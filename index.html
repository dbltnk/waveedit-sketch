<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WaveEdit</title>
    <link rel="stylesheet" href="gradients.css">
    <script src="audio-configs.js"></script>
    <style>
        :root {
            /* Color Variables */
            --primary-purple: #9b59b6;
            --primary-purple-dark: #8e44ad;
            --primary-red: #e74c3c;
            --primary-red-dark: #c0392b;
            --primary-orange: #f39c12;
            --primary-green: #27ae60;
            --primary-blue: #3498db;
            --primary-teal: #1abc9c;
            --primary-gray: #95a5a6;
            --primary-dark-blue: #34495e;
            --primary-dark-blue-alt: #2c3e50;

            /* Background Colors */
            --bg-primary: #1a1a1a;
            --bg-secondary: #2a2a2a;
            --bg-tertiary: #333;
            --bg-darker: #1e1e1e;
            --bg-transport: #252525;
            --bg-plugin-active: #443355;
            --bg-menu: #2c2c2c;
            --bg-hover: #404040;
            --bg-hover-light: #505050;
            --border-color: #444;
            --border-color-light: #555;
            --border-color-medium: #666;

            /* Text Colors */
            --text-primary: #ffffff;
            --text-secondary: #ecf0f1;
            --text-muted: #888;
            --text-light: #aaa;
            --text-very-light: #95a5a6;

            /* Effects */
            --shadow-subtle: 0 3px 8px rgba(0, 0, 0, 0.3);
            --shadow-glow: 0 0 10px rgba(243, 156, 18, 0.3);
            --transition-fast: all 0.2s ease;
            --transition-hover: all 0.1s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }

        /* Common Button Base */
        .btn-base {
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: bold;
        }

        .btn-round {
            border-radius: 50%;
        }

        .btn-rounded {
            border-radius: 5px;
        }

        /* Main App Layout */
        .app {
            display: flex;
            height: 100vh;
            flex-direction: column;
            overflow: hidden;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        /* Title Bar */
        .title-bar {
            height: 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            background: linear-gradient(90deg, var(--primary-purple-dark), var(--primary-purple));
        }

        .title-text {
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .window-controls {
            display: flex;
            gap: 10px;
        }

        .window-btn {
            border: none;
            cursor: pointer;
            transition: var(--transition-fast);
            font-weight: bold;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            color: white;
        }

        .minimize {
            background: var(--primary-orange);
        }

        .maximize {
            background: var(--primary-green);
        }

        .close {
            background: var(--primary-red);
        }

        /* Menu Bar */
        .menu-bar {
            height: 30px;
            display: flex;
            align-items: center;
            padding: 0 15px;
            background: var(--bg-menu);
            border-bottom: 1px solid var(--border-color);
            gap: 20px;
            flex-shrink: 0;
        }

        .menu-item {
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 3px;
            transition: var(--transition-fast);
        }

        .menu-item:hover {
            background: var(--bg-hover);
        }

        .menu-item.inactive {
            color: var(--text-muted);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .menu-item.inactive:hover {
            background: transparent;
        }

        /* Load dropdown styles */
        .load-menu {
            position: relative;
        }

        .load-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            min-width: 200px;
            background: var(--bg-menu);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            box-shadow: var(--shadow-subtle);
            z-index: 1000;
            display: none;
        }

        .load-dropdown.show {
            display: block;
        }

        .load-option {
            padding: 8px 12px;
            cursor: pointer;
            transition: var(--transition-fast);
            border-bottom: 1px solid var(--border-color);
        }

        .load-option:last-child {
            border-bottom: none;
        }

        .load-option:hover {
            background: var(--bg-hover);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        /* Panel Base */
        .panel-base {
            background: var(--bg-secondary);
            padding: 10px;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .left-panel {
            background: var(--bg-secondary);
            padding: 10px;
            overflow-y: auto;
            flex-shrink: 0;
            width: 200px;
            border-right: 1px solid var(--border-color);
        }

        .right-panel {
            background: var(--bg-secondary);
            padding: 10px;
            overflow-y: auto;
            flex-shrink: 0;
            width: 200px;
            border-left: 1px solid var(--border-color);
        }

        /* Center Panel */
        .center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-darker);
            overflow: hidden;
            position: relative;
        }

        /* Transport Controls */
        .transport-controls {
            height: 60px;
            background: var(--bg-transport);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
            flex-shrink: 0;
        }

        .transport-btn {
            border: none;
            cursor: pointer;
            transition: var(--transition-fast);
            font-weight: bold;
            border-radius: 5px;
            width: 40px;
            height: 40px;
            background: var(--bg-hover);
            color: white;
            font-size: 16px;
        }

        .transport-btn:hover {
            background: var(--bg-hover-light);
        }

        .time-display {
            margin-left: auto;
            font-family: 'Courier New', monospace;
            background: var(--bg-primary);
            padding: 8px 15px;
            border-radius: 5px;
        }

        /* Timeline */
        .timeline-container {
            flex: 1;
            padding: 20px 20px 100px 20px;
            /* Extra bottom padding for scrolling */
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            max-height: calc(100vh - 160px);
            /* Account for title bar, menu, transport controls */
        }

        /* Custom scrollbar for timeline */
        .timeline-container::-webkit-scrollbar {
            width: 12px;
        }

        .timeline-container::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 6px;
        }

        .timeline-container::-webkit-scrollbar-thumb {
            background: var(--border-color-medium);
            border-radius: 6px;
            border: 2px solid var(--bg-secondary);
        }

        .timeline-container::-webkit-scrollbar-thumb:hover {
            background: var(--text-light);
        }

        .timeline-ruler {
            height: 30px;
            background: var(--bg-secondary);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            border-radius: 3px;
        }

        .time-marker {
            margin-right: 40px;
            font-size: 12px;
            color: var(--text-light);
        }

        /* Merged View */
        .merged-view {
            min-height: 240px;
            max-height: 400px;
            /* Prevent merged view from becoming too tall */
            background: var(--bg-tertiary);
            margin-bottom: 20px;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }



        .merged-view::before {
            content: "MERGED VIEW";
            position: absolute;
            top: 5px;
            left: 10px;
            font-size: 12px;
            color: var(--text-light);
            z-index: 20;
        }

        /* Track layer in merged view */
        #merged.track-layer {
            min-height: 240px !important;
            max-height: 400px !important;
            /* Scale with merged view height */
        }

        /* Track content in merged view */
        #merged .track-content {
            min-height: 240px !important;
            max-height: 400px !important;
            /* Scale with merged view height */
            background: linear-gradient(90deg, var(--primary-dark-blue-alt) 0%, var(--primary-dark-blue-alt) 100%);
            position: relative;
        }

        .merged-waveform {
            position: absolute;
            bottom: 5px;
            left: 10px;
            right: 30px;
            height: 15px;
            border-radius: 2px;
            opacity: 0.8;
        }

        /* Track Layers */
        .track-layer {
            height: 60px;
            background: var(--bg-secondary);
            margin-bottom: 10px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            padding: 0 15px;
            position: relative;
        }

        .track-info {
            width: 150px;
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 4px 0;
            line-height: 0.6;
        }



        .track-controls {
            display: flex;
            gap: 5px;
            margin-left: auto;
            margin-right: 10px;
        }

        .track-content {
            flex: 1;
            height: 30px;
            margin-left: 20px;
            position: relative;
            border-radius: 3px;
        }

        /* Analyze button overlay */
        .analyze-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .analyze-btn {
            padding: 8px 16px;
            background: var(--primary-purple);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: var(--transition-fast);
        }

        .analyze-btn:hover {
            background: var(--primary-purple-dark);
            transform: translateY(-2px);
            box-shadow: var(--shadow-subtle);
        }

        /* Analysis minigame styles */
        .track-layer:not(#merged) {
            display: none;
        }

        .analysis-clip {
            position: absolute;
            height: 20px;
            top: 20px;
            border-radius: 3px;
            cursor: pointer;
            border: 2px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #666;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
            user-select: none;
            transition: all 0.2s ease;
            z-index: 20;
            background: #444;
            pointer-events: none;
        }

        .analysis-clip.revealed {
            animation: reveal 0.5s ease-out;
        }

        @keyframes reveal {
            0% {
                transform: scale(1);
                opacity: 0.5;
            }

            50% {
                transform: scale(1.2);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .selection-box {
            position: absolute;
            border: 2px dashed #1abc9c;
            background: rgba(26, 188, 156, 0.1);
            pointer-events: none;
            z-index: 30;
        }

        .selection-box.invalid {
            border-color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
        }

        /* Audio clip styling */
        .audio-clip {
            position: absolute;
            height: 20px;
            top: 5px;
            border-radius: 3px;
            cursor: pointer;
            border: 1.5px solid rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 0 0.5px rgba(0, 0, 0, 0.8), 0 2px 4px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.9);
            user-select: none;
            transition: all 0.2s ease;
            background: rgba(0, 0, 0, 0.1);
            overflow: hidden;
            font-style: normal !important;
            /* Prevent italic */
            z-index: 5;
            /* Base layer for clip */
        }

        /* Clip effect icons container */
        .clip-effects-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 12px;
            z-index: 1;
            /* Below text */
            pointer-events: none;
        }

        /* Clip effect icons */
        .clip-effect {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 8px;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
            line-height: 1;
            font-style: normal !important;
            /* Prevent italic */
        }

        /* Ensure text is always on top */
        .audio-clip::after {
            content: attr(data-clip);
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            /* Above everything */
            font-style: normal !important;
            /* Prevent italic */
        }

        /* Hide the original text content */
        .audio-clip {
            color: transparent;
        }

        .clip-effect+.clip-effect {
            left: 14px;
        }

        .clip-effect+.clip-effect+.clip-effect {
            left: 26px;
        }

        .clip-effect+.clip-effect+.clip-effect+.clip-effect {
            left: 38px;
        }

        /* Hide effect icons in merged view */
        #merged .clip-effects-container {
            display: none;
        }

        /* View mode toggle styles */
        .view-mode-toggle {
            display: flex;
            gap: 2px;
            margin-top: 4px;
        }

        .mode-btn {
            background: var(--bg-hover);
            border: 1px solid var(--border-color);
            color: var(--text-light);
            padding: 2px 6px;
            font-size: 0.65em;
            border-radius: 3px;
            cursor: pointer;
            transition: var(--transition-fast);
            flex: 1;
            text-align: center;
        }

        .mode-btn:hover {
            background: var(--bg-hover-light);
            border-color: var(--border-color-light);
        }

        .mode-btn.active {
            background: var(--primary-purple);
            border-color: var(--primary-purple-dark);
            color: var(--text-primary);
        }

        /* Add styles for merged view clips */
        #merged .audio-clip {
            pointer-events: none !important;
            opacity: 0.8;
            z-index: 1;
            height: 18px;
            top: 0;
            /* Reset top position, will be set by JS */
            cursor: default;
            border: 1.5px solid rgba(255, 255, 255, 0.7);
            box-shadow: 0 0 0 0.5px rgba(0, 0, 0, 0.9), 0 2px 6px rgba(0, 0, 0, 0.4);
        }

        #merged .audio-clip.revealed {
            opacity: 0.9;
            z-index: 2;
            pointer-events: none !important;
        }

        /* Layer-specific colors for merged view */
        /* find_the_murderer.wav layers */
        #merged .audio-clip[data-layer="evidence-recording"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="ghost-voices"] {
            color: #8e44ad;
        }

        #merged .audio-clip[data-layer="investigation"] {
            color: #27ae60;
        }

        #merged .audio-clip[data-layer="ambient-static-wave"] {
            color: #34495e;
        }

        /* morse_code.wav layers */
        #merged .audio-clip[data-layer="morse-signals"] {
            color: #3498db;
        }

        #merged .audio-clip[data-layer="radio-static"] {
            color: #95a5a6;
        }

        /* noise_profiling.wav layers */
        #merged .audio-clip[data-layer="vocal-track"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="background-noise"] {
            color: #f39c12;
        }

        #merged .audio-clip[data-layer="electrical-interference"] {
            color: #1abc9c;
        }

        #merged .audio-clip[data-layer="mechanical-sounds"] {
            color: #e67e22;
        }

        #merged .audio-clip[data-layer="digital-artifacts"] {
            color: #9b59b6;
        }

        #merged .audio-clip[data-layer="frequency-sweeps"] {
            color: #27ae60;
        }

        #merged .audio-clip[data-layer="calibration-tones"] {
            color: #34495e;
        }

        /* orchestra_hickups.wav layers */
        #merged .audio-clip[data-layer="violin-section"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="brass-section"] {
            color: #f39c12;
        }

        #merged .audio-clip[data-layer="woodwind-section"] {
            color: #27ae60;
        }

        #merged .audio-clip[data-layer="percussion-section"] {
            color: #9b59b6;
        }

        /* vocal_harmony.wav layers */
        #merged .audio-clip[data-layer="vocal-track"] {
            color: #e67e22;
        }

        /* getaway_analysis.wav layers */
        #merged .audio-clip[data-layer="digital-corruption"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="engine-signature"] {
            color: #3498db;
        }

        /* seasonal_birds.wav layers */
        #merged .audio-clip[data-layer="target-bird-call"] {
            color: #27ae60;
        }

        #merged .audio-clip[data-layer="forest-ambience"] {
            color: #2c3e50;
        }

        #merged .audio-clip[data-layer="viola-breathing"] {
            color: #8e44ad;
        }

        #merged .audio-clip[data-layer="unknown-presence"] {
            color: #e74c3c;
        }

        .audio-clip:hover {
            transform: translateY(-1px);
            box-shadow: 0 0 0 0.5px rgba(0, 0, 0, 0.9), 0 4px 12px rgba(0, 0, 0, 0.4);
            border-color: rgba(255, 255, 255, 0.8);
        }

        .audio-clip.selected {
            border: 2px solid #f39c12;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.3);
        }

        .audio-clip.dragging {
            z-index: 1000;
            transform: rotate(5deg);
            opacity: 0.8;
        }

        .audio-clip.disabled {
            opacity: 0.3;
            filter: grayscale(100%);
            pointer-events: none;
        }

        /* Layer-specific colors */
        /* find_the_murderer.wav layers */
        #evidence-recording .audio-clip {
            color: #e74c3c;
        }

        #ghost-voices .audio-clip {
            color: #8e44ad;
        }

        #investigation .audio-clip {
            color: #27ae60;
        }

        #ambient-static-wave .audio-clip {
            color: #34495e;
        }

        /* morse_code.wav layers */
        #morse-signals .audio-clip {
            color: #3498db;
        }

        #radio-static .audio-clip {
            color: #95a5a6;
        }

        /* noise_profiling.wav layers */
        #vocal-track .audio-clip {
            color: #e74c3c;
        }

        #background-noise .audio-clip {
            color: #f39c12;
        }

        #electrical-interference .audio-clip {
            color: #1abc9c;
        }

        #mechanical-sounds .audio-clip {
            color: #e67e22;
        }

        #digital-artifacts .audio-clip {
            color: #9b59b6;
        }

        #frequency-sweeps .audio-clip {
            color: #27ae60;
        }

        #calibration-tones .audio-clip {
            color: #34495e;
        }

        /* orchestra_hickups.wav layers */
        #violin-section .audio-clip {
            color: #e74c3c;
        }

        #brass-section .audio-clip {
            color: #f39c12;
        }

        #woodwind-section .audio-clip {
            color: #27ae60;
        }

        #percussion-section .audio-clip {
            color: #9b59b6;
        }

        /* vocal_harmony.wav layers - reusing #vocal-track but different color */
        #vocal-harmony .audio-clip {
            color: #e67e22;
        }

        /* getaway_analysis.wav layers */
        #digital-corruption .audio-clip {
            color: #e74c3c;
        }

        #engine-signature .audio-clip {
            color: #3498db;
        }

        /* seasonal_birds.wav layers */
        #target-bird-call .audio-clip {
            color: #27ae60;
        }

        #forest-ambience .audio-clip {
            color: #2c3e50;
        }

        #viola-breathing .audio-clip {
            color: #8e44ad;
        }

        #unknown-presence .audio-clip {
            color: #e74c3c;
        }

        /* Layer background colors to match clip colors with good contrast */
        /* find_the_murderer.wav layers */
        #evidence-recording {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        #ghost-voices {
            background: linear-gradient(90deg, rgba(142, 68, 173, 0.15), rgba(142, 68, 173, 0.08));
        }

        #investigation {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.15), rgba(39, 174, 96, 0.08));
        }

        #ambient-static-wave {
            background: linear-gradient(90deg, rgba(52, 73, 94, 0.15), rgba(52, 73, 94, 0.08));
        }

        /* morse_code.wav layers */
        #morse-signals {
            background: linear-gradient(90deg, rgba(52, 152, 219, 0.15), rgba(52, 152, 219, 0.08));
        }

        #radio-static {
            background: linear-gradient(90deg, rgba(149, 165, 166, 0.15), rgba(149, 165, 166, 0.08));
        }

        /* noise_profiling.wav layers */
        #vocal-track {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        #background-noise {
            background: linear-gradient(90deg, rgba(243, 156, 18, 0.15), rgba(243, 156, 18, 0.08));
        }

        #electrical-interference {
            background: linear-gradient(90deg, rgba(26, 188, 156, 0.15), rgba(26, 188, 156, 0.08));
        }

        #mechanical-sounds {
            background: linear-gradient(90deg, rgba(230, 126, 34, 0.15), rgba(230, 126, 34, 0.08));
        }

        #digital-artifacts {
            background: linear-gradient(90deg, rgba(155, 89, 182, 0.15), rgba(155, 89, 182, 0.08));
        }

        #frequency-sweeps {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.15), rgba(39, 174, 96, 0.08));
        }

        #calibration-tones {
            background: linear-gradient(90deg, rgba(52, 73, 94, 0.15), rgba(52, 73, 94, 0.08));
        }

        /* orchestra_hickups.wav layers */
        #violin-section {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        #brass-section {
            background: linear-gradient(90deg, rgba(243, 156, 18, 0.15), rgba(243, 156, 18, 0.08));
        }

        #woodwind-section {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.15), rgba(39, 174, 96, 0.08));
        }

        #percussion-section {
            background: linear-gradient(90deg, rgba(155, 89, 182, 0.15), rgba(155, 89, 182, 0.08));
        }

        /* vocal_harmony.wav layers - reusing vocal-track styling but different ID */
        #vocal-harmony {
            background: linear-gradient(90deg, rgba(230, 126, 34, 0.15), rgba(230, 126, 34, 0.08));
        }

        /* getaway_analysis.wav layers */
        #digital-corruption {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        #engine-signature {
            background: linear-gradient(90deg, rgba(52, 152, 219, 0.15), rgba(52, 152, 219, 0.08));
        }

        /* seasonal_birds.wav layers */
        #target-bird-call {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.15), rgba(39, 174, 96, 0.08));
        }

        #forest-ambience {
            background: linear-gradient(90deg, rgba(44, 62, 80, 0.15), rgba(44, 62, 80, 0.08));
        }

        #viola-breathing {
            background: linear-gradient(90deg, rgba(142, 68, 173, 0.15), rgba(142, 68, 173, 0.08));
        }

        #unknown-presence {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        /* Plugin applied effects */
        .clip-volume-boost {
            border-top: 2px solid #1abc9c;
        }

        .clip-denoise {
            opacity: 0.8;
            border-top: 2px solid #95a5a6;
        }

        .clip-frequency {
            border-top: 2px solid #3498db;
        }

        .clip-speed {
            font-style: italic;
            border-top: 2px solid #e67e22;
        }

        .clip-volume-boost::before {
            content: 'üîä';
            position: absolute;
            top: -12px;
            left: 2px;
            font-size: 8px;
        }

        .clip-denoise::before {
            content: 'üå´';
            position: absolute;
            top: -12px;
            left: 2px;
            font-size: 8px;
        }

        .clip-frequency::before {
            content: 'üìä';
            position: absolute;
            top: -12px;
            left: 2px;
            font-size: 8px;
        }

        .clip-speed::before {
            content: '‚ö°';
            position: absolute;
            top: -12px;
            left: 2px;
            font-size: 8px;
        }

        /* Track states */
        .track-muted {
            opacity: 0.4;
        }

        .track-soloed {
            box-shadow: 0 0 5px #f39c12;
        }

        .track-stereo .track-content {
            height: 50px;
        }

        .track-stereo .track-content::after {
            content: '';
            position: absolute;
            bottom: 5px;
            left: 0;
            right: 0;
            height: 18px;
            background: inherit;
            opacity: 0.6;
            border-radius: 3px;
        }

        /* Drag and drop zones */
        .drop-zone {
            min-height: 30px;
            border: 2px dashed transparent;
            margin: 2px 0;
            transition: all 0.3s ease;
        }

        .drop-zone.drag-over {
            border-color: #1abc9c;
            background: rgba(26, 188, 156, 0.1);
        }

        /* Audio control buttons */
        .audio-control {
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            transition: all 0.2s ease;
            font-size: 12px;
            border: 1px solid transparent;
        }

        .audio-control:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .audio-control.active {
            background: rgba(243, 156, 18, 0.3);
            border-color: #f39c12;
        }

        .audio-control.muted {
            color: #e74c3c;
        }

        .audio-control.soloed {
            color: #f39c12;
            background: rgba(243, 156, 18, 0.2);
        }

        /* Color themes */
        .waveedit .track-layer {
            border-left: 3px solid #9b59b6;
        }

        .waveedit .transport-controls {
            border-bottom-color: #9b59b6;
        }

        /* Tools Panel States */
        .tools-message {
            color: #888;
            font-size: 14px;
            text-align: center;
            padding: 20px;
            font-style: italic;
            border-bottom: 1px solid #444;
            margin-bottom: 15px;
        }

        .tools-container {
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        /* Selected Clip Display */
        .selected-clip-display {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 15px;
            display: none;
        }

        .selected-clip-title {
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .selected-clip-name {
            font-weight: bold;
            margin-bottom: 8px;
            color: #ecf0f1;
            font-size: 14px;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }

        .selected-clip-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .selected-clip-play-btn,
        .selected-clip-stop-btn {
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 50%;
            background: #9b59b6;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .selected-clip-play-btn:hover,
        .selected-clip-stop-btn:hover {
            background: #8e44ad;
            transform: scale(1.1);
        }

        .selected-clip-stop-btn {
            background: #e74c3c;
        }

        .selected-clip-stop-btn:hover {
            background: #c0392b;
        }

        .selected-clip-time {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #888;
        }

        .selected-clip-waveform {
            height: 20px;
            background: #333;
            border-radius: 3px;
            position: relative;
            overflow: hidden;
            border: 1px solid #444;
        }

        .selected-clip-playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #f39c12;
            left: 0%;
            pointer-events: none;
            z-index: 10;
            transition: left 0.1s ease;
        }

        /* Add slider styles */
        .slider-container {
            margin: 8px 0;
            position: relative;
            height: 20px;
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #888;
            margin-bottom: 4px;
        }

        .slider-track {
            position: relative;
            height: 4px;
            background: #444;
            border-radius: 2px;
            margin: 8px 0;
        }

        .slider-fill {
            position: absolute;
            height: 100%;
            background: #9b59b6;
            border-radius: 2px;
            width: 50%;
            /* Start at center */
            transition: width 0.1s ease;
        }

        .slider-thumb {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #fff;
            border: 2px solid #9b59b6;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            transition: all 0.1s ease;
        }

        .slider-thumb:hover {
            transform: translate(-50%, -50%) scale(1.2);
        }

        .plugin-section.disabled .slider-track,
        .plugin-section.disabled .slider-thumb {
            opacity: 0.3;
            pointer-events: none;
        }

        .plugin-section.disabled .slider-labels {
            opacity: 0.3;
        }

        /* Plugin sections */
        .plugin-section {
            margin-bottom: 15px;
            border: 1px solid var(--border-color-light);
            border-radius: 5px;
            padding: 10px;
            background: var(--bg-tertiary);
            cursor: pointer;
            transition: var(--transition-fast);
            position: relative;
        }

        .plugin-section:hover:not(.disabled) {
            background: var(--bg-hover);
            border-color: var(--primary-purple);
        }

        .plugin-section.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        .plugin-section.active {
            border-color: var(--primary-purple);
            background: var(--bg-plugin-active);
        }

        .plugin-section.active .plugin-title {
            color: var(--primary-purple);
        }

        .plugin-section.active .checkbox {
            background: var(--primary-purple);
            border-color: var(--primary-purple);
        }

        .plugin-section.active .checkbox::after {
            content: '‚úì';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            line-height: 1;
        }

        .plugin-section.disabled .checkbox {
            opacity: 0.3;
            pointer-events: none;
        }

        .plugin-title {
            font-weight: bold;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .checkbox {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-radius: 3px;
            background: transparent;
        }

        /* Ensure other track layers maintain their original height */
        .track-layer:not(#merged) {
            height: 60px !important;
        }

        .track-layer:not(#merged) .track-content {
            height: 30px !important;
        }

        /* Stem Isolation Loading Animation */
        .stem-isolation-overlay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            pointer-events: none;
        }

        .isolation-progress-container {
            background: var(--bg-secondary);
            border: 2px solid var(--primary-purple);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            text-align: center;
            min-width: 400px;
            backdrop-filter: blur(10px);
        }

        .isolation-title {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary-purple);
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(155, 89, 182, 0.5);
        }

        .isolation-status {
            font-size: 14px;
            color: var(--text-light);
            margin-bottom: 20px;
            min-height: 20px;
            font-style: italic;
        }

        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-purple), var(--primary-purple-dark));
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(155, 89, 182, 0.3);
        }

        .layer-status {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 10px;
        }

        /* MISC layer styles */
        .misc-layer {
            border-left: 3px solid #95a5a6;
        }

        .misc-layer .track-info span:first-child {
            color: #95a5a6;
        }

        /* Hidden small clips in MISC layers */
        .misc-layer .audio-clip.hidden-small {
            background: #444;
            color: #666;
            border: 2px solid #666;
            pointer-events: none;
        }

        .misc-layer .audio-clip.hidden-small::after {
            content: '???';
        }

        /* MISC layer colors */
        .misc-layer .audio-clip {
            color: #95a5a6;
        }

        .misc-layer {
            background: linear-gradient(90deg, rgba(149, 165, 166, 0.15), rgba(149, 165, 166, 0.08));
        }

        /* Merged view colors for MISC clips */
        #merged .audio-clip[data-layer^="misc-"] {
            color: #95a5a6;
        }

        /* MISC clips in merged view (zoom discovery) */
        .misc-clip-hidden {
            background: #444 !important;
            color: #666 !important;
            border: 2px solid #666 !important;
            pointer-events: auto !important;
            z-index: 50 !important;
            position: absolute !important;
        }

        /* Override the data-clip text display for MISC clips */
        .misc-clip-hidden::after {
            content: '???' !important;
        }

        /* Show true name for identified MISC clips */
        .identified::after {
            content: attr(data-clip) !important;
        }

        /* Zoom controls styles */
        .zoom-controls {
            position: absolute;
            bottom: 8px;
            right: 8px;
            display: none;
            /* Hidden until stem isolation is complete */
            gap: 4px;
            z-index: 15;
            pointer-events: auto;
        }

        .zoom-controls.enabled {
            display: flex;
        }

        .zoom-btn {
            width: 32px;
            height: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            user-select: none;
        }

        .zoom-btn:hover {
            background: var(--bg-hover);
            border-color: var(--primary-purple);
            transform: translateY(-1px);
        }

        .zoom-btn:active {
            transform: translateY(0px);
        }

        .zoom-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }

        .zoom-level-display {
            position: absolute;
            bottom: 32px;
            right: 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 10px;
            color: var(--text-light);
            z-index: 15;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            display: none;
            /* Hidden until stem isolation is complete */
        }

        .zoom-level-display.enabled {
            display: block;
        }

        .zoom-level-display.show {
            opacity: 1;
        }

        /* Waveform canvas styles */
        .waveform-canvas {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            /* Ensure pixel-perfect alignment with track content below */
            box-sizing: border-box;
        }

        /* Canvas waveform styling */

        /* Ensure perfect alignment between waveform and clips */

        /* Popup styles for ??? clips */
        .clip-popup {
            position: fixed;
            background: var(--bg-secondary);
            border: 2px solid var(--primary-purple);
            border-radius: 8px;
            padding: 15px 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            z-index: 2000;
            color: var(--text-primary);
            font-size: 14px;
            max-width: 300px;
            text-align: center;
            backdrop-filter: blur(10px);
            pointer-events: none;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.2s ease;
        }

        .clip-popup.show {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }

        .clip-popup::before {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid var(--primary-purple);
        }
    </style>
</head>

<body>
    <!-- Landing Screen -->
    <!-- Removed landing screen div -->

    <!-- Assembly App -->
    <!-- Removed Assembly app div -->

    <!-- WaveEdit App -->
    <div id="waveedit" class="app waveedit active">
        <div class="title-bar">
            <div class="title-text">
                üåä WaveEdit
            </div>
            <div class="window-controls">
                <button class="window-btn minimize">‚àí</button>
                <button class="window-btn maximize">‚ñ°</button>
                <button class="window-btn close">‚úï</button>
            </div>
        </div>

        <div class="menu-bar">
            <span class="menu-item load-menu" onclick="toggleLoadMenu(event)">Load ‚ñº
                <div class="load-dropdown" id="load-dropdown">
                    <div class="load-option" onclick="loadAudioFile('1_simple_getaway_analysis.wav', event)">
                        1_simple_getaway_analysis.wav</div>
                    <div class="load-option" onclick="loadAudioFile('2_simple_vocal_harmony.wav', event)">
                        2_simple_vocal_harmony.wav</div>
                    <div class="load-option" onclick="loadAudioFile('3_medium_morse_code.wav', event)">
                        3_medium_morse_code.wav
                    </div>
                    <div class="load-option" onclick="loadAudioFile('4_medium_seasonal_birds.wav', event)">
                        4_medium_seasonal_birds.wav</div>
                    <div class="load-option" onclick="loadAudioFile('5_medium_find_the_murderer.wav', event)">
                        5_medium_find_the_murderer.wav</div>
                    <div class="load-option" onclick="loadAudioFile('6_complex_noise_profiling.wav', event)">
                        6_complex_noise_profiling.wav
                    </div>
                    <div class="load-option" onclick="loadAudioFile('7_complex_orchestra_hickups.wav', event)">
                        7_complex_orchestra_hickups.wav
                    </div>
                </div>
            </span>
            <span class="menu-item inactive">Save</span>
            <span class="menu-item inactive">Analyze</span>
            <span class="menu-item inactive">Details</span>
            <span class="menu-item inactive">Plugins</span>
            <span class="menu-item inactive">Help</span>
            <span class="menu-item inactive">License</span>
        </div>

        <div class="main-content">
            <div class="center-panel">
                <div class="transport-controls">
                    <button class="transport-btn" onclick="toggleMainPlayback(event)">‚ñ∂</button>
                    <button class="transport-btn" onclick="stopMainPlayback(event)">‚èπ</button>
                    <button class="transport-btn" onclick="seekToStart(event)">‚èÆ</button>
                    <button class="transport-btn" onclick="seekToEnd(event)">‚è≠</button>
                    <div class="time-display">00:00.000 / 00:47.000</div>
                </div>

                <div class="track-layer" id="merged">
                    <div class="track-info">
                        <span
                            style="font-size: 0.7em; color: #ecf0f1; font-weight: 500; line-height: 1.2; display: block; margin-bottom: 4px;">1_simple_getaway_analysis.wav</span>
                        <div id="task-hint"
                            style="font-size: 0.75em; color: #f39c12; font-style: italic; line-height: 1.3; margin-bottom: 8px;">
                            Silence unwanted elements to reveal hidden evidence</div>
                        <div class="view-mode-toggle">
                            <button class="mode-btn active" data-mode="waveform" onclick="switchViewMode('waveform')">üìä
                                Wave</button>
                            <button class="mode-btn" data-mode="spectrogram" onclick="switchViewMode('spectrogram')">üåà
                                Spec</button>
                        </div>
                    </div>
                    <div class="track-content"
                        style="background: linear-gradient(90deg, #2c3e50 0%, #2c3e50 100%); position: relative;"
                        onclick="selectClip(event)">
                        <!-- Canvas-based waveform visualization -->
                        <!-- Playback marker -->
                        <div id="playback-marker"
                            style="position: absolute; top: 0; bottom: 0; width: 2px; background: #f39c12; left: 0%; pointer-events: none; z-index: 100;">
                        </div>
                        <!-- Stem Isolation button overlay -->
                        <div class="analyze-overlay">
                            <button class="analyze-btn" onclick="stemIsolation(event)">Stem Isolation</button>
                        </div>
                        <!-- Zoom controls -->
                        <div class="zoom-controls">
                            <button class="zoom-btn" onclick="zoomOut(event)"
                                title="Zoom Out (Mouse wheel down)">üîç‚àí</button>
                            <button class="zoom-btn" onclick="zoomIn(event)"
                                title="Zoom In (Mouse wheel up)">üîç+</button>
                        </div>
                        <!-- Zoom level display -->
                        <div class="zoom-level-display" id="zoom-level-display">100%</div>
                    </div>
                </div>

                <div class="track-layer" id="evidence-recording">
                    <div class="track-info">
                        <span style="font-size: 0.8em; color: #95a5a6;">Layer 1</span><br>
                        <span style="font-weight: bold; color: #ecf0f1;">Evidence_Recording</span>
                    </div>
                    <div class="track-content"
                        style="background: linear-gradient(90deg, #555 0%, #555 100%); position: relative;"
                        onclick="selectClip(event)">
                        <div class="audio-clip" data-clip="initial_scream"
                            style="left: 15%; width: 15%; height: 18px; top: 6px;" title="Initial scream">initial_scream
                        </div>
                        <div class="audio-clip" data-clip="struggle_sounds"
                            style="left: 45%; width: 20%; height: 18px; top: 6px;" title="Struggle sounds">
                            struggle_sounds</div>
                        <div class="audio-clip" data-clip="last_words"
                            style="left: 80%; width: 15%; height: 18px; top: 6px;" title="Last words">last_words</div>
                    </div>

                </div>

                <div class="track-layer" id="ghost-voices">
                    <div class="track-info">
                        <span style="font-size: 0.8em; color: #95a5a6;">Layer 2</span><br>
                        <span style="font-weight: bold; color: #ecf0f1;">Ghost_Voices</span>
                    </div>
                    <div class="track-content"
                        style="background: linear-gradient(90deg, #2c3e50 0%, #2c3e50 100%); position: relative;"
                        onclick="selectClip(event)">
                        <div class="audio-clip" data-clip="whisper_1"
                            style="left: 20%; width: 10%; height: 18px; top: 6px;" title="Second whisper">whisper_1
                        </div>
                        <div class="audio-clip" data-clip="whisper_2"
                            style="left: 35%; width: 10%; height: 18px; top: 6px;" title="Third whisper">whisper_2</div>
                        <div class="audio-clip" data-clip="whisper_3"
                            style="left: 55%; width: 7%; height: 18px; top: 6px;" title="Fourth whisper">whisper_3</div>
                        <div class="audio-clip" data-clip="whisper_4"
                            style="left: 70%; width: 9%; height: 18px; top: 6px;" title="Fifth whisper">whisper_4</div>
                    </div>

                </div>

                <div class="track-layer" id="investigation">
                    <div class="track-info">
                        <span style="font-size: 0.8em; color: #95a5a6;">Layer 3</span><br>
                        <span style="font-weight: bold; color: #ecf0f1;">Investigation_Notes</span>
                    </div>
                    <div class="track-content"
                        style="background: linear-gradient(90deg, #34495e 0%, #34495e 100%); position: relative;"
                        onclick="selectClip(event)">
                        <div class="audio-clip" data-clip="police_report"
                            style="left: 40%; width: 15%; height: 18px; top: 6px;" title="Police recording">
                            police_report</div>
                        <div class="audio-clip" data-clip="witness_statement"
                            style="left: 70%; width: 20%; height: 18px; top: 6px;" title="Witness statement">
                            witness_statement</div>
                    </div>

                </div>

                <div class="track-layer" id="ambient-static-wave">
                    <div class="track-info">
                        <span style="font-size: 0.8em; color: #95a5a6;">Layer 4</span><br>
                        <span style="font-weight: bold; color: #ecf0f1;">Ambient_Static</span>
                    </div>
                    <div class="track-content"
                        style="background: linear-gradient(90deg, #1a1a1a 0%, #1a1a1a 100%); position: relative;"
                        onclick="selectClip(event)">
                        <div class="audio-clip" data-clip="room_tone"
                            style="left: 10%; width: 20%; height: 18px; top: 6px;" title="Room tone">room_tone</div>
                        <div class="audio-clip" data-clip="static_burst"
                            style="left: 35%; width: 20%; height: 18px; top: 6px;" title="Static burst">static_burst
                        </div>
                        <div class="audio-clip" data-clip="tape_hiss"
                            style="left: 70%; width: 25%; height: 18px; top: 6px;" title="Tape hiss">tape_hiss</div>
                    </div>

                </div>
            </div>

            <div class="right-panel">
                <div class="tools-header">Tools</div>
                <div id="tools-message" class="tools-message">Run Stem Isolation to separate audio layers and unlock
                    tools.
                </div>
                <div id="selected-clip-display" class="selected-clip-display" style="display: none;">
                    <div class="selected-clip-title">Selected Clip:</div>
                    <div class="selected-clip-name"></div>
                    <div class="selected-clip-controls">
                        <button class="selected-clip-play-btn" onclick="toggleClipPlayback(event)">‚ñ∂</button>
                        <button class="selected-clip-stop-btn" onclick="stopClipPlayback(event)">‚èπ</button>
                        <span class="selected-clip-time">00:00.000</span>
                    </div>
                    <div class="selected-clip-waveform">
                        <div class="selected-clip-playhead"></div>
                    </div>
                </div>
                <div id="tools-container" class="tools-container" style="display: none;">
                    <!-- Plugins will be generated dynamically -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variable to store current layer configuration
        window.currentLayerConfig = null;

        let selectedPlugin = null;
        let selectedClip = null;
        let draggedClip = null;
        let discoveredClips = new Set();
        let isAnalyzed = false;
        let clipPlaybackInterval = null;
        let mergedMiscClips = []; // Track ??? clips in merged view
        let revealedMiscClips = new Set(); // Once revealed, always visible
        let clipStartTime = 0;
        let clipDuration = 0;
        let isClipPlaying = false;
        let currentPopup = null;

        // Zoom functionality
        let currentZoom = 1.0; // Current default is min zoom (100%)
        const minZoom = 1.0; // Current default is min (100%)
        const maxZoom = 10.0; // Can zoom in 10x from current (1000%)
        let zoomLevelTimeout = null;
        let waveformOffsetX = 0; // Track horizontal position for zooming
        let waveformCanvas = null;
        let waveformCtx = null;
        let waveformData = []; // Simulated waveform data
        let spectrogramData = []; // 2D spectrogram data [frequency][time]
        let originalClipData = new Map(); // Store original clip positions and sizes
        let zoomEnabled = false; // Track if zoom functionality is enabled

        // View mode state
        let currentViewMode = 'waveform'; // 'waveform' or 'spectrogram'
        let viewModePreferences = {}; // Store per-file view mode preferences

        // Show popup for ??? clips
        function showClipPopup(event) {
            event.stopPropagation();

            // Remove any existing popup
            if (currentPopup) {
                currentPopup.remove();
                currentPopup = null;
            }

            // Only show popup for hidden ??? clips
            if (!event.target.classList.contains('hidden-small')) {
                return;
            }

            // Create popup
            const popup = document.createElement('div');
            popup.className = 'clip-popup';
            popup.textContent = 'Zoom into the WAV file to find and identify this clip.';

            // Position popup above the clip
            const rect = event.target.getBoundingClientRect();
            popup.style.left = `${rect.left + (rect.width / 2)}px`;
            popup.style.top = `${rect.top - 10}px`;
            popup.style.transform = 'translate(-50%, -100%) scale(0.8)';

            document.body.appendChild(popup);
            currentPopup = popup;

            // Show popup with animation
            requestAnimationFrame(() => {
                popup.classList.add('show');
                popup.style.transform = 'translate(-50%, -100%) scale(1)';
            });

            // Auto-hide after 3 seconds
            setTimeout(() => {
                if (currentPopup === popup) {
                    popup.classList.remove('show');
                    setTimeout(() => {
                        if (currentPopup === popup) {
                            popup.remove();
                            currentPopup = null;
                        }
                    }, 200);
                }
            }, 3000);
        }

        // Close popup when clicking elsewhere
        document.addEventListener('click', function (event) {
            if (currentPopup && !event.target.classList.contains('hidden-small')) {
                currentPopup.classList.remove('show');
                setTimeout(() => {
                    if (currentPopup) {
                        currentPopup.remove();
                        currentPopup = null;
                    }
                }, 200);
            }
        });

        // Generate realistic transients for different audio types
        function generateTransients(filename, length, random) {
            const transients = new Array(length).fill(0);

            const transientPatterns = {
                '1_simple_getaway_analysis.wav': [
                    { time: 0.08, type: 'car_door_slam', intensity: 0.8 },
                    { time: 0.32, type: 'car_door_slam', intensity: 0.7 },
                    { time: 0.65, type: 'engine_rev', intensity: 0.6 },
                    { time: 0.89, type: 'tire_screech', intensity: 0.9 }
                ],
                '2_simple_vocal_harmony.wav': [
                    { time: 0.15, type: 'breath_intake', intensity: 0.3 },
                    { time: 0.35, type: 'consonant_pop', intensity: 0.4 },
                    { time: 0.58, type: 'breath_intake', intensity: 0.25 },
                    { time: 0.82, type: 'mouth_click', intensity: 0.2 }
                ],
                '3_medium_morse_code.wav': [
                    { time: 0.12, type: 'radio_pop', intensity: 0.7 },
                    { time: 0.45, type: 'static_burst', intensity: 0.8 },
                    { time: 0.67, type: 'carrier_glitch', intensity: 0.5 },
                    { time: 0.85, type: 'radio_pop', intensity: 0.6 }
                ],
                '4_medium_seasonal_birds.wav': [
                    { time: 0.22, type: 'wing_flap', intensity: 0.4 },
                    { time: 0.48, type: 'branch_snap', intensity: 0.6 },
                    { time: 0.73, type: 'bird_alarm', intensity: 0.8 },
                    { time: 0.91, type: 'rustling', intensity: 0.3 }
                ],
                '5_medium_find_the_murderer.wav': [
                    { time: 0.18, type: 'footstep', intensity: 0.5 },
                    { time: 0.41, type: 'door_creak', intensity: 0.7 },
                    { time: 0.59, type: 'glass_break', intensity: 0.9 },
                    { time: 0.78, type: 'metallic_clang', intensity: 0.6 }
                ],
                '6_complex_noise_profiling.wav': [
                    { time: 0.11, type: 'power_surge', intensity: 0.8 },
                    { time: 0.33, type: 'digital_glitch', intensity: 0.6 },
                    { time: 0.56, type: 'motor_start', intensity: 0.7 },
                    { time: 0.79, type: 'electrical_pop', intensity: 0.5 }
                ],
                '7_complex_orchestra_hickups.wav': [
                    { time: 0.21, type: 'string_snap', intensity: 0.8 },
                    { time: 0.44, type: 'bow_scratch', intensity: 0.4 },
                    { time: 0.67, type: 'chair_squeak', intensity: 0.3 },
                    { time: 0.89, type: 'music_stand_bump', intensity: 0.5 }
                ]
            };

            const patterns = transientPatterns[filename] || transientPatterns['5_medium_find_the_murderer.wav'];

            patterns.forEach(transient => {
                const startSample = Math.floor(transient.time * length);
                const transientLength = getTransientLength(transient.type);

                for (let i = 0; i < transientLength && startSample + i < length; i++) {
                    const progress = i / transientLength;
                    const envelope = getTransientEnvelope(transient.type, progress);
                    const amplitude = getTransientAmplitude(transient.type, progress, random) * transient.intensity;

                    transients[startSample + i] += amplitude * envelope;
                }
            });

            return transients;
        }

        // Get transient length in samples
        function getTransientLength(type) {
            const lengths = {
                'car_door_slam': 150,
                'engine_rev': 300,
                'tire_screech': 250,
                'breath_intake': 80,
                'consonant_pop': 20,
                'mouth_click': 15,
                'radio_pop': 40,
                'static_burst': 120,
                'carrier_glitch': 60,
                'wing_flap': 35,
                'branch_snap': 25,
                'bird_alarm': 180,
                'rustling': 90,
                'footstep': 50,
                'door_creak': 200,
                'glass_break': 300,
                'metallic_clang': 180,
                'power_surge': 100,
                'digital_glitch': 80,
                'motor_start': 220,
                'electrical_pop': 30,
                'string_snap': 40,
                'bow_scratch': 70,
                'chair_squeak': 60,
                'music_stand_bump': 45
            };
            return lengths[type] || 50;
        }

        // Get transient envelope shape
        function getTransientEnvelope(type, progress) {
            const envelopes = {
                'car_door_slam': Math.exp(-progress * 8) * (1 - progress),
                'engine_rev': Math.sin(progress * Math.PI) * (1 - progress * 0.3),
                'tire_screech': Math.sin(progress * Math.PI * 0.8) * Math.exp(-progress * 2),
                'breath_intake': Math.sin(progress * Math.PI) * 0.6,
                'consonant_pop': Math.exp(-progress * 12),
                'mouth_click': Math.exp(-progress * 15),
                'radio_pop': Math.exp(-progress * 10),
                'static_burst': Math.sin(progress * Math.PI) * (1 - progress * 0.5),
                'carrier_glitch': Math.abs(Math.sin(progress * Math.PI * 4)) * (1 - progress),
                'wing_flap': Math.sin(progress * Math.PI * 2) * (1 - progress),
                'branch_snap': Math.exp(-progress * 6),
                'bird_alarm': Math.sin(progress * Math.PI) * (1 - progress * 0.2),
                'rustling': Math.sin(progress * Math.PI) * 0.7,
                'footstep': Math.exp(-progress * 5) * (1 - progress),
                'door_creak': Math.sin(progress * Math.PI) * (1 - progress * 0.3),
                'glass_break': Math.exp(-progress * 4) * (1 - progress * 0.5),
                'metallic_clang': Math.exp(-progress * 3) * Math.sin(progress * Math.PI * 2),
                'power_surge': Math.sin(progress * Math.PI) * (1 - progress * 0.4),
                'digital_glitch': Math.abs(Math.sin(progress * Math.PI * 8)) * (1 - progress),
                'motor_start': Math.sin(progress * Math.PI) * (1 - progress * 0.2),
                'electrical_pop': Math.exp(-progress * 12),
                'string_snap': Math.exp(-progress * 8) * Math.sin(progress * Math.PI * 3),
                'bow_scratch': Math.sin(progress * Math.PI) * 0.8,
                'chair_squeak': Math.sin(progress * Math.PI) * 0.6,
                'music_stand_bump': Math.exp(-progress * 6)
            };
            return envelopes[type] || Math.exp(-progress * 5);
        }

        // Get transient amplitude pattern
        function getTransientAmplitude(type, progress, random) {
            const baseAmplitude = 0.6; // Increased from 0.4 for more prominence
            const patterns = {
                'car_door_slam': baseAmplitude * (0.8 + 0.4 * Math.sin(progress * Math.PI * 20)),
                'engine_rev': baseAmplitude * (0.6 + 0.4 * Math.sin(progress * Math.PI * 15)),
                'tire_screech': baseAmplitude * (0.7 + 0.6 * Math.sin(progress * Math.PI * 50)),
                'breath_intake': baseAmplitude * 0.3,
                'consonant_pop': baseAmplitude * (0.9 + 0.2 * (random() - 0.5)),
                'mouth_click': baseAmplitude * 0.4,
                'radio_pop': baseAmplitude * (0.8 + 0.4 * (random() - 0.5)),
                'static_burst': baseAmplitude * (0.6 + 0.8 * (random() - 0.5)),
                'carrier_glitch': baseAmplitude * (0.5 + 0.5 * Math.sin(progress * Math.PI * 12)),
                'wing_flap': baseAmplitude * (0.4 + 0.3 * Math.sin(progress * Math.PI * 8)),
                'branch_snap': baseAmplitude * (0.7 + 0.3 * (random() - 0.5)),
                'bird_alarm': baseAmplitude * (0.8 + 0.4 * Math.sin(progress * Math.PI * 25)),
                'rustling': baseAmplitude * (0.3 + 0.4 * (random() - 0.5)),
                'footstep': baseAmplitude * (0.6 + 0.2 * (random() - 0.5)),
                'door_creak': baseAmplitude * (0.5 + 0.3 * Math.sin(progress * Math.PI * 6)),
                'glass_break': baseAmplitude * (0.9 + 0.2 * (random() - 0.5)),
                'metallic_clang': baseAmplitude * (0.7 + 0.5 * Math.sin(progress * Math.PI * 18)),
                'power_surge': baseAmplitude * (0.8 + 0.4 * Math.sin(progress * Math.PI * 10)),
                'digital_glitch': baseAmplitude * (0.6 + 0.6 * (random() - 0.5)),
                'motor_start': baseAmplitude * (0.7 + 0.3 * Math.sin(progress * Math.PI * 12)),
                'electrical_pop': baseAmplitude * (0.9 + 0.2 * (random() - 0.5)),
                'string_snap': baseAmplitude * (0.8 + 0.4 * Math.sin(progress * Math.PI * 30)),
                'bow_scratch': baseAmplitude * (0.5 + 0.3 * Math.sin(progress * Math.PI * 15)),
                'chair_squeak': baseAmplitude * (0.4 + 0.2 * Math.sin(progress * Math.PI * 8)),
                'music_stand_bump': baseAmplitude * (0.6 + 0.3 * (random() - 0.5))
            };
            return patterns[type] || baseAmplitude * 0.5;
        }

        // Generate realistic waveform data based on filename
        function generateWaveformData(filename, length = 10000) {
            const data = [];

            // Use filename as seed for reproducible randomness
            const seed = hashString(filename);
            let random = seededRandom(seed);

            // Get file-specific characteristics
            const fileParams = getWaveformParams(filename);

            // Generate realistic transients based on file type
            const transients = generateTransients(filename, length, random);

            for (let i = 0; i < length; i++) {
                const t = i / length;
                let amplitude = 0;

                // Dense noise base (much more realistic)
                amplitude += (random() - 0.5) * fileParams.noiseLevel;

                // Multiple frequency components with file-specific characteristics
                for (let freq = 0; freq < fileParams.freqComponents.length; freq++) {
                    const component = fileParams.freqComponents[freq];
                    const phase = component.phase + t * Math.PI * component.frequency;
                    amplitude += Math.sin(phase) * component.amplitude * (0.5 + 0.5 * Math.sin(t * Math.PI * component.modulation));
                }

                // Add file-specific patterns
                if (fileParams.spikes && random() < fileParams.spikeChance) {
                    amplitude += (random() - 0.5) * fileParams.spikeIntensity;
                }

                // Inject realistic transients
                amplitude += transients[i];

                // Envelope shaping
                const envelope = fileParams.envelope(t);
                amplitude *= envelope;

                // Clip to reasonable range
                amplitude = Math.max(-1, Math.min(1, amplitude));

                data.push(amplitude);
            }
            return data;
        }

        // Simple hash function for string
        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            return Math.abs(hash);
        }

        // Seeded random number generator
        function seededRandom(seed) {
            let state = seed;
            return function () {
                state = (state * 1664525 + 1013904223) % Math.pow(2, 32);
                return state / Math.pow(2, 32);
            };
        }

        // Generate realistic spectrogram data based on filename
        function generateSpectrogramData(filename, width = 10000, height = 256) {
            const data = [];

            // Use filename as seed for reproducible randomness
            const seed = hashString(filename);
            let random = seededRandom(seed);

            // Get file-specific spectral characteristics
            const spectralParams = getSpectralParams(filename);

            // Initialize 2D array [frequency][time]
            for (let freq = 0; freq < height; freq++) {
                data[freq] = [];
                for (let time = 0; time < width; time++) {
                    data[freq][time] = 0;
                }
            }

            // Generate frequency content
            for (let time = 0; time < width; time++) {
                const t = time / width;

                // Add base noise floor
                for (let freq = 0; freq < height; freq++) {
                    data[freq][time] = random() * spectralParams.noiseFloor;
                }

                // Add frequency components based on file characteristics
                spectralParams.frequencyBands.forEach(band => {
                    const startFreq = Math.floor((band.freqRange[0] / 20000) * height);
                    const endFreq = Math.floor((band.freqRange[1] / 20000) * height);

                    for (let freq = startFreq; freq < endFreq; freq++) {
                        const freqNorm = endFreq > startFreq ? (freq - startFreq) / (endFreq - startFreq) : 0;
                        const timeVariation = Math.sin(t * Math.PI * band.timeModulation + band.phase);
                        const freqVariation = Math.sin(freqNorm * Math.PI * band.freqModulation);

                        let intensity = band.baseIntensity;
                        intensity *= (0.5 + 0.5 * timeVariation);
                        intensity *= (0.7 + 0.3 * freqVariation);
                        intensity += (random() - 0.5) * band.randomness;

                        data[freq][time] = Math.max(data[freq][time], Math.max(0, Math.min(1, intensity)));
                    }
                });

                // Add transient events
                if (random() < spectralParams.transientChance) {
                    const centerFreq = Math.floor(random() * height);
                    const bandwidth = Math.floor(10 + random() * 30);
                    const intensity = 0.3 + random() * 0.7;

                    for (let f = Math.max(0, centerFreq - bandwidth); f < Math.min(height, centerFreq + bandwidth); f++) {
                        const distance = Math.abs(f - centerFreq);
                        const falloff = Math.max(0, 1 - distance / bandwidth);
                        data[f][time] = Math.max(data[f][time], intensity * falloff);
                    }
                }
            }

            return data;
        }

        // Get spectral parameters for different file types
        function getSpectralParams(filename) {
            const params = {
                '1_simple_getaway_analysis.wav': {
                    noiseFloor: 0.05,
                    transientChance: 0.02,
                    frequencyBands: [
                        { freqRange: [20, 200], baseIntensity: 0.4, timeModulation: 2, freqModulation: 1, phase: 0, randomness: 0.1 }, // Engine rumble
                        { freqRange: [200, 2000], baseIntensity: 0.3, timeModulation: 5, freqModulation: 3, phase: 1.2, randomness: 0.15 }, // Dialogue
                        { freqRange: [2000, 8000], baseIntensity: 0.2, timeModulation: 12, freqModulation: 8, phase: 2.1, randomness: 0.2 }, // Clarity
                        { freqRange: [8000, 20000], baseIntensity: 0.15, timeModulation: 20, freqModulation: 15, phase: 0.5, randomness: 0.25 } // Digital artifacts
                    ]
                },
                '2_simple_vocal_harmony.wav': {
                    noiseFloor: 0.02,
                    transientChance: 0.005,
                    frequencyBands: [
                        { freqRange: [80, 300], baseIntensity: 0.2, timeModulation: 1, freqModulation: 2, phase: 0, randomness: 0.05 }, // Fundamental
                        { freqRange: [300, 1500], baseIntensity: 0.6, timeModulation: 3, freqModulation: 5, phase: 0.3, randomness: 0.1 }, // Vocals
                        { freqRange: [1500, 4000], baseIntensity: 0.4, timeModulation: 8, freqModulation: 12, phase: 1.8, randomness: 0.1 }, // Harmonics
                        { freqRange: [4000, 12000], baseIntensity: 0.25, timeModulation: 15, freqModulation: 20, phase: 2.7, randomness: 0.15 } // Brightness
                    ]
                },
                '3_medium_morse_code.wav': {
                    noiseFloor: 0.08,
                    transientChance: 0.04,
                    frequencyBands: [
                        { freqRange: [600, 1000], baseIntensity: 0.8, timeModulation: 16, freqModulation: 0, phase: 0, randomness: 0.1 }, // Carrier tone
                        { freqRange: [1000, 2000], baseIntensity: 0.3, timeModulation: 16, freqModulation: 2, phase: 0.5, randomness: 0.15 }, // Harmonics
                        { freqRange: [50, 500], baseIntensity: 0.3, timeModulation: 0.5, freqModulation: 3, phase: 1.2, randomness: 0.2 }, // Static
                        { freqRange: [5000, 15000], baseIntensity: 0.2, timeModulation: 25, freqModulation: 30, phase: 2.3, randomness: 0.3 } // Radio noise
                    ]
                },
                '4_medium_seasonal_birds.wav': {
                    noiseFloor: 0.06,
                    transientChance: 0.03,
                    frequencyBands: [
                        { freqRange: [100, 800], baseIntensity: 0.3, timeModulation: 2, freqModulation: 4, phase: 0, randomness: 0.2 }, // Forest ambience
                        { freqRange: [1000, 4000], baseIntensity: 0.4, timeModulation: 8, freqModulation: 15, phase: 1.5, randomness: 0.25 }, // Mid-range calls
                        { freqRange: [4000, 12000], baseIntensity: 0.6, timeModulation: 25, freqModulation: 60, phase: 0.8, randomness: 0.3 }, // Bird chirps
                        { freqRange: [12000, 20000], baseIntensity: 0.3, timeModulation: 80, freqModulation: 80, phase: 2.9, randomness: 0.4 } // High-freq details
                    ]
                },
                '5_medium_find_the_murderer.wav': {
                    noiseFloor: 0.1,
                    transientChance: 0.025,
                    frequencyBands: [
                        { freqRange: [20, 150], baseIntensity: 0.3, timeModulation: 1.5, freqModulation: 2, phase: 0, randomness: 0.15 }, // Low rumble
                        { freqRange: [150, 800], baseIntensity: 0.4, timeModulation: 4, freqModulation: 6, phase: 1.1, randomness: 0.2 }, // Mystery tones
                        { freqRange: [800, 3000], baseIntensity: 0.5, timeModulation: 12, freqModulation: 20, phase: 2.3, randomness: 0.25 }, // Evidence sounds
                        { freqRange: [3000, 8000], baseIntensity: 0.35, timeModulation: 28, freqModulation: 45, phase: 0.7, randomness: 0.3 }, // Clarity range
                        { freqRange: [8000, 20000], baseIntensity: 0.25, timeModulation: 120, freqModulation: 120, phase: 1.9, randomness: 0.35 } // Artifacts
                    ]
                },
                '6_complex_noise_profiling.wav': {
                    noiseFloor: 0.15,
                    transientChance: 0.05,
                    frequencyBands: [
                        { freqRange: [20, 500], baseIntensity: 0.4, timeModulation: 3, freqModulation: 6, phase: 0, randomness: 0.3 }, // Low noise
                        { freqRange: [500, 2000], baseIntensity: 0.5, timeModulation: 18, freqModulation: 35, phase: 0.9, randomness: 0.35 }, // Mid noise
                        { freqRange: [2000, 8000], baseIntensity: 0.6, timeModulation: 70, freqModulation: 70, phase: 1.7, randomness: 0.4 }, // High noise
                        { freqRange: [8000, 20000], baseIntensity: 0.3, timeModulation: 150, freqModulation: 150, phase: 2.5, randomness: 0.45 } // Very high noise
                    ]
                },
                '7_complex_orchestra_hickups.wav': {
                    noiseFloor: 0.03,
                    transientChance: 0.015,
                    frequencyBands: [
                        { freqRange: [40, 200], baseIntensity: 0.4, timeModulation: 1, freqModulation: 3, phase: 0, randomness: 0.08 }, // Double bass, cello
                        { freqRange: [200, 800], baseIntensity: 0.5, timeModulation: 8, freqModulation: 20, phase: 0.6, randomness: 0.1 }, // Viola, low strings
                        { freqRange: [800, 3000], baseIntensity: 0.6, timeModulation: 20, freqModulation: 50, phase: 1.9, randomness: 0.12 }, // Violin, woodwinds
                        { freqRange: [3000, 8000], baseIntensity: 0.4, timeModulation: 50, freqModulation: 100, phase: 2.7, randomness: 0.15 }, // Brass, upper harmonics
                        { freqRange: [8000, 20000], baseIntensity: 0.2, timeModulation: 100, freqModulation: 100, phase: 1.3, randomness: 0.2 } // Shimmer, hall acoustics
                    ]
                }
            };

            return params[filename] || params['5_medium_find_the_murderer.wav']; // Default fallback
        }

        // Get waveform parameters for different file types
        function getWaveformParams(filename) {
            const params = {
                '1_simple_getaway_analysis.wav': {
                    noiseLevel: 0.4,
                    freqComponents: [
                        { frequency: 2, amplitude: 0.3, phase: 0, modulation: 1 },
                        { frequency: 15, amplitude: 0.2, phase: 1.2, modulation: 3 },
                        { frequency: 80, amplitude: 0.15, phase: 2.1, modulation: 8 },
                        { frequency: 320, amplitude: 0.1, phase: 0.5, modulation: 20 }
                    ],
                    spikes: true,
                    spikeChance: 0.03,
                    spikeIntensity: 0.6,
                    envelope: (t) => {
                        // Getaway analysis: Engine revving + dialog gaps
                        const enginePulse = 0.7 + 0.3 * Math.sin(t * Math.PI * 2.1); // Engine rhythm
                        const speechGaps = Math.max(0.1, Math.sin(t * Math.PI * 8.5) * 0.6 + 0.4); // Speech pauses
                        const carEvents = t > 0.3 && t < 0.35 ? 1.2 : 1; // Car door slam
                        return Math.min(1, enginePulse * speechGaps * carEvents);
                    }
                },
                '2_simple_vocal_harmony.wav': {
                    noiseLevel: 0.25,
                    freqComponents: [
                        { frequency: 1, amplitude: 0.4, phase: 0, modulation: 0.5 },
                        { frequency: 8, amplitude: 0.3, phase: 0.3, modulation: 2 },
                        { frequency: 25, amplitude: 0.2, phase: 1.8, modulation: 5 },
                        { frequency: 120, amplitude: 0.15, phase: 2.7, modulation: 12 },
                        { frequency: 480, amplitude: 0.08, phase: 1.1, modulation: 30 }
                    ],
                    spikes: false,
                    envelope: (t) => {
                        // Vocal harmony: Breathing + phrase structure
                        const breathing = 0.3 + 0.7 * Math.sin(t * Math.PI * 1.2); // Natural breathing
                        const phrases = Math.max(0.2, Math.sin(t * Math.PI * 3.8) * 0.6 + 0.4); // Musical phrases
                        const dynamics = 0.8 + 0.2 * Math.sin(t * Math.PI * 0.5); // Overall dynamics
                        return breathing * phrases * dynamics;
                    }
                },
                '3_medium_morse_code.wav': {
                    noiseLevel: 0.35,
                    freqComponents: [
                        { frequency: 12, amplitude: 0.5, phase: 0, modulation: 0 },
                        { frequency: 24, amplitude: 0.3, phase: 0.5, modulation: 0 },
                        { frequency: 180, amplitude: 0.2, phase: 1.2, modulation: 15 },
                        { frequency: 800, amplitude: 0.1, phase: 2.3, modulation: 40 }
                    ],
                    spikes: true,
                    spikeChance: 0.02,
                    spikeIntensity: 0.8,
                    envelope: (t) => {
                        // Morse code: Sharp on/off pulses + static bursts
                        const morsePattern = Math.abs(Math.sin(t * Math.PI * 24)) > 0.6 ? 0.9 : 0.15; // Morse pulses
                        const staticBursts = t > 0.6 && t < 0.65 ? 1.3 : 1; // Static interference
                        const carrierTone = 0.4 + 0.3 * Math.sin(t * Math.PI * 0.8); // Carrier modulation
                        return Math.min(1.2, morsePattern * staticBursts * carrierTone);
                    }
                },
                '4_medium_seasonal_birds.wav': {
                    noiseLevel: 0.45,
                    freqComponents: [
                        { frequency: 3, amplitude: 0.2, phase: 0, modulation: 4 },
                        { frequency: 18, amplitude: 0.25, phase: 1.5, modulation: 8 },
                        { frequency: 75, amplitude: 0.3, phase: 0.8, modulation: 25 },
                        { frequency: 300, amplitude: 0.2, phase: 2.9, modulation: 60 },
                        { frequency: 1200, amplitude: 0.15, phase: 1.7, modulation: 80 }
                    ],
                    spikes: true,
                    spikeChance: 0.04,
                    spikeIntensity: 0.5,
                    envelope: (t) => {
                        // Bird calls: Chirp bursts + forest ambience cycles
                        const birdChirps = Math.sin(t * Math.PI * 12) > 0.4 ? 0.8 + 0.2 * Math.sin(t * Math.PI * 40) : 0.3; // Sharp chirps
                        const forestBreeze = 0.2 + 0.3 * Math.sin(t * Math.PI * 0.6); // Wind through trees
                        const seasonalActivity = 0.6 + 0.4 * Math.sin(t * Math.PI * 2.1); // Seasonal variation
                        return birdChirps * forestBreeze * seasonalActivity;
                    }
                },
                '5_medium_find_the_murderer.wav': {
                    noiseLevel: 0.5,
                    freqComponents: [
                        { frequency: 1.5, amplitude: 0.25, phase: 0, modulation: 2 },
                        { frequency: 6, amplitude: 0.2, phase: 1.1, modulation: 4 },
                        { frequency: 20, amplitude: 0.3, phase: 2.3, modulation: 12 },
                        { frequency: 95, amplitude: 0.25, phase: 0.7, modulation: 28 },
                        { frequency: 380, amplitude: 0.2, phase: 1.9, modulation: 45 },
                        { frequency: 1500, amplitude: 0.1, phase: 2.8, modulation: 120 }
                    ],
                    spikes: true,
                    spikeChance: 0.025,
                    spikeIntensity: 0.7,
                    envelope: (t) => {
                        // Mystery/evidence: Dramatic tension + sudden reveals
                        const tension = 0.4 + 0.3 * Math.sin(t * Math.PI * 1.5); // Building tension
                        const reveals = t > 0.25 && t < 0.3 ? 1.4 : (t > 0.7 && t < 0.75 ? 1.2 : 1); // Evidence reveals
                        const whispers = Math.sin(t * Math.PI * 20) > 0.8 ? 0.6 : 1; // Quiet whisper moments
                        const atmosphericDread = 0.3 + 0.5 * Math.sin(t * Math.PI * 0.4); // Ominous undertone
                        return tension * reveals * whispers * atmosphericDread;
                    }
                },
                '6_complex_noise_profiling.wav': {
                    noiseLevel: 0.6,
                    freqComponents: [
                        { frequency: 4, amplitude: 0.15, phase: 0, modulation: 3 },
                        { frequency: 12, amplitude: 0.2, phase: 0.9, modulation: 6 },
                        { frequency: 35, amplitude: 0.25, phase: 1.7, modulation: 18 },
                        { frequency: 140, amplitude: 0.3, phase: 2.5, modulation: 35 },
                        { frequency: 560, amplitude: 0.2, phase: 0.3, modulation: 70 },
                        { frequency: 2200, amplitude: 0.15, phase: 1.4, modulation: 150 }
                    ],
                    spikes: true,
                    spikeChance: 0.05,
                    spikeIntensity: 0.4,
                    envelope: (t) => {
                        // Complex noise: Variable interference patterns
                        const electricalSurges = 0.5 + 0.4 * Math.sin(t * Math.PI * 4.2); // Power fluctuations
                        const digitalGlitches = Math.sin(t * Math.PI * 15) > 0.7 ? 0.3 : 1; // Digital dropouts
                        const mechanicalNoise = 0.6 + 0.3 * Math.sin(t * Math.PI * 8.7); // Mechanical interference
                        const testToneEvents = t > 0.1 && t < 0.15 ? 1.5 : (t > 0.8 && t < 0.85 ? 1.3 : 1); // Calibration tones
                        return electricalSurges * digitalGlitches * mechanicalNoise * testToneEvents;
                    }
                },
                '7_complex_orchestra_hickups.wav': {
                    noiseLevel: 0.3,
                    freqComponents: [
                        { frequency: 0.8, amplitude: 0.35, phase: 0, modulation: 1 },
                        { frequency: 4, amplitude: 0.3, phase: 0.6, modulation: 3 },
                        { frequency: 16, amplitude: 0.25, phase: 1.9, modulation: 8 },
                        { frequency: 64, amplitude: 0.2, phase: 2.7, modulation: 20 },
                        { frequency: 256, amplitude: 0.15, phase: 1.3, modulation: 50 },
                        { frequency: 1024, amplitude: 0.1, phase: 0.1, modulation: 100 }
                    ],
                    spikes: true,
                    spikeChance: 0.015,
                    spikeIntensity: 0.8,
                    envelope: (t) => {
                        // Orchestra with hiccups: Musical phrases with sudden mistakes
                        const musicalPhrase = 0.7 + 0.2 * Math.sin(t * Math.PI * 1.1); // Natural musical flow
                        const orchestralBuilds = 0.5 + 0.5 * Math.sin(t * Math.PI * 0.3); // Dynamic swells
                        const hiccups = (t > 0.2 && t < 0.22) || (t > 0.55 && t < 0.57) ? 0.1 : 1; // Performance mistakes
                        const recoveries = (t > 0.22 && t < 0.25) || (t > 0.57 && t < 0.6) ? 1.3 : 1; // Post-mistake emphasis
                        return Math.min(1.2, musicalPhrase * orchestralBuilds * hiccups * recoveries);
                    }
                }
            };

            return params[filename] || params['5_medium_find_the_murderer.wav']; // Default fallback
        }

        // Map intensity value to RGB color (traditional spectrogram colors)
        function intensityToColor(intensity) {
            // Clamp intensity to 0-1 range
            intensity = Math.max(0, Math.min(1, intensity));

            // Traditional spectrogram color mapping: Black -> Blue -> Green -> Yellow -> Red -> White
            if (intensity < 0.2) {
                // Black to Blue
                const t = intensity / 0.2;
                return [0, 0, Math.floor(t * 128)];
            } else if (intensity < 0.4) {
                // Blue to Green
                const t = (intensity - 0.2) / 0.2;
                return [0, Math.floor(t * 255), 128 - Math.floor(t * 128)];
            } else if (intensity < 0.6) {
                // Green to Yellow
                const t = (intensity - 0.4) / 0.2;
                return [Math.floor(t * 255), 255, 0];
            } else if (intensity < 0.8) {
                // Yellow to Red
                const t = (intensity - 0.6) / 0.2;
                return [255, 255 - Math.floor(t * 255), 0];
            } else {
                // Red to White
                const t = (intensity - 0.8) / 0.2;
                return [255, Math.floor(t * 255), Math.floor(t * 255)];
            }
        }

        // Draw visualization based on current mode
        function drawVisualization() {
            if (!waveformCanvas || !waveformCtx) return;

            const width = waveformCanvas.width;
            const height = waveformCanvas.height;

            // Clear canvas
            waveformCtx.clearRect(0, 0, width, height);

            if (currentViewMode === 'waveform') {
                drawWaveformMode(width, height);
            } else if (currentViewMode === 'spectrogram') {
                drawSpectrogramMode(width, height);
            }
        }

        // Draw waveform mode
        function drawWaveformMode(width, height) {
            const centerY = height / 2;

            // Calculate visible range: fewer samples = more zoom (matches spectrogram logic)
            const waveformWidth = waveformData.length; // 10,000 samples
            const visibleSamples = waveformWidth / currentZoom;
            const maxStartSample = Math.max(0, waveformWidth - visibleSamples);
            const startSample = Math.floor(waveformOffsetX * maxStartSample);
            const endSample = Math.min(waveformWidth, startSample + visibleSamples);

            // Set waveform style
            waveformCtx.strokeStyle = getCurrentWaveformColor();
            waveformCtx.lineWidth = 2; // Increased from 1 for better visibility
            waveformCtx.beginPath();

            for (let x = 0; x < width; x++) {
                // Map canvas X to waveform position within visible range
                const timeProgress = x / width;
                const sampleIndex = Math.floor(startSample + timeProgress * (endSample - startSample));

                if (sampleIndex >= 0 && sampleIndex < waveformWidth) {
                    const amplitude = waveformData[sampleIndex];
                    const y = centerY + amplitude * (centerY - 5); // Leave 5px margin top/bottom

                    if (x === 0) {
                        waveformCtx.moveTo(x, y);
                    } else {
                        waveformCtx.lineTo(x, y);
                    }
                }
            }

            waveformCtx.stroke();

            // Draw subtle alignment markers at key percentages (only in waveform mode)
            if (currentViewMode === 'waveform') {
                waveformCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                waveformCtx.lineWidth = 1;

                // 15% mark (where first clip often starts)
                const mark15 = width * 0.15;
                waveformCtx.beginPath();
                waveformCtx.moveTo(mark15, 0);
                waveformCtx.lineTo(mark15, height);
                waveformCtx.stroke();

                // 50% mark (center reference)
                const mark50 = width * 0.5;
                waveformCtx.beginPath();
                waveformCtx.moveTo(mark50, 0);
                waveformCtx.lineTo(mark50, height);
                waveformCtx.stroke();
            }
        }

        // Draw spectrogram mode
        function drawSpectrogramMode(width, height) {
            if (spectrogramData.length === 0) return;

            // Create ImageData for pixel manipulation
            const imageData = waveformCtx.createImageData(width, height);
            const data = imageData.data;

            // Calculate which portion of spectrogram to show based on zoom
            const spectrogramWidth = spectrogramData[0].length; // 10,000 samples
            const spectrogramHeight = spectrogramData.length;   // 256 frequency bins

            // Calculate visible range: fewer samples = more zoom
            const visibleSamples = spectrogramWidth / currentZoom;
            const maxStartSample = Math.max(0, spectrogramWidth - visibleSamples);
            const startSample = Math.floor(waveformOffsetX * maxStartSample);
            const endSample = Math.min(spectrogramWidth, startSample + visibleSamples);

            // Render each pixel
            for (let x = 0; x < width; x++) {
                // Map canvas X to spectrogram time position within visible range
                const timeProgress = x / width;
                const spectrogramX = Math.floor(startSample + timeProgress * (endSample - startSample));

                if (spectrogramX >= 0 && spectrogramX < spectrogramWidth) {
                    for (let y = 0; y < height; y++) {
                        // Map canvas Y to spectrogram frequency (flip Y axis)
                        const spectrogramY = Math.floor(((height - 1 - y) / height) * spectrogramHeight);

                        if (spectrogramY >= 0 && spectrogramY < spectrogramHeight) {
                            const intensity = spectrogramData[spectrogramY][spectrogramX];
                            const [r, g, b] = intensityToColor(intensity);

                            const pixelIndex = (y * width + x) * 4;
                            data[pixelIndex] = r;     // Red
                            data[pixelIndex + 1] = g; // Green
                            data[pixelIndex + 2] = b; // Blue
                            data[pixelIndex + 3] = 255; // Alpha
                        }
                    }
                }
            }

            // Draw the image data to canvas
            waveformCtx.putImageData(imageData, 0, 0);

            // Draw subtle alignment markers at key percentages (for spectrogram mode too)
            waveformCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            waveformCtx.lineWidth = 1;

            // 15% mark (where first clip often starts)
            const mark15 = width * 0.15;
            waveformCtx.beginPath();
            waveformCtx.moveTo(mark15, 0);
            waveformCtx.lineTo(mark15, height);
            waveformCtx.stroke();

            // 50% mark (center reference)
            const mark50 = width * 0.5;
            waveformCtx.beginPath();
            waveformCtx.moveTo(mark50, 0);
            waveformCtx.lineTo(mark50, height);
            waveformCtx.stroke();
        }

        // Get current waveform color based on loaded file
        function getCurrentWaveformColor() {
            // Colors matching the main gradient themes
            const colors = {
                '1_simple_getaway_analysis.wav': '#e74c3c',
                '2_simple_vocal_harmony.wav': '#e67e22',
                '3_medium_morse_code.wav': '#3498db',
                '4_medium_seasonal_birds.wav': '#27ae60',
                '5_medium_find_the_murderer.wav': '#9b59b6',
                '6_complex_noise_profiling.wav': '#f39c12',
                '7_complex_orchestra_hickups.wav': '#e74c3c'
            };

            const currentFile = document.querySelector('#merged .track-info span:first-child')?.textContent;
            return colors[currentFile] || '#9b59b6';
        }

        // Zoom functionality
        function updateZoom(targetX = null) {
            // Adjust offset position to keep target point in view
            if (targetX !== null && waveformCanvas) {
                const containerWidth = waveformCanvas.width;
                const targetPercent = targetX / containerWidth;

                // Calculate new offset to keep target centered
                const maxOffset = 1 - (1 / currentZoom);
                waveformOffsetX = targetPercent * maxOffset;
                waveformOffsetX = Math.max(0, Math.min(maxOffset, waveformOffsetX));
            }

            // Redraw visualization with new zoom level
            drawVisualization();

            // Update clip positions and sizes based on zoom
            updateClipPositions();

            // Update zoom level display
            const zoomDisplay = document.getElementById('zoom-level-display');
            if (zoomDisplay) {
                const percentage = Math.round(100 * currentZoom);
                zoomDisplay.textContent = `${percentage}%`;
                zoomDisplay.classList.add('show');

                // Hide after 2 seconds
                clearTimeout(zoomLevelTimeout);
                zoomLevelTimeout = setTimeout(() => {
                    zoomDisplay.classList.remove('show');
                }, 2000);
            }

            // Update button states
            updateZoomButtons();
        }

        function updateZoomButtons() {
            const zoomInBtn = document.querySelector('.zoom-btn[onclick*="zoomIn"]');
            const zoomOutBtn = document.querySelector('.zoom-btn[onclick*="zoomOut"]');

            if (zoomInBtn) {
                zoomInBtn.classList.toggle('disabled', !zoomEnabled || currentZoom >= maxZoom);
            }
            if (zoomOutBtn) {
                zoomOutBtn.classList.toggle('disabled', !zoomEnabled || currentZoom <= minZoom);
            }
        }

        // Enable zoom functionality and show controls
        function enableZoomControls() {
            zoomEnabled = true;

            // Show zoom controls
            const zoomControls = document.querySelector('.zoom-controls');
            const zoomDisplay = document.getElementById('zoom-level-display');

            if (zoomControls) {
                zoomControls.classList.add('enabled');
            }
            if (zoomDisplay) {
                zoomDisplay.classList.add('enabled');
            }

            // Update button states
            updateZoomButtons();
        }

        function zoomIn(event) {
            event.stopPropagation();
            if (!zoomEnabled || currentZoom >= maxZoom) return;

            currentZoom = Math.min(maxZoom, currentZoom * 1.25);
            // Zoom to center for button clicks
            const container = document.querySelector('#merged .track-content');
            const centerX = container ? container.offsetWidth / 2 : 0;
            updateZoom(centerX);
        }

        function zoomOut(event) {
            event.stopPropagation();
            if (!zoomEnabled || currentZoom <= minZoom) return;

            currentZoom = Math.max(minZoom, currentZoom / 1.25);
            // Zoom to center for button clicks
            const container = document.querySelector('#merged .track-content');
            const centerX = container ? container.offsetWidth / 2 : 0;
            updateZoom(centerX);
        }

        // Store original clip positions and sizes for zoom calculations
        function storeOriginalClipData() {
            originalClipData.clear();

            // Store data for all visible clips in merged view (including MISC clips)
            const mergedClips = document.querySelectorAll('#merged .audio-clip');
            mergedClips.forEach(clip => {
                const left = parseFloat(clip.style.left.replace('%', ''));
                const width = parseFloat(clip.style.width.replace('%', ''));
                const clipId = clip.dataset.clip;

                originalClipData.set(clipId, {
                    left: left,
                    width: width,
                    element: clip
                });
            });

            // Store data for MISC clips (including hidden ones)
            mergedMiscClips.forEach(miscClip => {
                const left = parseFloat(miscClip.originalLeft.replace('%', ''));
                const width = parseFloat(miscClip.originalWidth.replace('%', ''));

                originalClipData.set(miscClip.clipId, {
                    left: left,
                    width: width,
                    element: miscClip.element
                });
            });
        }

        // Switch between waveform and spectrogram view modes
        function switchViewMode(mode) {
            if (mode === currentViewMode) return;

            currentViewMode = mode;

            // Update button states
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });

            // Store preference for current file
            const currentFile = document.querySelector('#merged .track-info span:first-child')?.textContent;
            if (currentFile) {
                viewModePreferences[currentFile] = mode;
            }

            // Redraw visualization
            drawVisualization();
        }

        // Update clip positions and sizes based on current zoom level
        function updateClipPositions() {
            if (originalClipData.size === 0) return;

            const mergedTrack = document.querySelector('#merged .track-content');
            if (!mergedTrack) return;

            // Calculate visible range in original coordinates (0-100%)
            const visibleStart = waveformOffsetX * 100;
            const visibleEnd = visibleStart + (100 / currentZoom);

            originalClipData.forEach((originalData, clipId) => {
                const clip = originalData.element;
                if (!clip) return;

                // Check if this is a MISC clip
                const isMiscClip = clip.classList.contains('misc-clip-hidden');

                // Calculate original clip boundaries
                const originalLeft = originalData.left;
                const originalRight = originalData.left + originalData.width;

                // Check if clip is visible in current zoom view
                const isInViewport = !(originalRight < visibleStart || originalLeft > visibleEnd);

                if (!isInViewport) {
                    // Clip is completely outside visible area - hide all clips regardless of type
                    clip.style.display = 'none';
                    return;
                }

                // Clip is at least partially visible in viewport
                if (isMiscClip) {
                    // For MISC clips, only show if already revealed
                    if (revealedMiscClips.has(clipId)) {
                        clip.style.display = 'flex';
                    } else {
                        clip.style.display = 'none';
                    }
                } else {
                    // Regular clips show normally when in viewport
                    clip.style.display = 'flex';
                }

                // Calculate new position and size
                // Convert from original coordinates to zoomed coordinates
                const newLeft = ((originalLeft - visibleStart) / (100 / currentZoom)) * 100;
                const newWidth = (originalData.width / (100 / currentZoom)) * 100;

                // Clamp to visible boundaries
                const clampedLeft = Math.max(0, newLeft);
                const clampedRight = Math.min(100, newLeft + newWidth);
                const clampedWidth = clampedRight - clampedLeft;

                // Apply new position and size
                clip.style.left = `${clampedLeft}%`;
                clip.style.width = `${clampedWidth}%`;

                // Fade out clips that are partially visible at edges
                if (clampedLeft <= 1 || clampedRight >= 99) {
                    clip.style.opacity = '0.6';
                } else {
                    clip.style.opacity = '';
                }
            });

            // Update MISC clip visibility
            updateMiscClipVisibility();
        }

        // Initialize waveform canvas
        function initializeWaveformCanvas() {
            const mergedTrack = document.querySelector('#merged .track-content');
            if (!mergedTrack) return;

            // Create canvas element
            waveformCanvas = document.createElement('canvas');
            waveformCanvas.className = 'waveform-canvas';
            mergedTrack.appendChild(waveformCanvas);

            // Get 2D context
            waveformCtx = waveformCanvas.getContext('2d');

            // Set canvas size to match container exactly
            function resizeCanvas() {
                const rect = mergedTrack.getBoundingClientRect();
                waveformCanvas.width = rect.width;
                waveformCanvas.height = rect.height;
                drawVisualization();
            }

            // Initial resize and setup
            resizeCanvas();

            // Handle window resize
            window.addEventListener('resize', resizeCanvas);

            // Canvas is now the primary waveform display

            // Generate waveform data based on current file
            const currentFile = document.querySelector('#merged .track-info span:first-child')?.textContent || '5_medium_find_the_murderer.wav';
            waveformData = generateWaveformData(currentFile, 10000);
            spectrogramData = generateSpectrogramData(currentFile);
            drawVisualization();
        }

        // Mouse wheel zoom functionality
        function initializeZoomControls() {
            const mergedTrack = document.querySelector('#merged .track-content');
            if (mergedTrack) {
                mergedTrack.addEventListener('wheel', function (event) {
                    // Only prevent default and zoom if zoom is enabled
                    if (!zoomEnabled) return;

                    event.preventDefault();

                    // Get mouse X position relative to the container
                    const rect = mergedTrack.getBoundingClientRect();
                    const mouseX = event.clientX - rect.left;

                    if (event.deltaY < 0) {
                        // Scroll up = zoom in
                        if (currentZoom >= maxZoom) return;
                        currentZoom = Math.min(maxZoom, currentZoom * 1.25);
                        updateZoom(mouseX);
                    } else {
                        // Scroll down = zoom out
                        if (currentZoom <= minZoom) return;
                        currentZoom = Math.max(minZoom, currentZoom / 1.25);
                        updateZoom(mouseX);
                    }
                });

                // Add box drawing for MISC clip identification
                mergedTrack.addEventListener('mousedown', startMiscClipIdentification);
                mergedTrack.addEventListener('mousemove', updateMiscClipIdentification);
                mergedTrack.addEventListener('mouseup', endMiscClipIdentification);
            }

            // Initialize button states
            updateZoomButtons();
        }

        // Check if a MISC clip should be visible based on zoom and viewport
        function shouldMiscClipBeVisible(miscClip) {
            const clipWidth = parseFloat(miscClip.originalWidth.replace('%', ''));
            const clipLeft = parseFloat(miscClip.originalLeft.replace('%', ''));

            // Check size threshold: 25% of view OR max zoom
            const sizeThresholdMet = (clipWidth * currentZoom >= 25) || (currentZoom >= maxZoom);
            if (!sizeThresholdMet) return false;

            // Check if in viewport
            const visibleStart = waveformOffsetX * 100;
            const visibleEnd = visibleStart + (100 / currentZoom);
            const clipEnd = clipLeft + clipWidth;

            const inViewport = (clipEnd > visibleStart) && (clipLeft < visibleEnd);

            return inViewport;
        }

        // Update MISC clip visibility based on current zoom and scroll
        function updateMiscClipVisibility() {
            if (mergedMiscClips.length === 0) return;

            mergedMiscClips.forEach(miscClip => {
                const clipId = miscClip.clipId;

                // Check if should be revealed now (but don't show yet - let updateClipPositions handle viewport)
                if (!revealedMiscClips.has(clipId) && shouldMiscClipBeVisible(miscClip)) {
                    revealMiscClip(miscClip);
                }
            });
        }

        // Reveal a MISC clip with animation
        function revealMiscClip(miscClip) {
            const element = miscClip.element;
            const clipId = miscClip.clipId;

            // Mark as revealed (permanent)
            revealedMiscClips.add(clipId);

            // Note: Don't set display here - let updateClipPositions handle viewport visibility
            // But only animate if the element will be visible
            const originalLeft = parseFloat(miscClip.originalLeft);
            const originalRight = originalLeft + parseFloat(miscClip.originalWidth);
            const visibleStart = waveformOffsetX * 100;
            const visibleEnd = visibleStart + (100 / currentZoom);
            const isInViewport = !(originalRight < visibleStart || originalLeft > visibleEnd);

            if (isInViewport) {
                // Show the element for animation
                element.style.display = 'flex';

                // Start animation from small scale and transparent
                element.style.transform = 'scale(0.5)';
                element.style.opacity = '0';
                element.style.transition = 'all 0.5s ease-out';
                element.style.zIndex = '50'; // Above regular clips

                // Animate to full size and opacity
                requestAnimationFrame(() => {
                    element.style.transform = 'scale(1.0)';
                    element.style.opacity = '1';

                    // Clean up transition after animation
                    setTimeout(() => {
                        element.style.transition = '';
                    }, 500);
                });
            }
        }

        // Plugin configuration
        const PLUGIN_CONFIG = [
            { id: 'mute', icon: 'üîá', name: 'Mute', type: 'toggle', description: 'Toggle clip muting' },
            { id: 'noise', icon: 'üå´', name: 'Noise Reduction', type: 'toggle', description: 'Remove noise/reverb/echo' },
            { id: 'voice', icon: 'üé§', name: 'Voice Boost', type: 'toggle', description: 'Enhance voice clarity' },
            { id: 'reverse', icon: '‚Üî', name: 'Reverse', type: 'toggle', description: 'Reverse audio playback' },
            { id: 'stereo', icon: 'üéß', name: 'Stereo/Mono', type: 'toggle', description: 'Toggle stereo/mono mode' },
            { id: 'volume', icon: 'üîä', name: 'Volume', type: 'slider', description: 'Adjust volume levels', range: ['Mute', 'Max'] },
            { id: 'pitch', icon: 'üéµ', name: 'Pitch', type: 'slider', description: 'Modify pitch', range: ['Lower', 'Higher'] },
            { id: 'speed', icon: '‚ö°', name: 'Speed', type: 'slider', description: 'Adjust playback speed', range: ['Faster', 'Slower'] },
            { id: 'highpass', icon: 'üìà', name: 'High Pass', type: 'slider', description: 'High frequency cut-off', range: ['Low', 'High'] },
            { id: 'lowpass', icon: 'üìâ', name: 'Low Pass', type: 'slider', description: 'Low frequency cut-off', range: ['Low', 'High'] },
            { id: 'bitrate', icon: 'üíæ', name: 'Bit Rate', type: 'slider', description: 'Adjust audio quality', range: ['Low', 'High'] }
        ];

        // Add data structure to track effects per clip
        const clipEffects = new Map(); // Maps clip ID to Set of active effects

        // Task hints for each level
        const TASK_HINTS = {
            '1_simple_getaway_analysis.wav': 'Silence unwanted elements to reveal hidden evidence',
            '2_simple_vocal_harmony.wav': 'Balance vocal levels and clean up the recording',
            '3_medium_morse_code.wav': 'Enhance signal clarity to decode the morse message',
            '4_medium_seasonal_birds.wav': 'Isolate the target bird call from background noise',
            '5_medium_find_the_murderer.wav': 'Process evidence using advanced time manipulation',
            '6_complex_noise_profiling.wav': 'Apply technical precision to separate signal types',
            '7_complex_orchestra_hickups.wav': 'Remove all performance mistakes and disruptions'
        };

        // Get clip color by layer ID
        function getClipColorByLayer(layerId) {
            const layerColors = {
                // find_the_murderer.wav layers
                'evidence-recording': '#e74c3c',
                'ghost-voices': '#8e44ad',
                'investigation': '#27ae60',
                'ambient-static-wave': '#34495e',
                // morse_code.wav layers
                'morse-signals': '#3498db',
                'radio-static': '#95a5a6',
                // noise_profiling.wav layers
                'vocal-track': '#e74c3c',
                'background-noise': '#f39c12',
                'electrical-interference': '#1abc9c',
                'mechanical-sounds': '#e67e22',
                'digital-artifacts': '#9b59b6',
                'frequency-sweeps': '#27ae60',
                'calibration-tones': '#34495e',
                // orchestra_hickups.wav layers
                'violin-section': '#e74c3c',
                'brass-section': '#f39c12',
                'woodwind-section': '#27ae60',
                'percussion-section': '#9b59b6',
                // vocal_harmony.wav layers
                'vocal-harmony': '#e67e22',
                // getaway_analysis.wav layers
                'digital-corruption': '#e74c3c',
                'engine-signature': '#3498db',
                // seasonal_birds.wav layers
                'target-bird-call': '#27ae60',
                'forest-ambience': '#2c3e50',
                'viola-breathing': '#8e44ad',
                'unknown-presence': '#e74c3c'
            };
            return layerColors[layerId] || '#95a5a6'; // Default gray if not found
        }

        // Plugin factory functions
        function createTogglePlugin(plugin) {
            return `
                <div class="plugin-section disabled" onclick="selectPlugin('${plugin.id}')">
                    <div class="plugin-title">${plugin.icon} ${plugin.name}</div>
                    <div style="font-size: 11px; color: var(--text-muted);">${plugin.description}</div>
                    <div class="checkbox"></div>
                </div>
            `;
        }

        function createSliderPlugin(plugin) {
            return `
                <div class="plugin-section disabled" onclick="selectPlugin('${plugin.id}')">
                    <div class="plugin-title">${plugin.icon} ${plugin.name}</div>
                    <div class="slider-container">
                        <div class="slider-labels">
                            <span>${plugin.range[0]}</span>
                            <span>${plugin.range[1]}</span>
                        </div>
                        <div class="slider-track">
                            <div class="slider-fill"></div>
                            <div class="slider-thumb"></div>
                        </div>
                    </div>
                    <div style="font-size: 11px; color: var(--text-muted);">${plugin.description}</div>
                </div>
            `;
        }

        function generatePluginsHTML(availableTools = []) {
            // Filter plugins to only show available tools for current level
            const filteredPlugins = PLUGIN_CONFIG.filter(plugin =>
                availableTools.length === 0 || availableTools.includes(plugin.id)
            );

            return filteredPlugins.map(plugin =>
                plugin.type === 'slider' ? createSliderPlugin(plugin) : createTogglePlugin(plugin)
            ).join('');
        }

        // Playback state
        let isPlaying = false;
        let currentTime = 0;
        let totalDuration = 47; // Total duration in seconds
        let playbackInterval;
        let playbackSpeed = 1; // Normal speed

        // Format time as MM:SS.mmm
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            const milliseconds = Math.floor((seconds % 1) * 1000);
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
        }

        // Update time display
        function updateTimeDisplay() {
            const timeDisplay = document.querySelector('.time-display');
            timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(totalDuration)}`;
        }

        // Update playback marker position
        function updatePlaybackMarker() {
            const marker = document.getElementById('playback-marker');
            const percentage = (currentTime / totalDuration) * 100;
            marker.style.left = `${percentage}%`;
        }

        // Toggle playback
        function toggleMainPlayback(event) {
            event.stopPropagation();
            isPlaying = !isPlaying;

            // Update button icon
            const playBtn = event.target;
            playBtn.textContent = isPlaying ? '‚è∏' : '‚ñ∂';

            if (isPlaying) {
                // Start playback
                playbackInterval = setInterval(() => {
                    currentTime += 0.1 * playbackSpeed;
                    if (currentTime >= totalDuration) {
                        stopMainPlayback(event);
                        return;
                    }
                    updateTimeDisplay();
                    updatePlaybackMarker();
                }, 100);
            } else {
                // Pause playback
                clearInterval(playbackInterval);
            }
        }

        // Stop playback
        function stopMainPlayback(event) {
            event.stopPropagation();
            isPlaying = false;
            clearInterval(playbackInterval);
            currentTime = 0;
            updateTimeDisplay();
            updatePlaybackMarker();

            // Reset play button icon
            const playBtn = document.querySelector('.transport-controls .transport-btn:first-child');
            playBtn.textContent = '‚ñ∂';
        }

        // Seek to start
        function seekToStart(event) {
            event.stopPropagation();
            currentTime = 0;
            updateTimeDisplay();
            updatePlaybackMarker();
        }

        // Seek to end
        function seekToEnd(event) {
            event.stopPropagation();
            currentTime = totalDuration;
            updateTimeDisplay();
            updatePlaybackMarker();
        }

        // Stem Isolation function - the new main analysis method
        async function stemIsolation(event) {
            event.stopPropagation();

            if (!window.currentLayerConfig) {
                console.error('No layer configuration loaded');
                return;
            }

            // Remove the button overlay
            const analyzeOverlay = event.target.closest('.analyze-overlay');
            if (analyzeOverlay) {
                analyzeOverlay.remove();
            }

            // Create loading overlay (only covers merged track)
            const loadingOverlay = document.createElement('div');
            loadingOverlay.className = 'stem-isolation-overlay';
            loadingOverlay.innerHTML = `
                <div class="isolation-progress-container">
                    <div class="isolation-title">üéµ STEM ISOLATION</div>
                    <div class="isolation-status">Initializing AI audio separation...</div>
                    <div class="progress-bar-container">
                        <div class="progress-bar-fill"></div>
                    </div>
                    <div class="layer-status">Preparing multi-band frequency analysis...</div>
                </div>
            `;

            // Add to merged track only so layers can be seen appearing below
            const mergedTrack = document.getElementById('merged');
            mergedTrack.appendChild(loadingOverlay);

            // Hide all existing layers to prevent duplication
            Object.keys(window.currentLayerConfig).forEach(layerId => {
                const layer = document.getElementById(layerId);
                if (layer) {
                    layer.style.display = 'none';
                }
            });

            // Clear merged track of existing clips
            const existingClips = mergedTrack.querySelectorAll('.audio-clip');
            existingClips.forEach(clip => clip.remove());

            // Separate large and small clips
            const largeClips = [];
            const smallClips = [];

            Object.entries(window.currentLayerConfig).forEach(([layerId, layerConfig]) => {
                layerConfig.clips.forEach(clip => {
                    const clipData = { ...clip, layerId, layerConfig };
                    if (clip.type === 'large') {
                        largeClips.push(clipData);
                    } else if (clip.type === 'small') {
                        smallClips.push(clipData);
                    } else {
                        // This should never happen if all clips have type defined
                        console.warn('Clip without type property:', clip);
                    }
                });
            });

            // Create MISC layers for small clips
            const miscLayers = createMiscLayers(smallClips);

            // Start the loading animation
            await performStemIsolation(largeClips, smallClips, miscLayers, loadingOverlay);
        }

        // Auto-analysis function (for menu)
        function autoAnalyzeAll() {
            // Use the same stem isolation process
            const fakeEvent = {
                stopPropagation: () => { },
                target: { closest: () => document.querySelector('.analyze-overlay') }
            };
            stemIsolation(fakeEvent);
        }

        function selectPlugin(pluginName) {
            if (!selectedClip || !isAnalyzed) return;

            const pluginSection = event.target.closest('.plugin-section');
            const isActive = pluginSection.classList.contains('active');
            const clipId = selectedClip.dataset.clip;

            // Initialize effects set for this clip if it doesn't exist
            if (!clipEffects.has(clipId)) {
                clipEffects.set(clipId, new Set());
            }

            const clipEffectSet = clipEffects.get(clipId);

            // Handle mute specifically
            if (pluginName === 'mute') {
                if (isActive) {
                    selectedClip.classList.remove('disabled');
                    clipEffectSet.delete(pluginName);
                } else {
                    selectedClip.classList.add('disabled');
                    clipEffectSet.add(pluginName);
                }
            } else {
                // Toggle effect in our data structure
                if (isActive) {
                    clipEffectSet.delete(pluginName);
                } else {
                    clipEffectSet.add(pluginName);
                }
            }

            // Toggle active state
            pluginSection.classList.toggle('active');

            // Toggle effect on clip
            const effectClass = `clip-${pluginName}`;
            selectedClip.classList.toggle(effectClass);

            // Update effect icons
            updateClipEffects(selectedClip);

            // Also update the clip in the merged view if it exists
            const mergedClip = document.querySelector(`#merged .audio-clip[data-clip="${clipId}"]`);
            if (mergedClip) {
                mergedClip.classList.toggle(effectClass);
            }
        }

        function updateClipEffects(clip) {
            // Remove all existing effect icons
            clip.querySelectorAll('.clip-effect').forEach(icon => icon.remove());

            const clipId = clip.dataset.clip;
            const activeEffects = clipEffects.get(clipId) || new Set();

            // Add icons for each active effect
            const effects = {
                'mute': 'üîá',
                'noise': 'üå´',
                'voice': 'üé§',
                'reverse': '‚Üî',
                'stereo': 'üéß',
                'volume': 'üîä',
                'pitch': 'üéµ',
                'speed': '‚ö°',
                'highpass': 'üìà',
                'lowpass': 'üìâ',
                'bitrate': 'üíæ'
            };

            let index = 0;
            for (const [effectName, icon] of Object.entries(effects)) {
                if (activeEffects.has(effectName)) {
                    const effectIcon = document.createElement('div');
                    effectIcon.className = 'clip-effect';
                    effectIcon.textContent = icon;
                    effectIcon.style.left = `${2 + (index * 12)}px`;
                    clip.appendChild(effectIcon);
                    index++;
                }
            }
        }

        // Create MISC layers for small clips
        function createMiscLayers(smallClips) {
            const miscLayers = [];

            // Sort clips by their original timeline position to maintain order
            const sortedClips = [...smallClips].sort((a, b) => {
                const leftA = parseFloat(a.left.replace('%', ''));
                const leftB = parseFloat(b.left.replace('%', ''));
                return leftA - leftB;
            });

            // Group clips into MISC layers while preserving their timeline positions
            let miscLayerIndex = 1;
            const clipsPerLayer = Math.ceil(sortedClips.length / Math.max(1, Math.ceil(sortedClips.length / 8))); // ~8 clips per layer max

            for (let i = 0; i < sortedClips.length; i += clipsPerLayer) {
                const layerClips = sortedClips.slice(i, i + clipsPerLayer);

                // Keep original positions - don't repack them to the left
                const miscLayer = {
                    id: `misc-${miscLayerIndex}`,
                    name: `MISC_${miscLayerIndex}`,
                    displayName: `MISC ${miscLayerIndex}`,
                    clips: layerClips.map(clip => ({
                        ...clip,
                        // Preserve original timeline position
                        left: clip.left,
                        width: clip.width
                    })),
                    baseHeight: 50 + (miscLayerIndex - 1) * 60 // Space them out vertically
                };

                miscLayers.push(miscLayer);
                miscLayerIndex++;
            }

            return miscLayers;
        }

        // Perform the stem isolation with loading animation
        async function performStemIsolation(largeClips, smallClips, miscLayers, loadingOverlay) {
            const progressBar = loadingOverlay.querySelector('.progress-bar-fill');
            const statusText = loadingOverlay.querySelector('.isolation-status');
            const layerStatus = loadingOverlay.querySelector('.layer-status');

            const messages = [
                'Analyzing frequency spectrum...',
                'Detecting harmonic patterns...',
                'Separating instrumental stems...',
                'Isolating vocal components...',
                'Processing digital artifacts...',
                'Finalizing layer separation...'
            ];

            // Get regular layers and sort them by displayName to ensure consistent order
            const regularLayers = [...new Set(largeClips.map(clip => clip.layerId))]
                .sort((a, b) => {
                    const layerA = window.currentLayerConfig[a];
                    const layerB = window.currentLayerConfig[b];
                    return layerA.displayName.localeCompare(layerB.displayName);
                });

            const totalSteps = regularLayers.length + miscLayers.length;
            let currentStep = 0;

            // Pre-create all layers in the correct order (but keep them hidden)
            const allLayersInOrder = [...regularLayers, ...miscLayers.map(m => m.id)];
            const createdLayers = [];

            // Create all regular layers first
            for (const layerId of regularLayers) {
                const trackLayer = createRegularLayerHidden(layerId, largeClips.filter(clip => clip.layerId === layerId));
                createdLayers.push(trackLayer);
            }

            // Create all MISC layers
            for (const miscLayer of miscLayers) {
                const trackLayer = createMiscLayerHidden(miscLayer);
                createdLayers.push(trackLayer);
            }

            // Now reveal layers one by one
            for (let i = 0; i < allLayersInOrder.length; i++) {
                const layerId = allLayersInOrder[i];
                const isRegular = regularLayers.includes(layerId);

                if (isRegular) {
                    statusText.textContent = messages[Math.min(currentStep, messages.length - 1)];
                    layerStatus.textContent = `Processing ${layerId.replace('-', ' ')}...`;
                } else {
                    statusText.textContent = 'Cataloging performance artifacts...';
                    layerStatus.textContent = `Creating ${miscLayers.find(m => m.id === layerId).displayName}...`;
                }

                // Step 1: Reveal the empty layer first
                createdLayers[i].style.display = 'flex';

                // Brief pause to show the empty layer
                await new Promise(resolve => setTimeout(resolve, 300));

                // Get actual clips from the DOM layer and sort them left to right
                let sortedClips = [];
                if (isRegular) {
                    // Get clips from the actual layer DOM element
                    const layerElement = createdLayers[i];
                    const clipElements = layerElement.querySelectorAll('.audio-clip');

                    sortedClips = Array.from(clipElements).map(clipEl => {
                        // Find the corresponding config data
                        const configClip = largeClips.find(c => c.id === clipEl.dataset.clip);
                        return {
                            id: clipEl.dataset.clip,
                            left: clipEl.style.left,
                            width: clipEl.style.width,
                            element: clipEl,
                            config: configClip
                        };
                    }).sort((a, b) => {
                        const leftA = parseFloat(a.left.replace('%', ''));
                        const leftB = parseFloat(b.left.replace('%', ''));
                        return leftA - leftB;
                    });
                } else {
                    // For MISC layers, use the provided clips
                    const miscLayer = miscLayers.find(m => m.id === layerId);
                    sortedClips = [...miscLayer.clips].sort((a, b) => {
                        const leftA = parseFloat(a.left.replace('%', ''));
                        const leftB = parseFloat(b.left.replace('%', ''));
                        return leftA - leftB;
                    });
                }

                // Step 2: Fill the layer with clips left-to-right while animating progress
                const clipsDelay = isRegular ? 2100 : 1300; // Reduced to account for the 300ms pause
                const startProgress = (currentStep / totalSteps) * 100;
                const endProgress = ((currentStep + 1) / totalSteps) * 100;

                // Start progress bar animation
                const progressPromise = animateProgressBar(progressBar, startProgress, endProgress, clipsDelay);

                // Reveal clips one by one from left to right (both in layer and merged view)
                const clipsPromise = revealClipsSequentially(layerId, sortedClips, clipsDelay, isRegular);

                // Wait for both to complete
                await Promise.all([progressPromise, clipsPromise]);

                currentStep++;
            }

            // Final completion
            statusText.textContent = 'Stem isolation complete!';
            layerStatus.textContent = 'All audio layers separated successfully.';
            progressBar.style.width = '100%';

            await new Promise(resolve => setTimeout(resolve, 2000)); // Doubled final delay

            // Remove loading overlay
            loadingOverlay.remove();

            // Store original clip data for zoom functionality
            storeOriginalClipData();

            // Enable zoom controls now that clips are available
            enableZoomControls();

            // Create MISC clips in merged view for zoom discovery
            createMergedMiscClips(smallClips);

            // Enable tools
            enableTools();

            // Set up manual discovery for small clips
            setupSmallClipDiscovery();
        }

        // Create a regular layer with large clips (old function for backwards compatibility)
        function createRegularLayer(layerId, layerClips) {
            const trackLayer = createRegularLayerHidden(layerId, layerClips);
            trackLayer.style.display = 'flex';
            addClipsToMergedView(layerId, layerClips);
        }

        // Create a regular layer but keep it hidden initially
        function createRegularLayerHidden(layerId, layerClips) {
            const layerConfig = window.currentLayerConfig[layerId];
            const centerPanel = document.querySelector('.center-panel');

            // Find the last layer to insert after (to maintain order)
            const existingLayers = centerPanel.querySelectorAll('.track-layer:not(#merged)');
            let insertAfter = document.getElementById('merged');

            // If there are existing layers, insert after the last one
            if (existingLayers.length > 0) {
                insertAfter = existingLayers[existingLayers.length - 1];
            }

            // Create a filtered layer config that only contains the large clips
            const filteredLayerConfig = {
                ...layerConfig,
                clips: layerClips // Only the large clips
            };

            // Create the layer with only large clips
            const trackLayer = createTrackLayer(layerId, filteredLayerConfig, centerPanel, insertAfter);

            // Hide all clips initially - they'll be revealed sequentially
            layerClips.forEach(clip => {
                const clipElement = trackLayer.querySelector(`[data-clip="${clip.id}"]`);
                if (clipElement) {
                    clipElement.style.display = 'none';
                    discoveredClips.add(clip.id); // Mark as discovered for tools
                }
            });

            return trackLayer;
        }

        // Add clips to merged view
        function addClipsToMergedView(layerId, layerClips) {
            const layerConfig = window.currentLayerConfig[layerId];

            layerClips.forEach(clip => {
                // Add to merged view
                const mergedClip = document.createElement('div');
                mergedClip.className = 'audio-clip revealed';
                mergedClip.dataset.clip = clip.id;
                mergedClip.dataset.layer = layerId;
                mergedClip.style.left = clip.left;
                mergedClip.style.width = clip.width;

                // Position in merged view
                const clipHash = clip.id.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                const verticalVariation = (clipHash % 30) - 15;
                mergedClip.style.top = `${layerConfig.baseHeight + verticalVariation}px`;
                mergedClip.textContent = clip.id;

                const mergedTrack = document.querySelector('#merged .track-content');
                if (mergedTrack) {
                    mergedTrack.appendChild(mergedClip);
                }
            });
        }

        // Create a MISC layer with small clips (old function for backwards compatibility)
        function createMiscLayer(miscLayer) {
            const trackLayer = createMiscLayerHidden(miscLayer);
            trackLayer.style.display = 'flex';
        }

        // Create a MISC layer but keep it hidden initially
        function createMiscLayerHidden(miscLayer) {
            const centerPanel = document.querySelector('.center-panel');

            // Find the last layer to insert after (to maintain order)
            const existingLayers = centerPanel.querySelectorAll('.track-layer:not(#merged)');
            let insertAfter = document.getElementById('merged');

            // If there are existing layers, insert after the last one
            if (existingLayers.length > 0) {
                insertAfter = existingLayers[existingLayers.length - 1];
            }

            const trackLayer = document.createElement('div');
            trackLayer.className = 'track-layer misc-layer';
            trackLayer.id = miscLayer.id;

            trackLayer.innerHTML = `
                <div class="track-info">
                    <span style="font-size: 0.8em; color: #95a5a6;">${miscLayer.displayName}</span><br>
                    <span style="font-weight: bold; color: #ecf0f1;">${miscLayer.name}</span>
                </div>
                <div class="track-content" 
                     style="position: relative;"
                     onclick="selectClip(event)">
                    ${miscLayer.clips.map(clip =>
                `<div class="audio-clip hidden-small" 
                              data-clip="${clip.id}"
                              data-layer="${miscLayer.id}"
                              style="left: ${clip.left}; width: ${clip.width}; height: 18px; top: 6px; display: none;" 
                              title="Zoom into the WAV file to find and identify this clip."
                              onclick="showClipPopup(event)">
                            ???
                        </div>`
            ).join('')}
                </div>
            `;

            // Insert after the last existing layer to maintain order
            insertAfter.parentNode.insertBefore(trackLayer, insertAfter.nextSibling);
            trackLayer.style.display = 'none'; // Start hidden

            return trackLayer;
        }

        // Animate progress bar smoothly from start to end percentage over duration
        function animateProgressBar(progressBar, startPercent, endPercent, duration) {
            return new Promise(resolve => {
                const startTime = Date.now();
                const startWidth = startPercent;
                const endWidth = endPercent;
                const totalChange = endWidth - startWidth;

                function updateProgress() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1); // 0 to 1

                    // Easing function for smooth animation (ease-out)
                    const easedProgress = 1 - Math.pow(1 - progress, 3);

                    const currentWidth = startWidth + (totalChange * easedProgress);
                    progressBar.style.width = `${currentWidth}%`;

                    if (progress < 1) {
                        requestAnimationFrame(updateProgress);
                    } else {
                        // Ensure we end at exactly the target
                        progressBar.style.width = `${endWidth}%`;
                        resolve();
                    }
                }

                requestAnimationFrame(updateProgress);
            });
        }

        // Reveal clips in a layer sequentially from left to right
        function revealClipsSequentially(layerId, sortedClips, totalDuration, isRegular) {
            return new Promise(async (resolve) => {
                if (sortedClips.length === 0) {
                    resolve();
                    return;
                }

                // Calculate delay between each clip
                const delayBetweenClips = totalDuration / sortedClips.length;

                for (let i = 0; i < sortedClips.length; i++) {
                    const clip = sortedClips[i];

                    if (isRegular) {
                        // Reveal clip in regular layer using the element reference
                        if (clip.element) {
                            clip.element.style.display = 'flex';

                            // Simultaneously add clip to merged view using config data
                            addSingleClipToMergedView(layerId, clip.config || clip);
                        }
                    } else {
                        // For MISC layers, reveal the ??? clips one by one
                        const miscLayer = document.getElementById(layerId);
                        if (miscLayer) {
                            const clipElement = miscLayer.querySelector(`[data-clip="${clip.id}"]`);
                            if (clipElement) {
                                clipElement.style.display = 'flex';
                            }
                        }
                    }

                    // Wait before revealing next clip (including after the last one)
                    await new Promise(resolve => setTimeout(resolve, delayBetweenClips));
                }

                resolve();
            });
        }

        // Add a single clip to merged view
        function addSingleClipToMergedView(layerId, clip) {
            const layerConfig = window.currentLayerConfig[layerId];

            // Add to merged view
            const mergedClip = document.createElement('div');
            mergedClip.className = 'audio-clip revealed';
            mergedClip.dataset.clip = clip.id;
            mergedClip.dataset.layer = layerId;
            mergedClip.style.left = clip.left;
            mergedClip.style.width = clip.width;

            // Position in merged view
            const clipHash = clip.id.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
            const verticalVariation = (clipHash % 30) - 15;
            mergedClip.style.top = `${layerConfig.baseHeight + verticalVariation}px`;
            mergedClip.textContent = clip.id;

            const mergedTrack = document.querySelector('#merged .track-content');
            if (mergedTrack) {
                mergedTrack.appendChild(mergedClip);

                // Update stored clip data if we're already tracking clips
                if (originalClipData.size > 0) {
                    const left = parseFloat(clip.left.replace('%', ''));
                    const width = parseFloat(clip.width.replace('%', ''));
                    originalClipData.set(clip.id, {
                        left: left,
                        width: width,
                        element: mergedClip
                    });
                }
            }
        }

        // Create MISC clips in merged view for zoom discovery
        function createMergedMiscClips(smallClips) {
            const mergedTrack = document.querySelector('#merged .track-content');
            if (!mergedTrack) return;

            // Clear any existing MISC clips
            mergedMiscClips.forEach(miscClip => {
                if (miscClip.element && miscClip.element.parentNode) {
                    miscClip.element.remove();
                }
            });
            mergedMiscClips = [];

            // Calculate vertical spread for MISC clips
            const trackHeight = 240; // Merged track height
            const clipHeight = 18;
            const margin = 10; // Margin from top and bottom edges
            const availableHeight = trackHeight - (2 * margin) - clipHeight;

            // Create ??? clips for each small clip
            smallClips.forEach((clip, index) => {
                // Create the ??? clip element
                const miscClip = document.createElement('div');
                miscClip.className = 'audio-clip misc-clip-hidden';
                miscClip.dataset.clip = clip.id;
                miscClip.dataset.layer = clip.layerId;
                miscClip.style.left = clip.left;
                miscClip.style.width = clip.width;
                miscClip.style.height = '18px';

                // Distribute clips vertically across available space
                let topPosition;
                if (smallClips.length === 1) {
                    // Single clip: center it
                    topPosition = margin + (availableHeight / 2);
                } else {
                    // Multiple clips: spread them evenly
                    const step = availableHeight / (smallClips.length - 1);
                    topPosition = margin + (index * step);
                }
                miscClip.style.top = `${topPosition}px`;

                miscClip.style.display = 'none'; // Hidden initially
                miscClip.style.zIndex = '50'; // Above regular clips
                miscClip.style.background = '#555';
                miscClip.style.color = '#bbb';
                miscClip.style.border = '2px solid #888';
                miscClip.style.boxShadow = '0 0 0 0.5px rgba(0, 0, 0, 0.9), 0 2px 6px rgba(0, 0, 0, 0.4)';
                miscClip.style.textShadow = '1px 1px 2px rgba(0, 0, 0, 0.9)';
                miscClip.style.pointerEvents = 'auto';
                miscClip.textContent = '???';
                miscClip.title = 'Zoom into the WAV file to find and identify this clip.';

                // Add click handler for popup
                miscClip.addEventListener('click', showClipPopup);

                // Add to merged track
                mergedTrack.appendChild(miscClip);

                // Store tracking data
                mergedMiscClips.push({
                    clipId: clip.id,
                    layerId: clip.layerId,
                    originalLeft: clip.left,
                    originalWidth: clip.width,
                    element: miscClip
                });

                // Add to zoom tracking data so MISC clips scale with zoom
                const left = parseFloat(clip.left.replace('%', ''));
                const width = parseFloat(clip.width.replace('%', ''));
                originalClipData.set(clip.id, {
                    left: left,
                    width: width,
                    element: miscClip
                });
            });
        }

        // Setup manual discovery for small clips in MISC layers
        function setupSmallClipDiscovery() {
            const trackContent = document.querySelector('#merged .track-content');
            if (trackContent && !trackContent.hasAttribute('data-discovery-setup')) {
                trackContent.setAttribute('data-discovery-setup', 'true');
                trackContent.addEventListener('mousedown', startSmallClipSelection);
                trackContent.addEventListener('mousemove', updateSmallClipSelection);
                trackContent.addEventListener('mouseup', endSmallClipSelection);
            }
        }

        // MISC clip identification system (for merged view)
        let miscIdentificationDrawing = false;
        let miscIdentificationBox = null;
        let miscIdentificationStartX = 0;
        let miscIdentificationStartY = 0;

        function startMiscClipIdentification(event) {
            // Only work on revealed MISC clips
            const miscClipElements = document.querySelectorAll('#merged .misc-clip-hidden');

            // Check if any revealed clips are visible
            const visibleRevealedClips = Array.from(miscClipElements).filter(clip =>
                clip.style.display === 'flex' && revealedMiscClips.has(clip.dataset.clip)
            );

            // Always allow box drawing for testing, even if no clips available
            miscIdentificationDrawing = true;
            // Find the track content container, not the canvas
            const trackContent = event.target.closest('.track-content') || document.querySelector('#merged .track-content');
            const rect = trackContent.getBoundingClientRect();

            miscIdentificationStartX = event.clientX - rect.left;
            miscIdentificationStartY = event.clientY - rect.top;

            // Clean up existing boxes
            const existingBoxes = trackContent.querySelectorAll('.selection-box');
            existingBoxes.forEach(box => box.remove());

            // Create selection box
            miscIdentificationBox = document.createElement('div');
            miscIdentificationBox.className = 'selection-box';
            trackContent.appendChild(miscIdentificationBox);
        }

        function updateMiscClipIdentification(event) {
            if (!miscIdentificationDrawing || !miscIdentificationBox) {
                return;
            }

            // Use the same track content container we used for the start
            const trackContent = miscIdentificationBox.parentNode;
            const rect = trackContent.getBoundingClientRect();

            const currentX = event.clientX - rect.left;
            const currentY = event.clientY - rect.top;

            const width = Math.abs(currentX - miscIdentificationStartX);
            const height = Math.abs(currentY - miscIdentificationStartY);

            miscIdentificationBox.style.left = Math.min(miscIdentificationStartX, currentX) + 'px';
            miscIdentificationBox.style.top = Math.min(miscIdentificationStartY, currentY) + 'px';
            miscIdentificationBox.style.width = width + 'px';
            miscIdentificationBox.style.height = height + 'px';
        }

        function endMiscClipIdentification(event) {
            if (!miscIdentificationDrawing || !miscIdentificationBox) return;

            // Find overlapping revealed MISC clips in merged view
            const miscClipElements = document.querySelectorAll('#merged .misc-clip-hidden');
            const boxRect = miscIdentificationBox.getBoundingClientRect();

            // Only process clips if there are revealed MISC clips
            if (miscClipElements.length > 0) {
                miscClipElements.forEach(clip => {
                    // Only process revealed clips that are currently visible
                    if (!revealedMiscClips.has(clip.dataset.clip) || clip.style.display !== 'flex') return;

                    const clipRect = clip.getBoundingClientRect();

                    // Check for overlap
                    if (boxRect.left <= clipRect.right && boxRect.right >= clipRect.left &&
                        boxRect.top <= clipRect.bottom && boxRect.bottom >= clipRect.top) {

                        // Identify the clip - reveal its true name and make it editable
                        identifyMiscClip(clip);
                    }
                });
            }

            // Clean up
            if (miscIdentificationBox && miscIdentificationBox.parentNode) {
                miscIdentificationBox.remove();
            }
            miscIdentificationBox = null;
            miscIdentificationDrawing = false;
        }

        function identifyMiscClip(mergedClip) {
            const clipId = mergedClip.dataset.clip;
            const layerId = mergedClip.dataset.layer;

            // Update the merged view clip
            mergedClip.classList.remove('misc-clip-hidden');
            mergedClip.classList.add('identified');
            mergedClip.textContent = ''; // Clear the ??? text since we'll use ::after for the real name
            mergedClip.title = clipId; // Update hover text to show real name
            mergedClip.style.pointerEvents = 'auto';
            mergedClip.style.cursor = 'pointer';

            // Change click handler from showClipPopup to selectClip
            mergedClip.removeEventListener('click', showClipPopup);
            mergedClip.addEventListener('click', selectClip);

            // Get the layer color and apply it
            const clipColor = getClipColorByLayer(layerId);
            mergedClip.style.background = clipColor;
            mergedClip.style.color = '#fff';
            mergedClip.style.border = `2px solid ${clipColor}`;

            // Find and update the corresponding clip in the MISC layer
            const miscLayerClip = document.querySelector(`.misc-layer .audio-clip[data-clip="${clipId}"]`);
            if (miscLayerClip) {
                miscLayerClip.classList.remove('hidden-small');
                miscLayerClip.textContent = clipId; // Show the real name instead of ???
                miscLayerClip.title = clipId; // Update hover text to show real name
                miscLayerClip.style.background = clipColor;
                miscLayerClip.style.color = '#fff';
                miscLayerClip.style.border = `1px solid ${clipColor}`;
                miscLayerClip.style.pointerEvents = 'auto';
                miscLayerClip.style.cursor = 'pointer';

                // Change click handler from showClipPopup to selectClip
                miscLayerClip.removeAttribute('onclick');
                miscLayerClip.onclick = selectClip;
            }

            // Add to discovered clips for tools access
            if (typeof discoveredClips !== 'undefined') {
                discoveredClips.add(clipId);
            }
        }

        // Small clip discovery system
        let discoveryDrawing = false;
        let discoveryBox = null;
        let discoveryStartX = 0;
        let discoveryStartY = 0;

        function startSmallClipSelection(event) {
            const hiddenClips = document.querySelectorAll('.audio-clip.hidden-small');
            if (hiddenClips.length === 0) return;

            discoveryDrawing = true;
            const trackContent = event.target;
            const rect = trackContent.getBoundingClientRect();

            discoveryStartX = event.clientX - rect.left;
            discoveryStartY = event.clientY - rect.top;

            // Clean up existing boxes
            const existingBoxes = event.target.querySelectorAll('.selection-box');
            existingBoxes.forEach(box => box.remove());

            // Create selection box
            discoveryBox = document.createElement('div');
            discoveryBox.className = 'selection-box';
            trackContent.appendChild(discoveryBox);
        }

        function updateSmallClipSelection(event) {
            if (!discoveryDrawing || !discoveryBox) return;

            const trackContent = event.target;
            const rect = trackContent.getBoundingClientRect();

            const currentX = event.clientX - rect.left;
            const currentY = event.clientY - rect.top;

            const width = Math.abs(currentX - discoveryStartX);
            const height = Math.abs(currentY - discoveryStartY);

            discoveryBox.style.left = Math.min(discoveryStartX, currentX) + 'px';
            discoveryBox.style.top = Math.min(discoveryStartY, currentY) + 'px';
            discoveryBox.style.width = width + 'px';
            discoveryBox.style.height = height + 'px';
        }

        function endSmallClipSelection(event) {
            if (!discoveryDrawing || !discoveryBox) return;

            // Find overlapping hidden clips
            const hiddenClips = document.querySelectorAll('.misc-layer .audio-clip.hidden-small');
            const boxRect = discoveryBox.getBoundingClientRect();

            hiddenClips.forEach(clip => {
                const clipRect = clip.getBoundingClientRect();

                // Check for overlap
                if (boxRect.left <= clipRect.right && boxRect.right >= clipRect.left &&
                    boxRect.top <= clipRect.bottom && boxRect.bottom >= clipRect.top) {

                    // Reveal the clip
                    clip.classList.remove('hidden-small');
                    clip.textContent = clip.dataset.clip;
                    clip.style.pointerEvents = 'auto';
                    clip.style.background = '';
                    clip.style.color = '';
                    clip.style.border = '';

                    discoveredClips.add(clip.dataset.clip);
                }
            });

            // Clean up
            if (discoveryBox && discoveryBox.parentNode) {
                discoveryBox.remove();
            }
            discoveryBox = null;
            discoveryDrawing = false;
        }



        // AUDIO CONTROL FUNCTIONS
        function toggleTrackMute(trackId) {
            const track = document.getElementById(trackId);
            if (!track) return;

            track.classList.toggle('track-muted');

            // Update mute button
            const muteBtn = track.querySelector('.audio-control[onclick*="toggleTrackMute"]');
            if (muteBtn) {
                if (track.classList.contains('track-muted')) {
                    muteBtn.textContent = 'üîá';
                    muteBtn.classList.add('muted');
                } else {
                    muteBtn.textContent = 'üîä';
                    muteBtn.classList.remove('muted');
                }
            }
        }

        function toggleTrackSolo(trackId) {
            const track = document.getElementById(trackId);
            if (!track) return;

            track.classList.toggle('track-soloed');

            // Update solo button
            const soloBtn = track.querySelector('.audio-control[onclick*="toggleTrackSolo"]');
            if (soloBtn) {
                if (track.classList.contains('track-soloed')) {
                    soloBtn.textContent = 'üéØ';
                    soloBtn.classList.add('soloed');
                } else {
                    soloBtn.textContent = 'S';
                    soloBtn.classList.remove('soloed');
                }
            }
        }

        function toggleTrackExpansion(trackId) {
            const track = document.getElementById(trackId);
            if (!track) return;

            track.classList.toggle('track-stereo');

            // Update expansion button
            const expandBtn = track.querySelector('.audio-control[onclick*="toggleTrackExpansion"]');
            if (expandBtn) {
                if (track.classList.contains('track-stereo')) {
                    expandBtn.textContent = '‚ñº';
                } else {
                    expandBtn.textContent = '‚ñ∫';
                }
            }
        }

        // Prevent default drag behavior on document
        document.addEventListener('dragover', function (e) {
            e.preventDefault();
        });

        document.addEventListener('drop', function (e) {
            e.preventDefault();
        });

        function enableTools() {
            isAnalyzed = true;
            document.getElementById('tools-message').textContent = 'Select a clip in a layer to use available tools.';
            document.getElementById('tools-container').style.display = 'block';

            // Make all clips clickable
            document.querySelectorAll('.audio-clip').forEach(clip => {
                clip.style.pointerEvents = 'auto';
                clip.style.cursor = 'pointer';
            });
        }

        function selectClip(event) {
            if (!event.target.classList.contains('audio-clip')) return;
            if (!isAnalyzed) return; // Don't allow selection before analysis
            if (event.target.classList.contains('hidden-small')) return; // Don't allow selection of ??? clips
            if (event.target.classList.contains('misc-clip-hidden') && !event.target.classList.contains('identified')) return; // Don't allow selection of unidentified MISC clips

            event.stopPropagation();

            // Remove selection from all clips
            document.querySelectorAll('.audio-clip').forEach(clip => {
                clip.classList.remove('selected');
            });

            // Select clicked clip
            event.target.classList.add('selected');
            selectedClip = event.target;

            // Update selected clip display
            const selectedClipDisplay = document.getElementById('selected-clip-display');
            const selectedClipName = selectedClipDisplay.querySelector('.selected-clip-name');
            const selectedClipWaveform = selectedClipDisplay.querySelector('.selected-clip-waveform');

            // Set clip name and correct waveform color
            selectedClipName.textContent = selectedClip.dataset.clip;

            // Get the correct color based on the clip's layer
            const clipLayerId = selectedClip.closest('.track-layer').id;
            const clipColor = getClipColorByLayer(clipLayerId);
            selectedClipWaveform.style.background = `linear-gradient(90deg, ${clipColor}22 0%, ${clipColor}11 100%)`;

            // Reset playhead position
            const playhead = selectedClipWaveform.querySelector('.selected-clip-playhead');
            if (playhead) {
                playhead.style.left = '0%';
            }

            // Show the display and hide the tools message
            selectedClipDisplay.style.display = 'block';
            document.getElementById('tools-message').style.display = 'none';

            // Enable tools and update their active state based on clip effects
            const clipId = selectedClip.dataset.clip;
            const activeEffects = clipEffects.get(clipId) || new Set();

            document.querySelectorAll('.plugin-section').forEach(section => {
                section.classList.remove('disabled');
                // Get the plugin name from the title, removing emoji and spaces
                const pluginName = section.querySelector('.plugin-title').textContent
                    .replace(/[^\w\s]/g, '') // Remove emojis
                    .trim()
                    .toLowerCase()
                    .replace(/\s+/g, ''); // Remove spaces

                // Toggle active state based on whether this effect is in the clip's active effects
                section.classList.toggle('active', activeEffects.has(pluginName));
            });
        }

        function deselectClip() {
            if (selectedClip) {
                selectedClip.classList.remove('selected');
                selectedClip = null;

                // Stop any playing clip
                if (clipPlaybackInterval) {
                    clearInterval(clipPlaybackInterval);
                    clipPlaybackInterval = null;
                }
                isClipPlaying = false;

                // Reset playhead position
                const playhead = document.querySelector('.selected-clip-playhead');
                if (playhead) {
                    playhead.style.left = '0%';
                }

                // Hide selected clip display and show tools message
                document.getElementById('selected-clip-display').style.display = 'none';
                const toolsMessage = document.getElementById('tools-message');
                toolsMessage.style.display = 'block';
                toolsMessage.textContent = 'Select a clip to use available tools';

                // Disable tools and reset their appearance
                document.querySelectorAll('.plugin-section').forEach(section => {
                    section.classList.add('disabled');
                    section.classList.remove('active'); // Remove active state to reset color
                });
            }
        }

        // Add click handler to track content to deselect clips
        document.querySelectorAll('.track-content').forEach(track => {
            track.addEventListener('click', function (event) {
                if (event.target === this) { // Only if clicking the track itself, not a clip
                    deselectClip();
                }
            });
        });

        // Add click handler to document to deselect when clicking outside
        document.addEventListener('click', function (event) {
            // Don't deselect if clicking on tools panel or its buttons
            if (event.target.closest('.right-panel')) {
                return;
            }

            // Check if click is outside of any track content
            if (!event.target.closest('.track-content')) {
                deselectClip();
            }
        });

        // Initially disable all clips
        document.querySelectorAll('.audio-clip').forEach(clip => {
            clip.style.pointerEvents = 'none';
            clip.style.cursor = 'default';
        });

        // Add slider functionality
        function initSliders() {
            document.querySelectorAll('.slider-track').forEach(track => {
                const thumb = track.querySelector('.slider-thumb');
                const fill = track.querySelector('.slider-fill');
                let isDragging = false;

                function updateSlider(e) {
                    const rect = track.getBoundingClientRect();
                    const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
                    const percent = (x / rect.width) * 100;

                    fill.style.width = `${percent}%`;
                    thumb.style.left = `${percent}%`;

                    // Handle speed slider specifically
                    if (track.closest('.plugin-section').querySelector('.plugin-title').textContent.includes('Speed')) {
                        const clip = document.querySelector('.audio-clip.selected');
                        if (clip) {
                            // Calculate new width based on slider value
                            // 50% = normal speed, 0% = half speed, 100% = double speed
                            const originalWidth = parseFloat(clip.dataset.originalWidth || clip.style.width);
                            const speedFactor = 1 + (percent - 50) / 50; // 0.5 to 1.5
                            clip.style.width = `${originalWidth * speedFactor}%`;
                        }
                    }
                }

                thumb.addEventListener('mousedown', () => {
                    isDragging = true;
                    // Store original width when starting to drag speed slider
                    if (track.closest('.plugin-section').querySelector('.plugin-title').textContent.includes('Speed')) {
                        const clip = document.querySelector('.audio-clip.selected');
                        if (clip && !clip.dataset.originalWidth) {
                            clip.dataset.originalWidth = clip.style.width;
                        }
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        updateSlider(e);
                    }
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                track.addEventListener('click', (e) => {
                    updateSlider(e);
                });
            });
        }

        // Initialize application
        function initializeApp() {
            // Generate plugins dynamically (initially empty - will be populated when loading audio)
            const toolsContainer = document.getElementById('tools-container');
            if (toolsContainer) {
                toolsContainer.innerHTML = generatePluginsHTML([]);
            }

            // Initialize sliders
            initSliders();

            // Initialize zoom controls
            initializeZoomControls();

            // Initialize waveform canvas
            initializeWaveformCanvas();

            // Load default file configuration (simplest file)
            const defaultConfig = AUDIO_CONFIGS['1_simple_getaway_analysis.wav'];
            if (defaultConfig) {
                loadAudioConfiguration(defaultConfig);
            }
        }

        // Call initialization after the page loads
        window.addEventListener('load', initializeApp);

        // Load menu functionality
        function toggleLoadMenu(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('load-dropdown');
            dropdown.classList.toggle('show');
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function (event) {
            const dropdown = document.getElementById('load-dropdown');
            const loadMenu = event.target.closest('.load-menu');

            if (!loadMenu && dropdown.classList.contains('show')) {
                dropdown.classList.remove('show');
            }
        });

        // Load audio file and reset state
        function loadAudioFile(filename, event) {
            event.stopPropagation();

            // Close dropdown
            document.getElementById('load-dropdown').classList.remove('show');

            // Get configuration for this file
            const config = AUDIO_CONFIGS[filename];
            if (!config) {
                console.error(`No configuration found for ${filename}`);
                return;
            }

            // Reset all application state
            resetApplicationState();

            // Update the application with new configuration
            loadAudioConfiguration(config);
        }

        // Reset entire application state
        function resetApplicationState() {
            // Reset analysis state
            isAnalyzed = false;
            discoveredClips.clear();
            selectedClip = null;
            selectedPlugin = null;

            // Clear all clip effects
            clipEffects.clear();

            // Clear clip position data
            originalClipData.clear();

            // Reset MISC clip discovery
            mergedMiscClips = [];
            revealedMiscClips.clear();

            // Disable zoom and hide controls
            zoomEnabled = false;
            const zoomControls = document.querySelector('.zoom-controls');
            const zoomDisplay = document.getElementById('zoom-level-display');
            if (zoomControls) {
                zoomControls.classList.remove('enabled');
            }
            if (zoomDisplay) {
                zoomDisplay.classList.remove('enabled');
            }

            // Stop any playback
            if (isPlaying) {
                stopMainPlayback({ stopPropagation: () => { } });
            }
            if (clipPlaybackInterval) {
                clearInterval(clipPlaybackInterval);
                clipPlaybackInterval = null;
            }
            isClipPlaying = false;

            // Reset time
            currentTime = 0;
            updateTimeDisplay();
            updatePlaybackMarker();

            // Reset zoom
            currentZoom = 1.0;
            waveformOffsetX = 0;

            // Note: Don't reset view mode here - let loadAudioConfiguration handle it
            // Reset canvas visualization if it exists
            if (waveformCanvas) {
                // Regenerate data for new file
                const currentFile = document.querySelector('#merged .track-info span:first-child')?.textContent || '5_medium_find_the_murderer.wav';
                waveformData = generateWaveformData(currentFile, 10000);
                spectrogramData = generateSpectrogramData(currentFile);
                drawVisualization();
            }

            updateZoomButtons();

            // Hide and remove all dynamic track layers (keep only merged)
            const trackLayers = document.querySelectorAll('.track-layer:not(#merged)');
            trackLayers.forEach(layer => {
                layer.remove();
            });

            // Clear merged view of revealed clips
            const mergedTrack = document.querySelector('#merged .track-content');
            if (mergedTrack) {
                // Remove all revealed clips but preserve the waveform gradient
                mergedTrack.querySelectorAll('.audio-clip').forEach(clip => clip.remove());

                // Restore stem isolation overlay if it doesn't exist
                if (!mergedTrack.querySelector('.analyze-overlay')) {
                    const analyzeOverlay = document.createElement('div');
                    analyzeOverlay.className = 'analyze-overlay';
                    analyzeOverlay.innerHTML = '<button class="analyze-btn" onclick="stemIsolation(event)">Stem Isolation</button>';
                    mergedTrack.appendChild(analyzeOverlay);
                }
            }

            // Reset tools panel
            document.getElementById('tools-message').textContent = 'Run Stem Isolation to separate audio layers and unlock tools.';
            document.getElementById('tools-message').style.display = 'block';
            document.getElementById('tools-container').style.display = 'none';
            document.getElementById('selected-clip-display').style.display = 'none';

            // Disable all plugins and reset their state
            document.querySelectorAll('.plugin-section').forEach(section => {
                section.classList.remove('active');
                section.classList.add('disabled');

                // Reset sliders to center position
                const sliderFill = section.querySelector('.slider-fill');
                const sliderThumb = section.querySelector('.slider-thumb');
                if (sliderFill && sliderThumb) {
                    sliderFill.style.width = '50%';
                    sliderThumb.style.left = '50%';
                }
            });


        }

        // Load audio configuration and create track structure
        function loadAudioConfiguration(config) {
            // Update total duration
            totalDuration = config.totalDuration;
            updateTimeDisplay();

            // Update filename in merged track
            const mergedTrackInfo = document.querySelector('#merged .track-info span:first-child');
            if (mergedTrackInfo) {
                mergedTrackInfo.textContent = config.name;
            }

            // Update task hint
            const taskHintElement = document.getElementById('task-hint');
            if (taskHintElement) {
                taskHintElement.textContent = TASK_HINTS[config.name] || 'Complete the audio analysis task';
            }

            // Canvas-based waveform is already updated via generateWaveformData

            // Update tools based on available tools for this level
            const toolsContainer = document.getElementById('tools-container');
            if (toolsContainer) {
                toolsContainer.innerHTML = generatePluginsHTML(config.availableTools || []);
                initSliders(); // Re-initialize sliders after regenerating tools
            }

            // Create track layers dynamically
            const centerPanel = document.querySelector('.center-panel');
            const mergedLayer = document.getElementById('merged');

            Object.entries(config.layers).forEach(([layerId, layerConfig]) => {
                createTrackLayer(layerId, layerConfig, centerPanel, mergedLayer);
            });

            // Update global layer config for analysis game
            window.currentLayerConfig = config.layers;

            // Restore view mode preference for this file
            const savedViewMode = viewModePreferences[config.name];
            if (savedViewMode && savedViewMode !== currentViewMode) {
                switchViewMode(savedViewMode);
            } else {
                // Update button states to reflect current mode
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === currentViewMode);
                });
            }

            // Generate both waveform and spectrogram data for the new file
            if (waveformCanvas) {
                waveformData = generateWaveformData(config.name, 10000);
                spectrogramData = generateSpectrogramData(config.name);
                drawVisualization();
            }


        }

        // Create a track layer element
        function createTrackLayer(layerId, layerConfig, parentElement, insertAfter) {
            const trackLayer = document.createElement('div');
            trackLayer.className = 'track-layer';
            trackLayer.id = layerId;

            trackLayer.innerHTML = `
                <div class="track-info">
                    <span style="font-size: 0.8em; color: #95a5a6;">${layerConfig.displayName}</span><br>
                    <span style="font-weight: bold; color: #ecf0f1;">${layerConfig.name}</span>
                </div>
                <div class="track-content" 
                     style="position: relative;"
                     onclick="selectClip(event)">
                    ${layerConfig.clips.map(clip =>
                `<div class="audio-clip" 
                              data-clip="${clip.id}"
                              style="left: ${clip.left}; width: ${clip.width}; height: 18px; top: 6px;" 
                              title="${clip.title}">
                            ${clip.id}
                        </div>`
            ).join('')}
                </div>
            `;

            // Insert after the merged layer
            insertAfter.parentNode.insertBefore(trackLayer, insertAfter.nextSibling);

            // Initially hide the layer
            trackLayer.style.display = 'none';

            // Return the created element
            return trackLayer;
        }

        function stopClipPlayback(event) {
            event.stopPropagation();
            const playBtn = event.target.parentElement.querySelector('.selected-clip-play-btn');
            const timeDisplay = event.target.parentElement.querySelector('.selected-clip-time');
            const playhead = document.querySelector('.selected-clip-playhead');

            // Stop playback
            if (clipPlaybackInterval) {
                clearInterval(clipPlaybackInterval);
                clipPlaybackInterval = null;
            }

            // Reset UI
            playBtn.textContent = '‚ñ∂';
            timeDisplay.textContent = '00:00.000';
            isClipPlaying = false;

            // Reset playhead position
            if (playhead) {
                playhead.style.left = '0%';
            }
        }

        function toggleClipPlayback(event) {
            event.stopPropagation();
            const playBtn = event.target;
            const timeDisplay = playBtn.parentElement.querySelector('.selected-clip-time');
            const playhead = document.querySelector('.selected-clip-playhead');

            if (isClipPlaying) {
                // Stop playback
                clearInterval(clipPlaybackInterval);
                playBtn.textContent = '‚ñ∂';
                isClipPlaying = false;
            } else {
                // Start playback
                clipStartTime = Date.now();
                clipDuration = 5000; // 5 seconds for demo
                playBtn.textContent = '‚è∏';
                isClipPlaying = true;

                // Update time display and playhead every 50ms
                clipPlaybackInterval = setInterval(() => {
                    const elapsed = Date.now() - clipStartTime;
                    if (elapsed >= clipDuration) {
                        // Stop at end of clip
                        clearInterval(clipPlaybackInterval);
                        playBtn.textContent = '‚ñ∂';
                        timeDisplay.textContent = '00:00.000';
                        isClipPlaying = false;
                        if (playhead) {
                            playhead.style.left = '100%';
                        }
                        return;
                    }

                    // Calculate progress percentage
                    const progress = (elapsed / clipDuration) * 100;

                    // Update playhead position
                    if (playhead) {
                        playhead.style.left = `${progress}%`;
                    }

                    // Format time as MM:SS.mmm
                    const seconds = Math.floor(elapsed / 1000);
                    const milliseconds = elapsed % 1000;
                    const minutes = Math.floor(seconds / 60);
                    const remainingSeconds = seconds % 60;
                    timeDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}.${String(milliseconds).padStart(3, '0')}`;
                }, 50);
            }
        }
    </script>
</body>

</html>