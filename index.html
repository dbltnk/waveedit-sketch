<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FMOD Music Editor</title>
    <link rel="stylesheet" href="gradients.css">
    <script src="audio-configs.js"></script>
    <style>
        :root {
            /* Color Variables */
            --primary-purple: #9b59b6;
            --primary-purple-dark: #8e44ad;
            --primary-red: #e74c3c;
            --primary-red-dark: #c0392b;
            --primary-orange: #f39c12;
            --primary-green: #27ae60;
            --primary-blue: #3498db;
            --primary-teal: #1abc9c;
            --primary-gray: #95a5a6;
            --primary-dark-blue: #34495e;
            --primary-dark-blue-alt: #2c3e50;

            /* Background Colors */
            --bg-primary: #1a1a1a;
            --bg-secondary: #2a2a2a;
            --bg-tertiary: #333;
            --bg-darker: #1e1e1e;
            --bg-transport: #252525;
            --bg-plugin-active: #443355;
            --bg-menu: #2c2c2c;
            --bg-hover: #404040;
            --bg-hover-light: #505050;
            --border-color: #444;
            --border-color-light: #555;
            --border-color-medium: #666;

            /* Text Colors */
            --text-primary: #ffffff;
            --text-secondary: #ecf0f1;
            --text-muted: #888;
            --text-light: #aaa;
            --text-very-light: #95a5a6;

            /* Effects */
            --shadow-subtle: 0 3px 8px rgba(0, 0, 0, 0.3);
            --shadow-glow: 0 0 10px rgba(243, 156, 18, 0.3);
            --transition-fast: all 0.2s ease;
            --transition-hover: all 0.1s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }

        /* Common Button Base */
        .btn-base {
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: bold;
        }

        .btn-round {
            border-radius: 50%;
        }

        .btn-rounded {
            border-radius: 5px;
        }

        /* Main App Layout */
        .app {
            display: flex;
            height: 100vh;
            flex-direction: column;
            overflow: hidden;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        /* Title Bar */
        .title-bar {
            height: 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            background: linear-gradient(90deg, var(--primary-purple-dark), var(--primary-purple));
        }

        .title-text {
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .window-controls {
            display: flex;
            gap: 10px;
        }

        .window-btn {
            border: none;
            cursor: pointer;
            transition: var(--transition-fast);
            font-weight: bold;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            color: white;
        }

        .minimize {
            background: var(--primary-orange);
        }

        .maximize {
            background: var(--primary-green);
        }

        .close {
            background: var(--primary-red);
        }

        /* Menu Bar */
        .menu-bar {
            height: 30px;
            display: flex;
            align-items: center;
            padding: 0 15px;
            background: var(--bg-menu);
            border-bottom: 1px solid var(--border-color);
            gap: 20px;
            flex-shrink: 0;
        }

        .menu-item {
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 3px;
            transition: var(--transition-fast);
        }

        .menu-item:hover {
            background: var(--bg-hover);
        }

        /* Load dropdown styles */
        .load-menu {
            position: relative;
        }

        .load-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            min-width: 200px;
            background: var(--bg-menu);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            box-shadow: var(--shadow-subtle);
            z-index: 1000;
            display: none;
        }

        .load-dropdown.show {
            display: block;
        }

        .load-option {
            padding: 8px 12px;
            cursor: pointer;
            transition: var(--transition-fast);
            border-bottom: 1px solid var(--border-color);
        }

        .load-option:last-child {
            border-bottom: none;
        }

        .load-option:hover {
            background: var(--bg-hover);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        /* Panel Base */
        .panel-base {
            background: var(--bg-secondary);
            padding: 10px;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .left-panel {
            background: var(--bg-secondary);
            padding: 10px;
            overflow-y: auto;
            flex-shrink: 0;
            width: 200px;
            border-right: 1px solid var(--border-color);
        }

        .right-panel {
            background: var(--bg-secondary);
            padding: 10px;
            overflow-y: auto;
            flex-shrink: 0;
            width: 200px;
            border-left: 1px solid var(--border-color);
        }

        /* Center Panel */
        .center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-darker);
            overflow: hidden;
            position: relative;
        }

        /* Transport Controls */
        .transport-controls {
            height: 60px;
            background: var(--bg-transport);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
            flex-shrink: 0;
        }

        .transport-btn {
            border: none;
            cursor: pointer;
            transition: var(--transition-fast);
            font-weight: bold;
            border-radius: 5px;
            width: 40px;
            height: 40px;
            background: var(--bg-hover);
            color: white;
            font-size: 16px;
        }

        .transport-btn:hover {
            background: var(--bg-hover-light);
        }

        .time-display {
            margin-left: auto;
            font-family: 'Courier New', monospace;
            background: var(--bg-primary);
            padding: 8px 15px;
            border-radius: 5px;
        }

        /* Timeline */
        .timeline-container {
            flex: 1;
            padding: 20px;
            overflow: auto;
            position: relative;
        }

        .timeline-ruler {
            height: 30px;
            background: var(--bg-secondary);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            border-radius: 3px;
        }

        .time-marker {
            margin-right: 40px;
            font-size: 12px;
            color: var(--text-light);
        }

        /* Merged View */
        .merged-view {
            height: 240px;
            /* Increased from 80px to 240px */
            background: var(--bg-tertiary);
            margin-bottom: 20px;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }

        .merged-view::before {
            content: "MERGED VIEW";
            position: absolute;
            top: 5px;
            left: 10px;
            font-size: 12px;
            color: var(--text-light);
            z-index: 20;
        }

        /* Track layer in merged view */
        #merged.track-layer {
            height: 240px !important;
            /* Match merged view height */
        }

        /* Track content in merged view */
        #merged .track-content {
            height: 240px !important;
            /* Match merged view height */
            background: linear-gradient(90deg, var(--primary-dark-blue-alt) 0%, var(--primary-dark-blue-alt) 100%);
            position: relative;
        }

        .merged-waveform {
            position: absolute;
            bottom: 5px;
            left: 10px;
            right: 30px;
            height: 15px;
            border-radius: 2px;
            opacity: 0.8;
        }

        /* Track Layers */
        .track-layer {
            height: 60px;
            background: var(--bg-secondary);
            margin-bottom: 10px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            padding: 0 15px;
            position: relative;
        }

        .track-info {
            width: 150px;
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 4px 0;
            line-height: 0.6;
        }

        .track-controls {
            display: flex;
            gap: 5px;
            margin-left: auto;
            margin-right: 10px;
        }

        .track-content {
            flex: 1;
            height: 30px;
            margin-left: 20px;
            position: relative;
            border-radius: 3px;
        }

        /* Analyze button overlay */
        .analyze-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .analyze-btn {
            padding: 8px 16px;
            background: var(--primary-purple);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: var(--transition-fast);
        }

        .analyze-btn:hover {
            background: var(--primary-purple-dark);
            transform: translateY(-2px);
            box-shadow: var(--shadow-subtle);
        }

        /* Analysis minigame styles */
        .track-layer:not(#merged) {
            display: none;
        }

        .analysis-clip {
            position: absolute;
            height: 20px;
            top: 20px;
            border-radius: 3px;
            cursor: pointer;
            border: 2px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #666;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
            user-select: none;
            transition: all 0.2s ease;
            z-index: 20;
            background: #444;
            pointer-events: none;
        }

        .analysis-clip.revealed {
            animation: reveal 0.5s ease-out;
        }

        @keyframes reveal {
            0% {
                transform: scale(1);
                opacity: 0.5;
            }

            50% {
                transform: scale(1.2);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .selection-box {
            position: absolute;
            border: 2px dashed #1abc9c;
            background: rgba(26, 188, 156, 0.1);
            pointer-events: none;
            z-index: 30;
        }

        .selection-box.invalid {
            border-color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
        }

        /* Audio clip styling */
        .audio-clip {
            position: absolute;
            height: 20px;
            top: 5px;
            border-radius: 3px;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
            user-select: none;
            transition: all 0.2s ease;
            background: transparent;
            overflow: hidden;
            font-style: normal !important;
            /* Prevent italic */
            z-index: 5;
            /* Base layer for clip */
        }

        /* Clip effect icons container */
        .clip-effects-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 12px;
            z-index: 1;
            /* Below text */
            pointer-events: none;
        }

        /* Clip effect icons */
        .clip-effect {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 8px;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
            line-height: 1;
            font-style: normal !important;
            /* Prevent italic */
        }

        /* Ensure text is always on top */
        .audio-clip::after {
            content: attr(data-clip);
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            /* Above everything */
            font-style: normal !important;
            /* Prevent italic */
        }

        /* Hide the original text content */
        .audio-clip {
            color: transparent;
        }

        .clip-effect+.clip-effect {
            left: 14px;
        }

        .clip-effect+.clip-effect+.clip-effect {
            left: 26px;
        }

        .clip-effect+.clip-effect+.clip-effect+.clip-effect {
            left: 38px;
        }

        /* Hide effect icons in merged view */
        #merged .clip-effects-container {
            display: none;
        }

        /* Add styles for merged view clips */
        #merged .audio-clip {
            pointer-events: none !important;
            opacity: 0.5;
            z-index: 1;
            height: 18px;
            top: 0;
            /* Reset top position, will be set by JS */
            cursor: default;
        }

        #merged .audio-clip.revealed {
            opacity: 0.7;
            z-index: 2;
            pointer-events: none !important;
        }

        /* Layer-specific colors for merged view */
        /* find_the_murderer.wav layers */
        #merged .audio-clip[data-layer="evidence-recording"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="ghost-voices"] {
            color: #8e44ad;
        }

        #merged .audio-clip[data-layer="investigation"] {
            color: #27ae60;
        }

        #merged .audio-clip[data-layer="ambient-static-wave"] {
            color: #34495e;
        }

        /* morse_code.wav layers */
        #merged .audio-clip[data-layer="morse-signals"] {
            color: #3498db;
        }

        #merged .audio-clip[data-layer="radio-static"] {
            color: #95a5a6;
        }

        /* noise_profiling.wav layers */
        #merged .audio-clip[data-layer="vocal-track"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="background-noise"] {
            color: #f39c12;
        }

        #merged .audio-clip[data-layer="electrical-interference"] {
            color: #1abc9c;
        }

        #merged .audio-clip[data-layer="mechanical-sounds"] {
            color: #e67e22;
        }

        #merged .audio-clip[data-layer="digital-artifacts"] {
            color: #9b59b6;
        }

        #merged .audio-clip[data-layer="frequency-sweeps"] {
            color: #27ae60;
        }

        #merged .audio-clip[data-layer="calibration-tones"] {
            color: #34495e;
        }

        /* orchestra_hickups.wav layers */
        #merged .audio-clip[data-layer="violin-section"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="brass-section"] {
            color: #f39c12;
        }

        #merged .audio-clip[data-layer="woodwind-section"] {
            color: #27ae60;
        }

        #merged .audio-clip[data-layer="percussion-section"] {
            color: #9b59b6;
        }

        /* vocal_harmony.wav layers */
        #merged .audio-clip[data-layer="vocal-track"] {
            color: #e67e22;
        }

        /* getaway_analysis.wav layers */
        #merged .audio-clip[data-layer="digital-corruption"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="engine-signature"] {
            color: #3498db;
        }

        /* seasonal_birds.wav layers */
        #merged .audio-clip[data-layer="target-bird-call"] {
            color: #27ae60;
        }

        #merged .audio-clip[data-layer="forest-ambience"] {
            color: #2c3e50;
        }

        #merged .audio-clip[data-layer="viola-breathing"] {
            color: #8e44ad;
        }

        #merged .audio-clip[data-layer="unknown-presence"] {
            color: #e74c3c;
        }

        /* morse_transmission.wav layers */
        #merged .audio-clip[data-layer="static-noise"] {
            color: #95a5a6;
        }

        #merged .audio-clip[data-layer="morse-dots"] {
            color: #3498db;
        }

        #merged .audio-clip[data-layer="morse-dashes"] {
            color: #e67e22;
        }

        /* murder_evidence.wav layers */
        #merged .audio-clip[data-layer="victim-voices"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="ghostly-whispers"] {
            color: #8e44ad;
        }

        #merged .audio-clip[data-layer="environmental-sounds"] {
            color: #27ae60;
        }

        #merged .audio-clip[data-layer="electrical-interference"] {
            color: #1abc9c;
        }

        #merged .audio-clip[data-layer="breathing-presence"] {
            color: #f39c12;
        }

        #merged .audio-clip[data-layer="temporal-echoes"] {
            color: #e67e22;
        }

        #merged .audio-clip[data-layer="mechanical-disturbance"] {
            color: #34495e;
        }

        #merged .audio-clip[data-layer="psychic-emanations"] {
            color: #9b59b6;
        }

        #merged .audio-clip[data-layer="viola-manifestation"] {
            color: #2c3e50;
        }

        #merged .audio-clip[data-layer="dimensional-tears"] {
            color: #16a085;
        }

        #merged .audio-clip[data-layer="corrupted-data"] {
            color: #c0392b;
        }

        #merged .audio-clip[data-layer="the-imprinted"] {
            color: #8b0000;
        }

        .audio-clip:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .audio-clip.selected {
            border: 2px solid #f39c12;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.3);
        }

        .audio-clip.dragging {
            z-index: 1000;
            transform: rotate(5deg);
            opacity: 0.8;
        }

        .audio-clip.disabled {
            opacity: 0.3;
            filter: grayscale(100%);
            pointer-events: none;
        }

        /* Layer-specific colors */
        /* find_the_murderer.wav layers */
        #evidence-recording .audio-clip {
            color: #e74c3c;
        }

        #ghost-voices .audio-clip {
            color: #8e44ad;
        }

        #investigation .audio-clip {
            color: #27ae60;
        }

        #ambient-static-wave .audio-clip {
            color: #34495e;
        }

        /* morse_code.wav layers */
        #morse-signals .audio-clip {
            color: #3498db;
        }

        #radio-static .audio-clip {
            color: #95a5a6;
        }

        /* noise_profiling.wav layers */
        #vocal-track .audio-clip {
            color: #e74c3c;
        }

        #background-noise .audio-clip {
            color: #f39c12;
        }

        #electrical-interference .audio-clip {
            color: #1abc9c;
        }

        #mechanical-sounds .audio-clip {
            color: #e67e22;
        }

        #digital-artifacts .audio-clip {
            color: #9b59b6;
        }

        #frequency-sweeps .audio-clip {
            color: #27ae60;
        }

        #calibration-tones .audio-clip {
            color: #34495e;
        }

        /* orchestra_hickups.wav layers */
        #violin-section .audio-clip {
            color: #e74c3c;
        }

        #brass-section .audio-clip {
            color: #f39c12;
        }

        #woodwind-section .audio-clip {
            color: #27ae60;
        }

        #percussion-section .audio-clip {
            color: #9b59b6;
        }

        /* vocal_harmony.wav layers - reusing #vocal-track but different color */
        #vocal-harmony .audio-clip {
            color: #e67e22;
        }

        /* getaway_analysis.wav layers */
        #digital-corruption .audio-clip {
            color: #e74c3c;
        }

        #engine-signature .audio-clip {
            color: #3498db;
        }

        /* seasonal_birds.wav layers */
        #target-bird-call .audio-clip {
            color: #27ae60;
        }

        #forest-ambience .audio-clip {
            color: #2c3e50;
        }

        #viola-breathing .audio-clip {
            color: #8e44ad;
        }

        #unknown-presence .audio-clip {
            color: #e74c3c;
        }

        /* morse_transmission.wav layers */
        #static-noise .audio-clip {
            color: #95a5a6;
        }

        #morse-dots .audio-clip {
            color: #3498db;
        }

        #morse-dashes .audio-clip {
            color: #e67e22;
        }

        /* murder_evidence.wav layers */
        #victim-voices .audio-clip {
            color: #e74c3c;
        }

        #ghostly-whispers .audio-clip {
            color: #8e44ad;
        }

        #environmental-sounds .audio-clip {
            color: #27ae60;
        }

        #breathing-presence .audio-clip {
            color: #f39c12;
        }

        #temporal-echoes .audio-clip {
            color: #e67e22;
        }

        #mechanical-disturbance .audio-clip {
            color: #34495e;
        }

        #psychic-emanations .audio-clip {
            color: #9b59b6;
        }

        #viola-manifestation .audio-clip {
            color: #2c3e50;
        }

        #dimensional-tears .audio-clip {
            color: #16a085;
        }

        #corrupted-data .audio-clip {
            color: #c0392b;
        }

        #the-imprinted .audio-clip {
            color: #8b0000;
        }

        /* Plugin applied effects */
        .clip-volume-boost {
            border-top: 2px solid #1abc9c;
        }

        .clip-denoise {
            opacity: 0.8;
            border-top: 2px solid #95a5a6;
        }

        .clip-frequency {
            border-top: 2px solid #3498db;
        }

        .clip-speed {
            font-style: italic;
            border-top: 2px solid #e67e22;
        }

        .clip-volume-boost::before {
            content: '🔊';
            position: absolute;
            top: -12px;
            left: 2px;
            font-size: 8px;
        }

        .clip-denoise::before {
            content: '🌫';
            position: absolute;
            top: -12px;
            left: 2px;
            font-size: 8px;
        }

        .clip-frequency::before {
            content: '📊';
            position: absolute;
            top: -12px;
            left: 2px;
            font-size: 8px;
        }

        .clip-speed::before {
            content: '⚡';
            position: absolute;
            top: -12px;
            left: 2px;
            font-size: 8px;
        }

        /* Track states */
        .track-muted {
            opacity: 0.4;
        }

        .track-soloed {
            box-shadow: 0 0 5px #f39c12;
        }

        .track-stereo .track-content {
            height: 50px;
        }

        .track-stereo .track-content::after {
            content: '';
            position: absolute;
            bottom: 5px;
            left: 0;
            right: 0;
            height: 18px;
            background: inherit;
            opacity: 0.6;
            border-radius: 3px;
        }

        /* Drag and drop zones */
        .drop-zone {
            min-height: 30px;
            border: 2px dashed transparent;
            margin: 2px 0;
            transition: all 0.3s ease;
        }

        .drop-zone.drag-over {
            border-color: #1abc9c;
            background: rgba(26, 188, 156, 0.1);
        }

        /* Audio control buttons */
        .audio-control {
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            transition: all 0.2s ease;
            font-size: 12px;
            border: 1px solid transparent;
        }

        .audio-control:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .audio-control.active {
            background: rgba(243, 156, 18, 0.3);
            border-color: #f39c12;
        }

        .audio-control.muted {
            color: #e74c3c;
        }

        .audio-control.soloed {
            color: #f39c12;
            background: rgba(243, 156, 18, 0.2);
        }

        /* Color themes */
        .waveedit .track-layer {
            border-left: 3px solid #9b59b6;
        }

        .waveedit .transport-controls {
            border-bottom-color: #9b59b6;
        }

        /* Tools Panel States */
        .tools-message {
            color: #888;
            font-size: 14px;
            text-align: center;
            padding: 20px;
            font-style: italic;
            border-bottom: 1px solid #444;
            margin-bottom: 15px;
        }

        .tools-container {
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        /* Selected Clip Display */
        .selected-clip-display {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 15px;
            display: none;
        }

        .selected-clip-title {
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .selected-clip-name {
            font-weight: bold;
            margin-bottom: 8px;
            color: #ecf0f1;
            font-size: 14px;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }

        .selected-clip-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .selected-clip-play-btn,
        .selected-clip-stop-btn {
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 50%;
            background: #9b59b6;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .selected-clip-play-btn:hover,
        .selected-clip-stop-btn:hover {
            background: #8e44ad;
            transform: scale(1.1);
        }

        .selected-clip-stop-btn {
            background: #e74c3c;
        }

        .selected-clip-stop-btn:hover {
            background: #c0392b;
        }

        .selected-clip-time {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #888;
        }

        .selected-clip-waveform {
            height: 20px;
            background: #333;
            border-radius: 3px;
            position: relative;
            overflow: hidden;
            border: 1px solid #444;
        }

        /* Add slider styles */
        .slider-container {
            margin: 8px 0;
            position: relative;
            height: 20px;
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #888;
            margin-bottom: 4px;
        }

        .slider-track {
            position: relative;
            height: 4px;
            background: #444;
            border-radius: 2px;
            margin: 8px 0;
        }

        .slider-fill {
            position: absolute;
            height: 100%;
            background: #9b59b6;
            border-radius: 2px;
            width: 50%;
            /* Start at center */
            transition: width 0.1s ease;
        }

        .slider-thumb {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #fff;
            border: 2px solid #9b59b6;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            transition: all 0.1s ease;
        }

        .slider-thumb:hover {
            transform: translate(-50%, -50%) scale(1.2);
        }

        .plugin-section.disabled .slider-track,
        .plugin-section.disabled .slider-thumb {
            opacity: 0.3;
            pointer-events: none;
        }

        .plugin-section.disabled .slider-labels {
            opacity: 0.3;
        }

        /* Plugin sections */
        .plugin-section {
            margin-bottom: 15px;
            border: 1px solid var(--border-color-light);
            border-radius: 5px;
            padding: 10px;
            background: var(--bg-tertiary);
            cursor: pointer;
            transition: var(--transition-fast);
            position: relative;
        }

        .plugin-section:hover:not(.disabled) {
            background: var(--bg-hover);
            border-color: var(--primary-purple);
        }

        .plugin-section.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        .plugin-section.active {
            border-color: var(--primary-purple);
            background: var(--bg-plugin-active);
        }

        .plugin-section.active .plugin-title {
            color: var(--primary-purple);
        }

        .plugin-section.active .checkbox {
            background: var(--primary-purple);
            border-color: var(--primary-purple);
        }

        .plugin-section.active .checkbox::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            line-height: 1;
        }

        .plugin-section.disabled .checkbox {
            opacity: 0.3;
            pointer-events: none;
        }

        .plugin-title {
            font-weight: bold;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .checkbox {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-radius: 3px;
            background: transparent;
        }

        /* Ensure other track layers maintain their original height */
        .track-layer:not(#merged) {
            height: 60px !important;
        }

        .track-layer:not(#merged) .track-content {
            height: 30px !important;
        }
    </style>
</head>

<body>
    <!-- Landing Screen -->
    <!-- Removed landing screen div -->

    <!-- Assembly App -->
    <!-- Removed Assembly app div -->

    <!-- WaveEdit App -->
    <div id="waveedit" class="app waveedit active">
        <div class="title-bar">
            <div class="title-text">
                ⚙ FMOD Music - WaveEdit
            </div>
            <div class="window-controls">
                <button class="window-btn minimize">−</button>
                <button class="window-btn maximize">□</button>
                <button class="window-btn close">✕</button>
            </div>
        </div>

        <div class="menu-bar">
            <span class="menu-item load-menu" onclick="toggleLoadMenu(event)">Load ▼
                <div class="load-dropdown" id="load-dropdown">
                    <div class="load-option" onclick="loadAudioFile('find_the_murderer.wav', event)">
                        find_the_murderer.wav</div>
                    <div class="load-option" onclick="loadAudioFile('morse_code.wav', event)">morse_code.wav</div>
                    <div class="load-option" onclick="loadAudioFile('noise_profiling.wav', event)">noise_profiling.wav
                    </div>
                    <div class="load-option" onclick="loadAudioFile('orchestra_hickups.wav', event)">
                        orchestra_hickups.wav</div>
                    <div class="load-option" onclick="loadAudioFile('vocal_harmony.wav', event)">vocal_harmony.wav</div>
                    <div class="load-option" onclick="loadAudioFile('getaway_analysis.wav', event)">getaway_analysis.wav
                    </div>
                    <div class="load-option" onclick="loadAudioFile('seasonal_birds.wav', event)">seasonal_birds.wav
                    </div>
                    <div class="load-option" onclick="loadAudioFile('morse_transmission.wav', event)">
                        morse_transmission.wav</div>
                    <div class="load-option" onclick="loadAudioFile('murder_evidence.wav', event)">murder_evidence.wav
                    </div>
                </div>
            </span>
            <span class="menu-item">Save</span>
            <span class="menu-item" onclick="autoAnalyzeAll()">Analyze</span>
            <span class="menu-item">Details</span>
            <span class="menu-item">Plugins</span>
            <span class="menu-item">Help</span>
            <span class="menu-item">License</span>
        </div>

        <div class="main-content">
            <div class="center-panel">
                <div class="transport-controls">
                    <button class="transport-btn" onclick="toggleMainPlayback(event)">▶</button>
                    <button class="transport-btn" onclick="stopMainPlayback(event)">⏹</button>
                    <button class="transport-btn" onclick="seekToStart(event)">⏮</button>
                    <button class="transport-btn" onclick="seekToEnd(event)">⏭</button>
                    <div class="time-display">00:00.000 / 00:47.000</div>
                </div>

                <div class="track-layer" id="merged">
                    <div class="track-info">
                        <span style="font-size: 0.8em; color: #95a5a6;">crime_scene.wav</span><br>
                        <span style="font-weight: bold; color: #ecf0f1;">All Layers</span>
                    </div>
                    <div class="track-content"
                        style="background: linear-gradient(90deg, #2c3e50 0%, #2c3e50 100%); position: relative; height: 60px;"
                        onclick="selectClip(event)">
                        <!-- Waveform visualization -->
                        <div class="main-waveform-gradient"
                            style="position: absolute; top: 0; left: 0; right: 0; bottom: 0;"></div>
                        <!-- Playback marker -->
                        <div id="playback-marker"
                            style="position: absolute; top: 0; bottom: 0; width: 2px; background: #f39c12; left: 0%; pointer-events: none; z-index: 100;">
                        </div>
                        <!-- Analyze button overlay -->
                        <div class="analyze-overlay">
                            <button class="analyze-btn" onclick="analyzeWaveform(event)">Analyze</button>
                        </div>
                    </div>
                </div>

                <div class="track-layer" id="evidence-recording">
                    <div class="track-info">
                        <span style="font-size: 0.8em; color: #95a5a6;">Layer 1</span><br>
                        <span style="font-weight: bold; color: #ecf0f1;">Evidence_Recording</span>
                    </div>
                    <div class="track-content"
                        style="background: linear-gradient(90deg, #555 0%, #555 100%); position: relative;"
                        onclick="selectClip(event)">
                        <div class="audio-clip" data-clip="initial_scream"
                            style="left: 15%; width: 15%; height: 18px; top: 6px;" title="Initial scream">initial_scream
                        </div>
                        <div class="audio-clip" data-clip="struggle_sounds"
                            style="left: 45%; width: 20%; height: 18px; top: 6px;" title="Struggle sounds">
                            struggle_sounds</div>
                        <div class="audio-clip" data-clip="last_words"
                            style="left: 80%; width: 15%; height: 18px; top: 6px;" title="Last words">last_words</div>
                    </div>

                </div>

                <div class="track-layer" id="ghost-voices">
                    <div class="track-info">
                        <span style="font-size: 0.8em; color: #95a5a6;">Layer 2</span><br>
                        <span style="font-weight: bold; color: #ecf0f1;">Ghost_Voices</span>
                    </div>
                    <div class="track-content"
                        style="background: linear-gradient(90deg, #2c3e50 0%, #2c3e50 100%); position: relative;"
                        onclick="selectClip(event)">
                        <div class="audio-clip" data-clip="whisper_1"
                            style="left: 20%; width: 10%; height: 18px; top: 6px;" title="Second whisper">whisper_1
                        </div>
                        <div class="audio-clip" data-clip="whisper_2"
                            style="left: 35%; width: 10%; height: 18px; top: 6px;" title="Third whisper">whisper_2</div>
                        <div class="audio-clip" data-clip="whisper_3"
                            style="left: 55%; width: 7%; height: 18px; top: 6px;" title="Fourth whisper">whisper_3</div>
                        <div class="audio-clip" data-clip="whisper_4"
                            style="left: 70%; width: 9%; height: 18px; top: 6px;" title="Fifth whisper">whisper_4</div>
                    </div>

                </div>

                <div class="track-layer" id="investigation">
                    <div class="track-info">
                        <span style="font-size: 0.8em; color: #95a5a6;">Layer 3</span><br>
                        <span style="font-weight: bold; color: #ecf0f1;">Investigation_Notes</span>
                    </div>
                    <div class="track-content"
                        style="background: linear-gradient(90deg, #34495e 0%, #34495e 100%); position: relative;"
                        onclick="selectClip(event)">
                        <div class="audio-clip" data-clip="police_report"
                            style="left: 40%; width: 15%; height: 18px; top: 6px;" title="Police recording">
                            police_report</div>
                        <div class="audio-clip" data-clip="witness_statement"
                            style="left: 70%; width: 20%; height: 18px; top: 6px;" title="Witness statement">
                            witness_statement</div>
                    </div>

                </div>

                <div class="track-layer" id="ambient-static-wave">
                    <div class="track-info">
                        <span style="font-size: 0.8em; color: #95a5a6;">Layer 4</span><br>
                        <span style="font-weight: bold; color: #ecf0f1;">Ambient_Static</span>
                    </div>
                    <div class="track-content"
                        style="background: linear-gradient(90deg, #1a1a1a 0%, #1a1a1a 100%); position: relative;"
                        onclick="selectClip(event)">
                        <div class="audio-clip" data-clip="room_tone"
                            style="left: 10%; width: 20%; height: 18px; top: 6px;" title="Room tone">room_tone</div>
                        <div class="audio-clip" data-clip="static_burst"
                            style="left: 35%; width: 20%; height: 18px; top: 6px;" title="Static burst">static_burst
                        </div>
                        <div class="audio-clip" data-clip="tape_hiss"
                            style="left: 70%; width: 25%; height: 18px; top: 6px;" title="Tape hiss">tape_hiss</div>
                    </div>

                </div>
            </div>

            <div class="right-panel">
                <div class="tools-header">Tools</div>
                <div id="tools-message" class="tools-message">Completely analyze the track to enable tools.</div>
                <div id="selected-clip-display" class="selected-clip-display" style="display: none;">
                    <div class="selected-clip-title">Selected Clip:</div>
                    <div class="selected-clip-name"></div>
                    <div class="selected-clip-controls">
                        <button class="selected-clip-play-btn" onclick="toggleClipPlayback(event)">▶</button>
                        <button class="selected-clip-stop-btn" onclick="stopClipPlayback(event)">⏹</button>
                        <span class="selected-clip-time">00:00.000</span>
                    </div>
                    <div class="selected-clip-waveform"></div>
                </div>
                <div id="tools-container" class="tools-container" style="display: none;">
                    <!-- Plugins will be generated dynamically -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variable to store current layer configuration
        window.currentLayerConfig = null;

        let selectedPlugin = null;
        let selectedClip = null;
        let draggedClip = null;
        let remainingClips = [];
        let currentAnalysisClip = null;
        let discoveredClips = new Set();
        let isAnalyzed = false;
        let isDrawing = false;
        let selectionBox = null;
        let startX = 0;
        let startY = 0;
        let clipPlaybackInterval = null;
        let clipStartTime = 0;
        let clipDuration = 0;
        let isClipPlaying = false;

        // Plugin configuration
        const PLUGIN_CONFIG = [
            { id: 'mute', icon: '🔇', name: 'Mute', type: 'toggle', description: 'Toggle clip muting' },
            { id: 'noise', icon: '🌫', name: 'Noise Reduction', type: 'toggle', description: 'Remove noise/reverb/echo' },
            { id: 'voice', icon: '🎤', name: 'Voice Boost', type: 'toggle', description: 'Enhance voice clarity' },
            { id: 'reverse', icon: '↔', name: 'Reverse', type: 'toggle', description: 'Reverse audio playback' },
            { id: 'stereo', icon: '🎧', name: 'Stereo/Mono', type: 'toggle', description: 'Toggle stereo/mono mode' },
            { id: 'volume', icon: '🔊', name: 'Volume', type: 'slider', description: 'Adjust volume levels', range: ['Mute', 'Max'] },
            { id: 'pitch', icon: '🎵', name: 'Pitch', type: 'slider', description: 'Modify pitch', range: ['Lower', 'Higher'] },
            { id: 'speed', icon: '⚡', name: 'Speed', type: 'slider', description: 'Adjust playback speed', range: ['Faster', 'Slower'] },
            { id: 'highpass', icon: '📈', name: 'High Pass', type: 'slider', description: 'High frequency cut-off', range: ['Low', 'High'] },
            { id: 'lowpass', icon: '📉', name: 'Low Pass', type: 'slider', description: 'Low frequency cut-off', range: ['Low', 'High'] },
            { id: 'bitrate', icon: '💾', name: 'Bit Rate', type: 'slider', description: 'Adjust audio quality', range: ['Low', 'High'] }
        ];

        // Add data structure to track effects per clip
        const clipEffects = new Map(); // Maps clip ID to Set of active effects

        // Plugin factory functions
        function createTogglePlugin(plugin) {
            return `
                <div class="plugin-section disabled" onclick="selectPlugin('${plugin.id}')">
                    <div class="plugin-title">${plugin.icon} ${plugin.name}</div>
                    <div style="font-size: 11px; color: var(--text-muted);">${plugin.description}</div>
                    <div class="checkbox"></div>
                </div>
            `;
        }

        function createSliderPlugin(plugin) {
            return `
                <div class="plugin-section disabled" onclick="selectPlugin('${plugin.id}')">
                    <div class="plugin-title">${plugin.icon} ${plugin.name}</div>
                    <div class="slider-container">
                        <div class="slider-labels">
                            <span>${plugin.range[0]}</span>
                            <span>${plugin.range[1]}</span>
                        </div>
                        <div class="slider-track">
                            <div class="slider-fill"></div>
                            <div class="slider-thumb"></div>
                        </div>
                    </div>
                    <div style="font-size: 11px; color: var(--text-muted);">${plugin.description}</div>
                </div>
            `;
        }

        function generatePluginsHTML() {
            return PLUGIN_CONFIG.map(plugin =>
                plugin.type === 'slider' ? createSliderPlugin(plugin) : createTogglePlugin(plugin)
            ).join('');
        }

        // Playback state
        let isPlaying = false;
        let currentTime = 0;
        let totalDuration = 47; // Total duration in seconds
        let playbackInterval;
        let playbackSpeed = 1; // Normal speed

        // Format time as MM:SS.mmm
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            const milliseconds = Math.floor((seconds % 1) * 1000);
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
        }

        // Update time display
        function updateTimeDisplay() {
            const timeDisplay = document.querySelector('.time-display');
            timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(totalDuration)}`;
        }

        // Update playback marker position
        function updatePlaybackMarker() {
            const marker = document.getElementById('playback-marker');
            const percentage = (currentTime / totalDuration) * 100;
            marker.style.left = `${percentage}%`;
        }

        // Toggle playback
        function toggleMainPlayback(event) {
            event.stopPropagation();
            isPlaying = !isPlaying;

            // Update button icon
            const playBtn = event.target;
            playBtn.textContent = isPlaying ? '⏸' : '▶';

            if (isPlaying) {
                // Start playback
                playbackInterval = setInterval(() => {
                    currentTime += 0.1 * playbackSpeed;
                    if (currentTime >= totalDuration) {
                        stopMainPlayback(event);
                        return;
                    }
                    updateTimeDisplay();
                    updatePlaybackMarker();
                }, 100);
            } else {
                // Pause playback
                clearInterval(playbackInterval);
            }
        }

        // Stop playback
        function stopMainPlayback(event) {
            event.stopPropagation();
            isPlaying = false;
            clearInterval(playbackInterval);
            currentTime = 0;
            updateTimeDisplay();
            updatePlaybackMarker();

            // Reset play button icon
            const playBtn = document.querySelector('.transport-controls .transport-btn:first-child');
            playBtn.textContent = '▶';
        }

        // Seek to start
        function seekToStart(event) {
            event.stopPropagation();
            currentTime = 0;
            updateTimeDisplay();
            updatePlaybackMarker();
        }

        // Seek to end
        function seekToEnd(event) {
            event.stopPropagation();
            currentTime = totalDuration;
            updateTimeDisplay();
            updatePlaybackMarker();
        }

        // Add new function for auto-analysis
        function autoAnalyzeAll() {
            console.log('Auto-analyzing all clips');

            if (!window.currentLayerConfig) {
                console.error('No layer configuration loaded');
                return;
            }

            // Remove analyze button if it exists
            const analyzeOverlay = document.querySelector('.analyze-overlay');
            if (analyzeOverlay) {
                analyzeOverlay.remove();
            }

            // Show all layers and add clips to merged view using current config
            Object.entries(window.currentLayerConfig).forEach(([layerId, layerConfig]) => {
                const layer = document.getElementById(layerId);

                if (layer) {
                    layer.style.display = 'flex';
                    // Show all clips in the layer
                    const clips = layer.querySelectorAll('.audio-clip');
                    clips.forEach(clip => {
                        clip.style.display = 'flex';
                        discoveredClips.add(clip.dataset.clip);

                        // Add clip to merged view
                        const mergedClip = document.createElement('div');
                        mergedClip.className = 'audio-clip revealed';
                        mergedClip.dataset.clip = clip.dataset.clip;
                        mergedClip.dataset.layer = layerId;
                        mergedClip.style.left = clip.style.left;
                        mergedClip.style.width = clip.style.width;

                        // Create a hash of the clip ID to get a consistent but varied position
                        const clipHash = clip.dataset.clip.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                        const verticalVariation = (clipHash % 30) - 15; // -15 to +15 pixels variation

                        mergedClip.style.top = `${layerConfig.baseHeight + verticalVariation}px`;
                        mergedClip.textContent = clip.dataset.clip;

                        const mergedTrack = document.querySelector('#merged .track-content');
                        if (mergedTrack) {
                            mergedTrack.appendChild(mergedClip);
                        }
                    });
                }
            });

            // Enable tools
            enableTools();
        }

        // Initialize the analysis minigame
        function initAnalysisGame() {
            console.log('Initializing game');

            if (!window.currentLayerConfig) {
                console.error('No layer configuration loaded');
                return;
            }

            // Collect all clips from current configuration
            remainingClips = [];
            Object.entries(window.currentLayerConfig).forEach(([layerId, layerConfig]) => {
                const layer = document.getElementById(layerId);
                console.log('Checking layer:', layerId, layer);
                if (!layer) {
                    console.error('Layer not found:', layerId);
                    return;
                }
                const clips = layer.querySelectorAll('.audio-clip');
                console.log('Found clips:', clips.length);
                // Hide all clips initially
                clips.forEach(clip => {
                    clip.style.display = 'none';
                    remainingClips.push({
                        id: clip.dataset.clip,
                        layer: layerId,
                        left: clip.style.left,
                        width: clip.style.width,
                        baseHeight: layerConfig.baseHeight
                    });
                });
            });

            console.log('Total clips collected:', remainingClips.length);

            // Hide all layers except merged
            Object.keys(window.currentLayerConfig).forEach(layerId => {
                const layer = document.getElementById(layerId);
                if (layer) {
                    layer.style.display = 'none';
                }
            });

            // Show first random clip
            showNextAnalysisClip();

            // Add mouse event listeners for selection box
            const trackContent = document.querySelector('#waveedit #merged .track-content');
            if (trackContent) {
                trackContent.addEventListener('mousedown', startSelection);
                trackContent.addEventListener('mousemove', updateSelection);
                trackContent.addEventListener('mouseup', endSelection);
            }
        }

        function startSelection(event) {
            if (!currentAnalysisClip) return;

            // Clean up any existing selection boxes first
            const existingBoxes = event.target.querySelectorAll('.selection-box');
            existingBoxes.forEach(box => box.remove());

            isDrawing = true;
            const trackContent = event.target;
            const rect = trackContent.getBoundingClientRect();

            // Calculate position relative to track content
            startX = event.clientX - rect.left;
            startY = event.clientY - rect.top;

            // Create selection box
            selectionBox = document.createElement('div');
            selectionBox.className = 'selection-box';
            trackContent.appendChild(selectionBox);
        }

        function updateSelection(event) {
            if (!isDrawing || !selectionBox) return;

            const trackContent = event.target;
            const rect = trackContent.getBoundingClientRect();

            // Calculate current position relative to track content
            const currentX = event.clientX - rect.left;
            const currentY = event.clientY - rect.top;

            // Calculate width and height, capped at 200px
            let width = Math.abs(currentX - startX);
            let height = Math.abs(currentY - startY);

            // Cap dimensions
            width = Math.min(width, 9999);
            height = Math.min(height, 50);

            // Update selection box position and size
            selectionBox.style.left = Math.min(startX, currentX) + 'px';
            selectionBox.style.top = Math.min(startY, currentY) + 'px';
            selectionBox.style.width = width + 'px';
            selectionBox.style.height = height + 'px';
        }

        function endSelection(event) {
            if (!isDrawing || !selectionBox || !currentAnalysisClip) return;

            const width = parseInt(selectionBox.style.width);
            const height = parseInt(selectionBox.style.height);

            // Check if selection contains the clip
            const clipRect = currentAnalysisClip.getBoundingClientRect();
            const selectionRect = selectionBox.getBoundingClientRect();

            const isSelectionValid = selectionRect.left <= clipRect.left &&
                selectionRect.right >= clipRect.right &&
                selectionRect.top <= clipRect.top &&
                selectionRect.bottom >= clipRect.bottom;

            if (isSelectionValid) {
                revealClip(currentAnalysisClip);
            }

            // Clean up
            if (selectionBox && selectionBox.parentNode) {
                selectionBox.remove();
            }
            selectionBox = null;
            isDrawing = false;
        }

        // Add cleanup on mouse leave
        document.querySelector('#waveedit #merged .track-content').addEventListener('mouseleave', function () {
            if (selectionBox && selectionBox.parentNode) {
                selectionBox.remove();
            }
            selectionBox = null;
            isDrawing = false;
        });

        function revealClip(clip) {
            const clipData = remainingClips.find(c => c.id === clip.dataset.clip);
            if (!clipData) return;

            // Reveal the clip
            clip.classList.add('revealed');
            clip.style.color = 'white';
            clip.style.borderColor = '#f39c12';
            clip.textContent = clipData.id;

            // Create a copy of the clip for the merged view
            const mergedClip = document.createElement('div');
            mergedClip.className = 'audio-clip revealed';
            mergedClip.dataset.clip = clipData.id;
            mergedClip.dataset.layer = clipData.layer;
            mergedClip.style.left = clipData.left;
            mergedClip.style.width = clipData.width;
            mergedClip.textContent = clipData.id;

            // Create a hash of the clip ID to get a consistent but varied position
            const clipHash = clipData.id.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
            const verticalVariation = (clipHash % 30) - 15; // -15 to +15 pixels variation

            mergedClip.style.top = `${clipData.baseHeight + verticalVariation}px`;

            // Add the clip to the merged view
            const mergedTrack = document.querySelector('#merged .track-content');
            if (mergedTrack) {
                mergedTrack.appendChild(mergedClip);
            }

            // Show the layer and clip after a short delay
            setTimeout(() => {
                const layer = document.getElementById(clipData.layer);
                if (layer) {
                    layer.style.display = 'flex';
                    const targetClip = layer.querySelector(`.audio-clip[data-clip="${clipData.id}"]`);
                    if (targetClip) {
                        targetClip.style.display = 'flex';
                        discoveredClips.add(clipData.id);
                    }
                }

                // Remove from remaining clips
                remainingClips = remainingClips.filter(c => c.id !== clipData.id);

                // Remove analysis clip
                clip.remove();
                currentAnalysisClip = null;

                // Show next clip
                showNextAnalysisClip();

                // If all clips are discovered, enable tools
                if (remainingClips.length === 0) {
                    enableTools();
                }
            }, 500);
        }

        function showNextAnalysisClip() {
            console.log('Showing next clip, remaining:', remainingClips.length);
            if (remainingClips.length === 0) {
                console.log('No more clips to show');
                return;
            }

            // Remove previous analysis clip if exists
            if (currentAnalysisClip) {
                currentAnalysisClip.remove();
            }

            // Get random clip
            const randomIndex = Math.floor(Math.random() * remainingClips.length);
            const clipData = remainingClips[randomIndex];
            console.log('Selected clip:', clipData);

            // Create analysis clip
            const clip = document.createElement('div');
            clip.className = 'analysis-clip';
            clip.textContent = '???';
            clip.style.left = clipData.left;
            clip.style.width = clipData.width;
            clip.dataset.layer = clipData.layer;
            clip.dataset.clip = clipData.id;

            // Create a hash of the clip ID to get a consistent but varied position
            const clipHash = clipData.id.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
            const verticalVariation = (clipHash % 30) - 15; // -15 to +15 pixels variation

            clip.style.top = `${clipData.baseHeight + verticalVariation}px`;

            // Add to merged track
            const trackContent = document.querySelector('#waveedit #merged .track-content');
            console.log('Adding clip to track:', trackContent);
            if (trackContent) {
                trackContent.appendChild(clip);
                currentAnalysisClip = clip;
            } else {
                console.error('Track content not found');
            }
        }

        function selectPlugin(pluginName) {
            if (!selectedClip || !isAnalyzed) return;

            const pluginSection = event.target.closest('.plugin-section');
            const isActive = pluginSection.classList.contains('active');
            const clipId = selectedClip.dataset.clip;

            // Initialize effects set for this clip if it doesn't exist
            if (!clipEffects.has(clipId)) {
                clipEffects.set(clipId, new Set());
            }

            const clipEffectSet = clipEffects.get(clipId);

            // Handle mute specifically
            if (pluginName === 'mute') {
                if (isActive) {
                    selectedClip.classList.remove('disabled');
                    clipEffectSet.delete(pluginName);
                } else {
                    selectedClip.classList.add('disabled');
                    clipEffectSet.add(pluginName);
                }
            } else {
                // Toggle effect in our data structure
                if (isActive) {
                    clipEffectSet.delete(pluginName);
                } else {
                    clipEffectSet.add(pluginName);
                }
            }

            // Toggle active state
            pluginSection.classList.toggle('active');

            // Toggle effect on clip
            const effectClass = `clip-${pluginName}`;
            selectedClip.classList.toggle(effectClass);

            // Update effect icons
            updateClipEffects(selectedClip);

            // Also update the clip in the merged view if it exists
            const mergedClip = document.querySelector(`#merged .audio-clip[data-clip="${clipId}"]`);
            if (mergedClip) {
                mergedClip.classList.toggle(effectClass);
            }
        }

        function updateClipEffects(clip) {
            // Remove all existing effect icons
            clip.querySelectorAll('.clip-effect').forEach(icon => icon.remove());

            const clipId = clip.dataset.clip;
            const activeEffects = clipEffects.get(clipId) || new Set();

            // Add icons for each active effect
            const effects = {
                'mute': '🔇',
                'noise': '🌫',
                'voice': '🎤',
                'reverse': '↔',
                'stereo': '🎧',
                'volume': '🔊',
                'pitch': '🎵',
                'speed': '⚡',
                'highpass': '📈',
                'lowpass': '📉',
                'bitrate': '💾'
            };

            let index = 0;
            for (const [effectName, icon] of Object.entries(effects)) {
                if (activeEffects.has(effectName)) {
                    const effectIcon = document.createElement('div');
                    effectIcon.className = 'clip-effect';
                    effectIcon.textContent = icon;
                    effectIcon.style.left = `${2 + (index * 12)}px`;
                    clip.appendChild(effectIcon);
                    index++;
                }
            }
        }

        function analyzeWaveform(event) {
            event.stopPropagation();
            console.log('Analyze button clicked');
            // Remove analyze button
            event.target.closest('.analyze-overlay').remove();
            // Start the game
            initAnalysisGame();
        }

        // AUDIO CONTROL FUNCTIONS
        function toggleTrackMute(trackId) {
            const track = document.getElementById(trackId);
            if (!track) return;

            track.classList.toggle('track-muted');

            // Update mute button
            const muteBtn = track.querySelector('.audio-control[onclick*="toggleTrackMute"]');
            if (muteBtn) {
                if (track.classList.contains('track-muted')) {
                    muteBtn.textContent = '🔇';
                    muteBtn.classList.add('muted');
                } else {
                    muteBtn.textContent = '🔊';
                    muteBtn.classList.remove('muted');
                }
            }
        }

        function toggleTrackSolo(trackId) {
            const track = document.getElementById(trackId);
            if (!track) return;

            track.classList.toggle('track-soloed');

            // Update solo button
            const soloBtn = track.querySelector('.audio-control[onclick*="toggleTrackSolo"]');
            if (soloBtn) {
                if (track.classList.contains('track-soloed')) {
                    soloBtn.textContent = '🎯';
                    soloBtn.classList.add('soloed');
                } else {
                    soloBtn.textContent = 'S';
                    soloBtn.classList.remove('soloed');
                }
            }
        }

        function toggleTrackExpansion(trackId) {
            const track = document.getElementById(trackId);
            if (!track) return;

            track.classList.toggle('track-stereo');

            // Update expansion button
            const expandBtn = track.querySelector('.audio-control[onclick*="toggleTrackExpansion"]');
            if (expandBtn) {
                if (track.classList.contains('track-stereo')) {
                    expandBtn.textContent = '▼';
                } else {
                    expandBtn.textContent = '►';
                }
            }
        }

        // Prevent default drag behavior on document
        document.addEventListener('dragover', function (e) {
            e.preventDefault();
        });

        document.addEventListener('drop', function (e) {
            e.preventDefault();
        });

        function enableTools() {
            isAnalyzed = true;
            document.getElementById('tools-message').textContent = 'Select a clip in a layer to use tools.';
            document.getElementById('tools-container').style.display = 'block';

            // Make all clips clickable
            document.querySelectorAll('.audio-clip').forEach(clip => {
                clip.style.pointerEvents = 'auto';
                clip.style.cursor = 'pointer';
            });
        }

        function selectClip(event) {
            if (!event.target.classList.contains('audio-clip')) return;
            if (!isAnalyzed) return; // Don't allow selection before analysis

            event.stopPropagation();

            // Remove selection from all clips
            document.querySelectorAll('.audio-clip').forEach(clip => {
                clip.classList.remove('selected');
            });

            // Select clicked clip
            event.target.classList.add('selected');
            selectedClip = event.target;

            // Update selected clip display
            const selectedClipDisplay = document.getElementById('selected-clip-display');
            const selectedClipName = selectedClipDisplay.querySelector('.selected-clip-name');
            const selectedClipWaveform = selectedClipDisplay.querySelector('.selected-clip-waveform');

            // Set clip name and style
            selectedClipName.textContent = selectedClip.dataset.clip;
            selectedClipWaveform.style.background = selectedClip.style.background;

            // Show the display and hide the tools message
            selectedClipDisplay.style.display = 'block';
            document.getElementById('tools-message').style.display = 'none';

            // Enable tools and update their active state based on clip effects
            const clipId = selectedClip.dataset.clip;
            const activeEffects = clipEffects.get(clipId) || new Set();

            document.querySelectorAll('.plugin-section').forEach(section => {
                section.classList.remove('disabled');
                // Get the plugin name from the title, removing emoji and spaces
                const pluginName = section.querySelector('.plugin-title').textContent
                    .replace(/[^\w\s]/g, '') // Remove emojis
                    .trim()
                    .toLowerCase()
                    .replace(/\s+/g, ''); // Remove spaces

                // Toggle active state based on whether this effect is in the clip's active effects
                section.classList.toggle('active', activeEffects.has(pluginName));
            });
        }

        function deselectClip() {
            if (selectedClip) {
                selectedClip.classList.remove('selected');
                selectedClip = null;

                // Stop any playing clip
                if (clipPlaybackInterval) {
                    clearInterval(clipPlaybackInterval);
                    clipPlaybackInterval = null;
                }
                isClipPlaying = false;

                // Hide selected clip display and show tools message
                document.getElementById('selected-clip-display').style.display = 'none';
                const toolsMessage = document.getElementById('tools-message');
                toolsMessage.style.display = 'block';
                toolsMessage.textContent = 'Select a clip to use tools';

                // Disable tools and reset their appearance
                document.querySelectorAll('.plugin-section').forEach(section => {
                    section.classList.add('disabled');
                    section.classList.remove('active'); // Remove active state to reset color
                });
            }
        }

        // Add click handler to track content to deselect clips
        document.querySelectorAll('.track-content').forEach(track => {
            track.addEventListener('click', function (event) {
                if (event.target === this) { // Only if clicking the track itself, not a clip
                    deselectClip();
                }
            });
        });

        // Add click handler to document to deselect when clicking outside
        document.addEventListener('click', function (event) {
            // Don't deselect if clicking on tools panel or its buttons
            if (event.target.closest('.right-panel')) {
                return;
            }

            // Check if click is outside of any track content
            if (!event.target.closest('.track-content')) {
                deselectClip();
            }
        });

        // Initially disable all clips
        document.querySelectorAll('.audio-clip').forEach(clip => {
            clip.style.pointerEvents = 'none';
            clip.style.cursor = 'default';
        });

        // Add slider functionality
        function initSliders() {
            document.querySelectorAll('.slider-track').forEach(track => {
                const thumb = track.querySelector('.slider-thumb');
                const fill = track.querySelector('.slider-fill');
                let isDragging = false;

                function updateSlider(e) {
                    const rect = track.getBoundingClientRect();
                    const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
                    const percent = (x / rect.width) * 100;

                    fill.style.width = `${percent}%`;
                    thumb.style.left = `${percent}%`;

                    // Handle speed slider specifically
                    if (track.closest('.plugin-section').querySelector('.plugin-title').textContent.includes('Speed')) {
                        const clip = document.querySelector('.audio-clip.selected');
                        if (clip) {
                            // Calculate new width based on slider value
                            // 50% = normal speed, 0% = half speed, 100% = double speed
                            const originalWidth = parseFloat(clip.dataset.originalWidth || clip.style.width);
                            const speedFactor = 1 + (percent - 50) / 50; // 0.5 to 1.5
                            clip.style.width = `${originalWidth * speedFactor}%`;
                        }
                    }
                }

                thumb.addEventListener('mousedown', () => {
                    isDragging = true;
                    // Store original width when starting to drag speed slider
                    if (track.closest('.plugin-section').querySelector('.plugin-title').textContent.includes('Speed')) {
                        const clip = document.querySelector('.audio-clip.selected');
                        if (clip && !clip.dataset.originalWidth) {
                            clip.dataset.originalWidth = clip.style.width;
                        }
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        updateSlider(e);
                    }
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                track.addEventListener('click', (e) => {
                    updateSlider(e);
                });
            });
        }

        // Initialize application
        function initializeApp() {
            // Generate plugins dynamically
            const toolsContainer = document.getElementById('tools-container');
            if (toolsContainer) {
                toolsContainer.innerHTML = generatePluginsHTML();
            }

            // Initialize sliders
            initSliders();

            // Load default file configuration
            const defaultConfig = AUDIO_CONFIGS['find_the_murderer.wav'];
            if (defaultConfig) {
                loadAudioConfiguration(defaultConfig);
            }
        }

        // Call initialization after the page loads
        window.addEventListener('load', initializeApp);

        // Load menu functionality
        function toggleLoadMenu(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('load-dropdown');
            dropdown.classList.toggle('show');
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function (event) {
            const dropdown = document.getElementById('load-dropdown');
            const loadMenu = event.target.closest('.load-menu');

            if (!loadMenu && dropdown.classList.contains('show')) {
                dropdown.classList.remove('show');
            }
        });

        // Load audio file and reset state
        function loadAudioFile(filename, event) {
            event.stopPropagation();

            // Close dropdown
            document.getElementById('load-dropdown').classList.remove('show');

            // Get configuration for this file
            const config = AUDIO_CONFIGS[filename];
            if (!config) {
                console.error(`No configuration found for ${filename}`);
                return;
            }

            // Reset all application state
            resetApplicationState();

            // Update the application with new configuration
            loadAudioConfiguration(config);

            console.log(`Loaded audio file: ${filename}`);
        }

        // Reset entire application state
        function resetApplicationState() {
            // Reset analysis state
            isAnalyzed = false;
            discoveredClips.clear();
            remainingClips = [];
            selectedClip = null;
            selectedPlugin = null;
            currentAnalysisClip = null;

            // Clear all clip effects
            clipEffects.clear();

            // Stop any playback
            if (isPlaying) {
                stopMainPlayback({ stopPropagation: () => { } });
            }
            if (clipPlaybackInterval) {
                clearInterval(clipPlaybackInterval);
                clipPlaybackInterval = null;
            }
            isClipPlaying = false;

            // Reset time
            currentTime = 0;
            updateTimeDisplay();
            updatePlaybackMarker();

            // Hide and remove all dynamic track layers (keep only merged)
            const trackLayers = document.querySelectorAll('.track-layer:not(#merged)');
            trackLayers.forEach(layer => {
                layer.remove();
            });

            // Clear merged view of revealed clips
            const mergedTrack = document.querySelector('#merged .track-content');
            if (mergedTrack) {
                // Remove all revealed clips but preserve the waveform gradient
                mergedTrack.querySelectorAll('.audio-clip').forEach(clip => clip.remove());

                // Restore analyze overlay if it doesn't exist
                if (!mergedTrack.querySelector('.analyze-overlay')) {
                    const analyzeOverlay = document.createElement('div');
                    analyzeOverlay.className = 'analyze-overlay';
                    analyzeOverlay.innerHTML = '<button class="analyze-btn" onclick="analyzeWaveform(event)">Analyze</button>';
                    mergedTrack.appendChild(analyzeOverlay);
                }
            }

            // Reset tools panel
            document.getElementById('tools-message').textContent = 'Completely analyze the track to enable tools.';
            document.getElementById('tools-message').style.display = 'block';
            document.getElementById('tools-container').style.display = 'none';
            document.getElementById('selected-clip-display').style.display = 'none';

            // Disable all plugins and reset their state
            document.querySelectorAll('.plugin-section').forEach(section => {
                section.classList.remove('active');
                section.classList.add('disabled');

                // Reset sliders to center position
                const sliderFill = section.querySelector('.slider-fill');
                const sliderThumb = section.querySelector('.slider-thumb');
                if (sliderFill && sliderThumb) {
                    sliderFill.style.width = '50%';
                    sliderThumb.style.left = '50%';
                }
            });

            console.log('Application state reset');
        }

        // Load audio configuration and create track structure
        function loadAudioConfiguration(config) {
            // Update total duration
            totalDuration = config.totalDuration;
            updateTimeDisplay();

            // Update filename in merged track
            const mergedTrackInfo = document.querySelector('#merged .track-info span:first-child');
            if (mergedTrackInfo) {
                mergedTrackInfo.textContent = config.name;
            }

            // Update merged track gradient
            const mergedWaveform = document.querySelector('#merged .main-waveform-gradient');
            if (mergedWaveform) {
                mergedWaveform.className = `main-waveform-gradient ${config.gradientClass}`;
            }

            // Create track layers dynamically
            const centerPanel = document.querySelector('.center-panel');
            const mergedLayer = document.getElementById('merged');

            Object.entries(config.layers).forEach(([layerId, layerConfig]) => {
                createTrackLayer(layerId, layerConfig, centerPanel, mergedLayer);
            });

            // Update global layer config for analysis game
            window.currentLayerConfig = config.layers;

            console.log(`Loaded configuration for ${config.name} with ${Object.keys(config.layers).length} layers`);
        }

        // Create a track layer element
        function createTrackLayer(layerId, layerConfig, parentElement, insertAfter) {
            const trackLayer = document.createElement('div');
            trackLayer.className = 'track-layer';
            trackLayer.id = layerId;

            trackLayer.innerHTML = `
                <div class="track-info">
                    <span style="font-size: 0.8em; color: #95a5a6;">${layerConfig.displayName}</span><br>
                    <span style="font-weight: bold; color: #ecf0f1;">${layerConfig.name}</span>
                </div>
                <div class="track-content" 
                     style="position: relative;"
                     onclick="selectClip(event)">
                    ${layerConfig.clips.map(clip =>
                `<div class="audio-clip" 
                              data-clip="${clip.id}"
                              style="left: ${clip.left}; width: ${clip.width}; height: 18px; top: 6px;" 
                              title="${clip.title}">
                            ${clip.id}
                        </div>`
            ).join('')}
                </div>
            `;

            // Insert after the merged layer
            insertAfter.parentNode.insertBefore(trackLayer, insertAfter.nextSibling);

            // Initially hide the layer
            trackLayer.style.display = 'none';
        }

        function stopClipPlayback(event) {
            event.stopPropagation();
            const playBtn = event.target.parentElement.querySelector('.selected-clip-play-btn');
            const timeDisplay = event.target.parentElement.querySelector('.selected-clip-time');

            // Stop playback
            if (clipPlaybackInterval) {
                clearInterval(clipPlaybackInterval);
                clipPlaybackInterval = null;
            }

            // Reset UI
            playBtn.textContent = '▶';
            timeDisplay.textContent = '00:00.000';
            isClipPlaying = false;
        }

        function toggleClipPlayback(event) {
            event.stopPropagation();
            const playBtn = event.target;
            const timeDisplay = playBtn.parentElement.querySelector('.selected-clip-time');

            if (isClipPlaying) {
                // Stop playback
                clearInterval(clipPlaybackInterval);
                playBtn.textContent = '▶';
                isClipPlaying = false;
            } else {
                // Start playback
                clipStartTime = Date.now();
                clipDuration = 5000; // 5 seconds for demo
                playBtn.textContent = '⏸';
                isClipPlaying = true;

                // Update time display every 50ms
                clipPlaybackInterval = setInterval(() => {
                    const elapsed = Date.now() - clipStartTime;
                    if (elapsed >= clipDuration) {
                        // Stop at end of clip
                        clearInterval(clipPlaybackInterval);
                        playBtn.textContent = '▶';
                        timeDisplay.textContent = '00:00.000';
                        isClipPlaying = false;
                        return;
                    }

                    // Format time as MM:SS.mmm
                    const seconds = Math.floor(elapsed / 1000);
                    const milliseconds = elapsed % 1000;
                    const minutes = Math.floor(seconds / 60);
                    const remainingSeconds = seconds % 60;
                    timeDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}.${String(milliseconds).padStart(3, '0')}`;
                }, 50);
            }
        }
    </script>
</body>

</html>