<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WaveEdit</title>
    <link rel="stylesheet" href="gradients.css">
    <script src="audio-configs.js"></script>
    <style>
        :root {
            /* Color Variables */
            --primary-brown: #8B6F47;
            --primary-brown-dark: #6B5837;
            --primary-red: #e74c3c;
            --primary-red-dark: #c0392b;
            --primary-orange: #f39c12;
            --primary-green: #27ae60;
            --primary-blue: #3498db;
            --primary-teal: #1abc9c;
            --primary-gray: #95a5a6;
            --primary-dark-blue: #34495e;
            --primary-dark-blue-alt: #2c3e50;

            /* Background Colors */
            --bg-primary: #1a1a1a;
            --bg-secondary: #2a2a2a;
            --bg-tertiary: #333;
            --bg-darker: #1e1e1e;
            --bg-transport: #252525;
            --bg-plugin-active: #4A3C2A;
            --bg-menu: #2c2c2c;
            --bg-hover: #404040;
            --bg-hover-light: #505050;
            --border-color: #444;
            --border-color-light: #555;
            --border-color-medium: #666;

            /* Text Colors */
            --text-primary: #ffffff;
            --text-secondary: #ecf0f1;
            --text-muted: #888;
            --text-light: #aaa;
            --text-very-light: #95a5a6;

            /* Effects */
            --shadow-subtle: 0 3px 8px rgba(0, 0, 0, 0.3);
            --shadow-glow: 0 0 10px rgba(243, 156, 18, 0.3);
            --transition-fast: all 0.2s ease;
            --transition-hover: all 0.1s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }

        /* Common Button Base */
        .btn-base {
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: bold;
        }

        .btn-round {
            border-radius: 50%;
        }

        .btn-rounded {
            border-radius: 5px;
        }

        /* Main App Layout */
        .app {
            display: flex;
            height: 100vh;
            flex-direction: column;
            overflow: hidden;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        /* Title Bar */
        .title-bar {
            height: 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            background: linear-gradient(90deg, var(--primary-brown-dark), var(--primary-brown));
        }

        .title-text {
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .window-controls {
            display: flex;
            gap: 10px;
        }

        .window-btn {
            border: none;
            cursor: pointer;
            transition: var(--transition-fast);
            font-weight: bold;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            color: white;
        }

        .minimize {
            background: var(--primary-orange);
        }

        .maximize {
            background: var(--primary-green);
        }

        .close {
            background: var(--primary-red);
        }

        /* Menu Bar */
        .menu-bar {
            height: 30px;
            display: flex;
            align-items: center;
            padding: 0 15px;
            background: var(--bg-menu);
            border-bottom: 1px solid var(--border-color);
            gap: 20px;
            flex-shrink: 0;
        }

        .menu-item {
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 3px;
            transition: var(--transition-fast);
        }

        .menu-item:hover {
            background: var(--bg-hover);
        }

        .menu-item.inactive {
            color: var(--text-muted);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .menu-item.inactive:hover {
            background: transparent;
        }

        /* Load dropdown styles */
        .load-menu {
            position: relative;
        }

        .load-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            min-width: 200px;
            background: var(--bg-menu);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            box-shadow: var(--shadow-subtle);
            z-index: 1000;
            display: none;
        }

        .load-dropdown.show {
            display: block;
        }

        .load-option {
            padding: 8px 12px;
            cursor: pointer;
            transition: var(--transition-fast);
            border-bottom: 1px solid var(--border-color);
        }

        .load-option:last-child {
            border-bottom: none;
        }

        .load-option:hover {
            background: var(--bg-hover);
        }

        /* Settings dropdown styles */
        .settings-menu {
            position: relative;
        }

        .settings-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            min-width: 200px;
            background: var(--bg-menu);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            box-shadow: var(--shadow-subtle);
            z-index: 1000;
            display: none;
        }

        .settings-dropdown.show {
            display: block;
        }

        .settings-option {
            padding: 8px 12px;
            cursor: pointer;
            transition: var(--transition-fast);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .settings-option:hover {
            background: var(--bg-hover);
        }

        .settings-option:last-child {
            border-bottom: none;
        }

        .settings-option:hover {
            background: var(--bg-hover);
        }

        .settings-checkbox {
            margin: 0;
            cursor: pointer;
            accent-color: var(--primary-orange);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        /* Panel Base */
        .panel-base {
            background: var(--bg-secondary);
            padding: 10px;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .left-panel {
            background: var(--bg-secondary);
            padding: 0;
            overflow-y: auto;
            overflow-x: hidden;
            flex-shrink: 0;
            width: 220px;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        .left-panel-section {
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .left-panel-section:last-child {
            border-bottom: none;
            flex: 1;
        }

        .right-panel {
            background: var(--bg-secondary);
            padding: 0;
            overflow-y: auto;
            flex-shrink: 0;
            width: 280px;
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        .right-panel-section {
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .right-panel-section:last-child {
            border-bottom: none;
            flex: 1;
        }

        .section-header {
            background: var(--bg-darker);
            padding: 12px 15px;
            font-size: 11px;
            font-weight: bold;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid var(--border-color);
        }

        .section-content {
            padding: 15px;
        }

        /* File Info Section */
        .file-info {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .current-file {
            font-weight: bold;
            font-size: 11px;
            color: var(--text-primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .file-stats {
            font-size: 11px;
            color: var(--text-muted);
            font-family: 'Courier New', monospace;
        }

        .file-goal {
            font-size: 11px;
            color: var(--primary-orange);
            font-weight: 500;
            font-style: italic;
            line-height: 1.3;
            margin-top: 4px;
        }

        /* Responsive Layout for Widescreen */
        @media (min-width: 1920px) {
            .left-panel {
                width: 260px;
            }

            .right-panel {
                width: 350px;
            }

            .vu-meter-large {
                width: 45px;
                height: 280px;
            }

            .section-content {
                padding: 20px;
            }
        }

        @media (min-width: 2560px) {
            .left-panel {
                width: 280px;
            }

            .right-panel {
                width: 400px;
            }

            .vu-meter-large {
                width: 50px;
                height: 320px;
            }

            .vu-meters-container {
                padding: 25px;
            }


        }

        /* Center Panel */
        .center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-darker);
            overflow: hidden;
            position: relative;
        }

        /* Timeline Header */
        .timeline-header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .timeline-instructions {
            padding: 10px 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            background: var(--bg-transport);
            border-bottom: 1px solid var(--border-color);
        }

        .instruction-item {
            font-size: 11px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .instruction-item strong {
            color: var(--text-primary);
        }

        .vu-meters-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .vu-title {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 15px;
            font-weight: bold;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .vu-meters {
            display: flex;
            gap: 20px;
            align-items: flex-end;
            justify-content: center;
            width: 100%;
        }

        .vu-meter {
            width: 30px;
            height: 200px;
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .vu-meter-large {
            width: 40px;
            height: 250px;
        }

        .vu-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top,
                    #27ae60 0%,
                    #f39c12 70%,
                    #e74c3c 90%);
            transition: height 0.1s ease-out;
            border-radius: 6px;
        }

        .vu-peak {
            position: absolute;
            left: 0;
            right: 0;
            height: 2px;
            background: #ffffff;
            transition: top 0.05s ease-out;
            border-radius: 1px;
            opacity: 0.8;
        }

        .vu-labels {
            display: flex;
            gap: 20px;
            margin-top: 12px;
            justify-content: center;
            width: 100%;
        }

        .vu-label {
            font-size: 14px;
            color: var(--text-muted);
            text-align: center;
            width: 30px;
            font-weight: bold;
        }

        .vu-label-large {
            width: 40px;
            font-size: 16px;
        }

        .main-playback-simple {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .main-time-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .main-position-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            position: relative;
            cursor: pointer;
            transition: height 0.2s ease;
        }

        .main-position-bar:hover {
            height: 8px;
        }

        .main-position-fill {
            height: 100%;
            background: var(--primary-orange);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s ease;
            box-shadow: 0 0 8px rgba(243, 156, 18, 0.4);
        }

        .main-controls-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .main-playback-title {
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 8px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            letter-spacing: 1px;
        }

        .main-playback-controls {
            display: flex;
            align-items: center;
            gap: 18px;
        }

        .main-buttons {
            display: flex;
            gap: 8px;
        }

        .main-loop-container {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .main-loop-label {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            padding: 6px 12px;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
            backdrop-filter: blur(5px);
        }

        .main-loop-label:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .main-loop-label input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
            accent-color: var(--primary-orange);
        }

        .loop-text {
            color: var(--text-primary);
            font-size: 12px;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .main-time-display {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .transport-btn {
            border: none;
            cursor: pointer;
            transition: var(--transition-fast);
            font-weight: bold;
            border-radius: 8px;
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            line-height: 1;
            backdrop-filter: blur(5px);
        }

        .transport-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .transport-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .time-display {
            font-family: 'Courier New', monospace;
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
            text-align: center;
        }

        /* Timeline */
        .timeline-container {
            flex: 1;
            padding: 20px 20px 100px 20px;
            /* Extra bottom padding for scrolling */
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            max-height: calc(100vh - 140px);
            /* Account for title bar, menu, timeline header */
        }

        /* Custom scrollbar for timeline */
        .timeline-container::-webkit-scrollbar {
            width: 12px;
        }

        .timeline-container::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 6px;
        }

        .timeline-container::-webkit-scrollbar-thumb {
            background: var(--border-color-medium);
            border-radius: 6px;
            border: 2px solid var(--bg-secondary);
        }

        .timeline-container::-webkit-scrollbar-thumb:hover {
            background: var(--text-light);
        }

        /* Custom minimal scrollbars for sidebars */
        .left-panel::-webkit-scrollbar,
        .right-panel::-webkit-scrollbar {
            width: 6px;
        }

        .left-panel::-webkit-scrollbar-track,
        .right-panel::-webkit-scrollbar-track {
            background: transparent;
        }

        .left-panel::-webkit-scrollbar-thumb,
        .right-panel::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
            transition: background 0.2s ease;
        }

        .left-panel::-webkit-scrollbar-thumb:hover,
        .right-panel::-webkit-scrollbar-thumb:hover {
            background: var(--border-color-medium);
        }

        .timeline-ruler {
            height: 30px;
            background: var(--bg-secondary);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            border-radius: 3px;
        }

        .time-marker {
            margin-right: 40px;
            font-size: 12px;
            color: var(--text-light);
        }

        /* Merged View */
        .merged-view {
            min-height: 240px;
            max-height: 400px;
            /* Prevent merged view from becoming too tall */
            background: var(--bg-tertiary);
            margin-bottom: 20px;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }



        .merged-view::before {
            content: "MERGED VIEW";
            position: absolute;
            top: 5px;
            left: 10px;
            font-size: 12px;
            color: var(--text-light);
            z-index: 20;
        }

        /* Track layer in merged view */
        #merged.track-layer {
            min-height: 240px !important;
            max-height: 400px !important;
            /* Scale with merged view height */
        }

        /* Track content in merged view */
        #merged .track-content {
            min-height: 240px !important;
            max-height: 400px !important;
            /* Scale with merged view height */
            background: linear-gradient(90deg, var(--primary-dark-blue-alt) 0%, var(--primary-dark-blue-alt) 100%);
            position: relative;
        }

        .merged-waveform {
            position: absolute;
            bottom: 5px;
            left: 10px;
            right: 30px;
            height: 15px;
            border-radius: 2px;
            opacity: 0.8;
        }

        /* Track Layers */
        .track-layer {
            height: 60px;
            background: var(--bg-secondary);
            margin-bottom: 10px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            padding: 0 15px;
            position: relative;
        }

        .track-info {
            width: 150px;
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 4px 0;
            line-height: 0.6;
        }



        .track-controls {
            display: flex;
            gap: 5px;
            margin-left: auto;
            margin-right: 10px;
        }

        .track-content {
            flex: 1;
            height: 30px;
            margin-left: 20px;
            position: relative;
            border-radius: 3px;
        }

        /* Analyze button overlay */
        .analyze-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .analyze-btn {
            padding: 8px 16px;
            background: var(--primary-brown);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: var(--transition-fast);
        }

        .analyze-btn:hover {
            background: var(--primary-brown-dark);
            transform: translateY(-2px);
            box-shadow: var(--shadow-subtle);
        }

        /* Analysis minigame styles */
        .track-layer:not(#merged) {
            display: none;
        }

        .analysis-clip {
            position: absolute;
            height: 20px;
            top: 20px;
            border-radius: 3px;
            cursor: pointer;
            border: 2px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #666;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
            user-select: none;
            transition: all 0.2s ease;
            z-index: 20;
            background: #444;
            pointer-events: none;
        }

        .analysis-clip.revealed {
            animation: reveal 0.5s ease-out;
        }

        @keyframes reveal {
            0% {
                transform: scale(1);
                opacity: 0.5;
            }

            50% {
                transform: scale(1.2);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .selection-box {
            position: absolute;
            border: 2px dashed #1abc9c;
            background: rgba(26, 188, 156, 0.1);
            pointer-events: none;
            z-index: 30;
        }

        .selection-box.invalid {
            border-color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
        }

        /* Audio clip styling */
        .audio-clip {
            position: absolute;
            height: 20px;
            top: 5px;
            border-radius: 3px;
            cursor: pointer;
            border: 1.5px solid rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 0 0.5px rgba(0, 0, 0, 0.8), 0 2px 4px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.9);
            user-select: none;
            transition: all 0.2s ease;
            background: rgba(0, 0, 0, 0.1);
            overflow: hidden;
            font-style: normal !important;
            /* Prevent italic */
            z-index: 5;
            /* Base layer for clip */
        }

        /* Override the vertical line pattern from gradients.css with flat color */
        .audio-clip::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.1) !important;
            opacity: 1 !important;
            z-index: 0;
        }

        /* Clip waveform visualization */
        .clip-waveform {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: currentColor;
            opacity: 0.3;
            z-index: 1;
            pointer-events: none;
        }

        /* Clip effect icons container */
        .clip-effects-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 12px;
            z-index: 1;
            /* Below text */
            pointer-events: none;
        }

        /* Clip effect icons */
        .clip-effect {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 8px;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
            line-height: 1;
            font-style: normal !important;
            /* Prevent italic */
        }

        /* Ensure text is always on top */
        .audio-clip::after {
            content: attr(data-clip);
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            /* Above everything */
            font-style: normal !important;
            /* Prevent italic */
        }

        /* Hide the original text content */
        .audio-clip {
            color: transparent;
        }

        .clip-effect+.clip-effect {
            left: 14px;
        }

        .clip-effect+.clip-effect+.clip-effect {
            left: 26px;
        }

        .clip-effect+.clip-effect+.clip-effect+.clip-effect {
            left: 38px;
        }

        /* Hide effect icons in merged view */
        #merged .clip-effects-container {
            display: none;
        }

        /* View mode toggle styles */
        .view-mode-toggle {
            display: flex;
            gap: 2px;
            margin-top: 4px;
        }

        .mode-btn {
            background: var(--bg-hover);
            border: 1px solid var(--border-color);
            color: var(--text-light);
            padding: 2px 6px;
            font-size: 0.65em;
            border-radius: 3px;
            cursor: pointer;
            transition: var(--transition-fast);
            flex: 1;
            text-align: center;
        }

        .mode-btn:hover {
            background: var(--bg-hover-light);
            border-color: var(--border-color-light);
        }

        .mode-btn.active {
            background: var(--primary-brown);
            border-color: var(--primary-brown-dark);
            color: var(--text-primary);
        }

        /* Add styles for merged view clips */
        #merged .audio-clip {
            pointer-events: none !important;
            opacity: 0.8;
            z-index: 1;
            height: 18px;
            top: 0;
            /* Reset top position, will be set by JS */
            cursor: default;
            border: 1.5px solid rgba(255, 255, 255, 0.7);
            box-shadow: 0 0 0 0.5px rgba(0, 0, 0, 0.9), 0 2px 6px rgba(0, 0, 0, 0.4);
        }

        #merged .audio-clip.revealed {
            opacity: 0.9;
            z-index: 2;
            pointer-events: none !important;
        }

        /* Layer-specific colors for merged view */
        /* find_the_murderer.wav layers */
        #merged .audio-clip[data-layer="evidence-recording"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="ghost-voices"] {
            color: #8e44ad;
        }

        #merged .audio-clip[data-layer="investigation"] {
            color: #27ae60;
        }

        #merged .audio-clip[data-layer="ambient-static-wave"] {
            color: #34495e;
        }

        /* morse_code.wav layers */
        #merged .audio-clip[data-layer="morse-signals"] {
            color: #3498db;
        }

        #merged .audio-clip[data-layer="radio-static"] {
            color: #95a5a6;
        }

        /* noise_profiling.wav layers */
        #merged .audio-clip[data-layer="vocal-track"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="background-noise"] {
            color: #f39c12;
        }

        #merged .audio-clip[data-layer="electrical-interference"] {
            color: #1abc9c;
        }

        #merged .audio-clip[data-layer="mechanical-sounds"] {
            color: #e67e22;
        }

        #merged .audio-clip[data-layer="digital-artifacts"] {
            color: #9b59b6;
        }

        #merged .audio-clip[data-layer="frequency-sweeps"] {
            color: #27ae60;
        }

        #merged .audio-clip[data-layer="calibration-tones"] {
            color: #34495e;
        }

        /* orchestra_hickups.wav layers */
        #merged .audio-clip[data-layer="violin-section"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="brass-section"] {
            color: #f39c12;
        }

        #merged .audio-clip[data-layer="woodwind-section"] {
            color: #27ae60;
        }

        #merged .audio-clip[data-layer="percussion-section"] {
            color: #9b59b6;
        }

        /* vocal_harmony.wav layers */
        #merged .audio-clip[data-layer="vocal-track"] {
            color: #e67e22;
        }

        /* getaway_analysis.wav layers */
        #merged .audio-clip[data-layer="digital-corruption"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="engine-signature"] {
            color: #3498db;
        }

        /* seasonal_birds.wav layers */
        #merged .audio-clip[data-layer="target-bird-call"] {
            color: #27ae60;
        }

        #merged .audio-clip[data-layer="forest-ambience"] {
            color: #2c3e50;
        }

        #merged .audio-clip[data-layer="viola-breathing"] {
            color: #8e44ad;
        }

        #merged .audio-clip[data-layer="unknown-presence"] {
            color: #e74c3c;
        }

        .audio-clip:hover {
            transform: translateY(-1px);
            box-shadow: 0 0 0 0.5px rgba(0, 0, 0, 0.9), 0 4px 12px rgba(0, 0, 0, 0.4);
            border-color: rgba(255, 255, 255, 0.8);
        }

        .audio-clip.selected {
            border: 2px solid #f39c12;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.3);
        }

        .audio-clip.dragging {
            z-index: 1000;
            transform: rotate(5deg);
            opacity: 0.8;
        }

        .audio-clip.disabled {
            opacity: 0.3;
            filter: grayscale(100%);
            pointer-events: none;
        }

        /* Layer-specific colors */
        /* find_the_murderer.wav layers */
        #evidence-recording .audio-clip {
            color: #e74c3c;
        }

        #ghost-voices .audio-clip {
            color: #8e44ad;
        }

        #investigation .audio-clip {
            color: #27ae60;
        }

        #ambient-static-wave .audio-clip {
            color: #34495e;
        }

        /* morse_code.wav layers */
        #morse-signals .audio-clip {
            color: #3498db;
        }

        #radio-static .audio-clip {
            color: #95a5a6;
        }

        /* noise_profiling.wav layers */
        #vocal-track .audio-clip {
            color: #e74c3c;
        }

        #background-noise .audio-clip {
            color: #f39c12;
        }

        #electrical-interference .audio-clip {
            color: #1abc9c;
        }

        #mechanical-sounds .audio-clip {
            color: #e67e22;
        }

        #digital-artifacts .audio-clip {
            color: #9b59b6;
        }

        #frequency-sweeps .audio-clip {
            color: #27ae60;
        }

        #calibration-tones .audio-clip {
            color: #34495e;
        }

        /* orchestra_hickups.wav layers */
        #violin-section .audio-clip {
            color: #e74c3c;
        }

        #brass-section .audio-clip {
            color: #f39c12;
        }

        #woodwind-section .audio-clip {
            color: #27ae60;
        }

        #percussion-section .audio-clip {
            color: #9b59b6;
        }

        /* vocal_harmony.wav layers - reusing #vocal-track but different color */
        #vocal-harmony .audio-clip {
            color: #e67e22;
        }

        /* getaway_analysis.wav layers */
        #digital-corruption .audio-clip {
            color: #e74c3c;
        }

        #engine-signature .audio-clip {
            color: #3498db;
        }

        /* seasonal_birds.wav layers */
        #target-bird-call .audio-clip {
            color: #27ae60;
        }

        #forest-ambience .audio-clip {
            color: #2c3e50;
        }

        #viola-breathing .audio-clip {
            color: #8e44ad;
        }

        #unknown-presence .audio-clip {
            color: #e74c3c;
        }

        /* Layer background colors to match clip colors with good contrast */
        /* find_the_murderer.wav layers */
        #evidence-recording {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        #ghost-voices {
            background: linear-gradient(90deg, rgba(142, 68, 173, 0.15), rgba(142, 68, 173, 0.08));
        }

        #investigation {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.15), rgba(39, 174, 96, 0.08));
        }

        #ambient-static-wave {
            background: linear-gradient(90deg, rgba(52, 73, 94, 0.15), rgba(52, 73, 94, 0.08));
        }

        /* morse_code.wav layers */
        #morse-signals {
            background: linear-gradient(90deg, rgba(52, 152, 219, 0.15), rgba(52, 152, 219, 0.08));
        }

        #radio-static {
            background: linear-gradient(90deg, rgba(149, 165, 166, 0.15), rgba(149, 165, 166, 0.08));
        }

        /* noise_profiling.wav layers */
        #vocal-track {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        #background-noise {
            background: linear-gradient(90deg, rgba(243, 156, 18, 0.15), rgba(243, 156, 18, 0.08));
        }

        #electrical-interference {
            background: linear-gradient(90deg, rgba(26, 188, 156, 0.15), rgba(26, 188, 156, 0.08));
        }

        #mechanical-sounds {
            background: linear-gradient(90deg, rgba(230, 126, 34, 0.15), rgba(230, 126, 34, 0.08));
        }

        #digital-artifacts {
            background: linear-gradient(90deg, rgba(155, 89, 182, 0.15), rgba(155, 89, 182, 0.08));
        }

        #frequency-sweeps {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.15), rgba(39, 174, 96, 0.08));
        }

        #calibration-tones {
            background: linear-gradient(90deg, rgba(52, 73, 94, 0.15), rgba(52, 73, 94, 0.08));
        }

        /* orchestra_hickups.wav layers */
        #violin-section {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        #brass-section {
            background: linear-gradient(90deg, rgba(243, 156, 18, 0.15), rgba(243, 156, 18, 0.08));
        }

        #woodwind-section {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.15), rgba(39, 174, 96, 0.08));
        }

        #percussion-section {
            background: linear-gradient(90deg, rgba(155, 89, 182, 0.15), rgba(155, 89, 182, 0.08));
        }

        /* vocal_harmony.wav layers - reusing vocal-track styling but different ID */
        #vocal-harmony {
            background: linear-gradient(90deg, rgba(230, 126, 34, 0.15), rgba(230, 126, 34, 0.08));
        }

        /* getaway_analysis.wav layers */
        #digital-corruption {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        #engine-signature {
            background: linear-gradient(90deg, rgba(52, 152, 219, 0.15), rgba(52, 152, 219, 0.08));
        }

        /* seasonal_birds.wav layers */
        #target-bird-call {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.15), rgba(39, 174, 96, 0.08));
        }

        #forest-ambience {
            background: linear-gradient(90deg, rgba(44, 62, 80, 0.15), rgba(44, 62, 80, 0.08));
        }

        #viola-breathing {
            background: linear-gradient(90deg, rgba(142, 68, 173, 0.15), rgba(142, 68, 173, 0.08));
        }

        #unknown-presence {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        /* Plugin applied effects */
        .clip-volume-boost {
            border-top: 2px solid #1abc9c;
        }

        .clip-denoise {
            opacity: 0.8;
            border-top: 2px solid #95a5a6;
        }

        .clip-frequency {
            border-top: 2px solid #3498db;
        }

        .clip-speed {
            font-style: italic;
            border-top: 2px solid #e67e22;
        }

        .clip-volume-boost::before {
            content: 'ðŸ”Š';
            position: absolute;
            top: -12px;
            left: 2px;
            font-size: 8px;
        }

        .clip-denoise::before {
            content: 'ðŸŒ«';
            position: absolute;
            top: -12px;
            left: 2px;
            font-size: 8px;
        }

        .clip-frequency::before {
            content: 'ðŸ“Š';
            position: absolute;
            top: -12px;
            left: 2px;
            font-size: 8px;
        }

        .clip-speed::before {
            content: 'âš¡';
            position: absolute;
            top: -12px;
            left: 2px;
            font-size: 8px;
        }

        /* Track states */
        .track-muted {
            opacity: 0.4;
        }

        .track-soloed {
            box-shadow: 0 0 5px #f39c12;
        }

        .track-stereo .track-content {
            height: 50px;
        }

        .track-stereo .track-content::after {
            content: '';
            position: absolute;
            bottom: 5px;
            left: 0;
            right: 0;
            height: 18px;
            background: inherit;
            opacity: 0.6;
            border-radius: 3px;
        }

        /* Drag and drop zones */
        .drop-zone {
            min-height: 30px;
            border: 2px dashed transparent;
            margin: 2px 0;
            transition: all 0.3s ease;
        }

        .drop-zone.drag-over {
            border-color: #1abc9c;
            background: rgba(26, 188, 156, 0.1);
        }

        /* Audio control buttons */
        .audio-control {
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            transition: all 0.2s ease;
            font-size: 12px;
            border: 1px solid transparent;
        }

        .audio-control:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .audio-control.active {
            background: rgba(243, 156, 18, 0.3);
            border-color: #f39c12;
        }

        .audio-control.muted {
            color: #e74c3c;
        }

        .audio-control.soloed {
            color: #f39c12;
            background: rgba(243, 156, 18, 0.2);
        }

        /* Color themes */
        .waveedit .track-layer {
            border-left: 3px solid var(--primary-brown);
        }

        .waveedit .transport-controls {
            border-bottom-color: var(--primary-brown);
        }

        /* Tools Panel States */
        .tools-message {
            color: #888;
            font-size: 14px;
            text-align: center;
            padding: 20px;
            font-style: italic;
            border-bottom: 1px solid #444;
            margin-bottom: 15px;
        }

        .tools-container {
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        /* Selected Clip Display */
        .selected-clip-display {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 12px;
            margin-bottom: 15px;
            display: none;
            box-shadow: var(--shadow-subtle);
        }

        .selected-clip-title {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: bold;
        }

        .selected-clip-name {
            font-weight: bold;
            margin-bottom: 8px;
            color: var(--text-secondary);
            font-size: 14px;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }

        .selected-clip-controls {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            margin-bottom: 8px;
        }

        .clip-buttons {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .clip-playback-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
        }

        .clip-loop-label {
            display: flex;
            align-items: center;
            gap: 3px;
            color: var(--text-light);
            font-size: 11px;
            cursor: pointer;
            user-select: none;
        }

        .clip-loop-label input[type="checkbox"] {
            margin: 0;
            transform: scale(0.8);
            cursor: pointer;
        }

        .selected-clip-play-btn,
        .selected-clip-stop-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition-fast);
            font-weight: bold;
            font-size: 14px;
            backdrop-filter: blur(5px);
            line-height: 1;
            text-align: center;
        }

        .selected-clip-play-btn:hover,
        .selected-clip-stop-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .selected-clip-stop-btn {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .selected-clip-stop-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .selected-clip-time {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: var(--text-muted);
        }

        .selected-clip-waveform {
            height: 20px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            position: relative;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }

        .selected-clip-waveform .clip-waveform {
            opacity: 0.7;
        }

        /* Override the selected clip waveform pattern from gradients.css with flat color */
        .selected-clip-waveform::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.2) !important;
            opacity: 1 !important;
            z-index: 0;
        }

        .selected-clip-playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #f39c12;
            left: 0%;
            pointer-events: none;
            z-index: 10;
            transition: left 0.1s ease;
        }

        /* Add slider styles */
        .slider-container {
            margin: 8px 0;
            position: relative;
            height: 20px;
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .slider-track {
            position: relative;
            height: 4px;
            background: var(--border-color);
            border-radius: 2px;
            margin: 8px 0;
        }

        .slider-center-mark {
            position: absolute;
            left: 50%;
            top: -2px;
            bottom: -2px;
            width: 1px;
            background: rgba(255, 255, 255, 0.3);
            transform: translateX(-50%);
            pointer-events: none;
        }

        .slider-fill {
            position: absolute;
            height: 100%;
            background: var(--primary-brown);
            border-radius: 2px;
            width: 50%;
            /* Start at center */
            transition: width 0.1s ease;
        }

        .slider-thumb {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #fff;
            border: 2px solid var(--primary-brown);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            transition: all 0.1s ease;
        }

        .slider-thumb:hover {
            transform: translate(-50%, -50%) scale(1.2);
        }

        .plugin-section.disabled .slider-track,
        .plugin-section.disabled .slider-thumb {
            opacity: 0.3;
            pointer-events: none;
        }

        .plugin-section.disabled .slider-labels {
            opacity: 0.3;
        }

        /* Plugin sections */
        .plugin-section {
            margin-bottom: 15px;
            border: 1px solid var(--border-color-light);
            border-radius: 5px;
            padding: 10px;
            background: var(--bg-tertiary);
            cursor: pointer;
            transition: var(--transition-fast);
            position: relative;
        }

        .plugin-section:has(.slider-container) {
            cursor: default;
        }

        .plugin-section:hover:not(.disabled):not(:has(.slider-container)) {
            background: var(--bg-hover);
            border-color: var(--primary-brown);
        }

        .plugin-section.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        .plugin-section.active {
            border-color: var(--primary-brown);
            background: var(--bg-plugin-active);
        }

        .plugin-section.active .plugin-title {
            color: var(--primary-brown);
        }

        .plugin-section.active .checkbox {
            background: var(--primary-brown);
            border-color: var(--primary-brown);
        }

        .plugin-section.active .checkbox::after {
            content: 'âœ“';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            line-height: 1;
        }

        .plugin-section.disabled .checkbox {
            opacity: 0.3;
            pointer-events: none;
        }

        .plugin-title {
            font-weight: bold;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .checkbox {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-radius: 3px;
            background: transparent;
        }

        /* Ensure other track layers maintain their original height */
        .track-layer:not(#merged) {
            height: 60px !important;
        }

        .track-layer:not(#merged) .track-content {
            height: 30px !important;
        }

        /* Stem Isolation Loading Animation */
        .stem-isolation-overlay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            pointer-events: none;
        }

        .isolation-progress-container {
            background: var(--bg-secondary);
            border: 2px solid var(--primary-brown);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            text-align: center;
            min-width: 400px;
            backdrop-filter: blur(10px);
        }

        .isolation-title {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary-brown);
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(139, 111, 71, 0.5);
        }

        .isolation-status {
            font-size: 14px;
            color: var(--text-light);
            margin-bottom: 20px;
            min-height: 20px;
            font-style: italic;
        }

        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-brown), var(--primary-brown-dark));
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(139, 111, 71, 0.3);
        }

        .layer-status {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 10px;
        }

        /* MISC layer styles */
        .misc-layer {
            border-left: 3px solid #95a5a6;
        }

        .misc-layer .track-info span:first-child {
            color: #95a5a6;
        }

        /* Hidden small clips in MISC layers */
        .misc-layer .audio-clip.hidden-small {
            background: #444;
            color: #666;
            border: 2px solid #666;
            pointer-events: none;
        }

        .misc-layer .audio-clip.hidden-small::after {
            content: '???';
        }

        /* MISC layer colors */
        .misc-layer .audio-clip {
            color: #95a5a6;
        }

        .misc-layer {
            background: linear-gradient(90deg, rgba(149, 165, 166, 0.15), rgba(149, 165, 166, 0.08));
        }

        /* Merged view colors for MISC clips */
        #merged .audio-clip[data-layer^="misc-"] {
            color: #95a5a6;
        }

        /* MISC clips in merged view (zoom discovery) */
        .misc-clip-hidden {
            background: #444 !important;
            color: #666 !important;
            border: 2px solid #666 !important;
            pointer-events: auto !important;
            z-index: 50 !important;
            position: absolute !important;
        }

        /* Override the data-clip text display for MISC clips */
        .misc-clip-hidden::after {
            content: '???' !important;
        }

        /* Show true name for identified MISC clips */
        .identified::after {
            content: attr(data-clip) !important;
        }

        /* View mode overlay styles */
        .view-mode-overlay {
            position: absolute;
            bottom: 8px;
            left: 8px;
            display: none;
            gap: 4px;
            z-index: 15;
            pointer-events: auto;
        }

        /* Zoom controls styles */
        .zoom-controls {
            position: absolute;
            bottom: 8px;
            right: 8px;
            display: none;
            /* Hidden until stem isolation is complete */
            gap: 4px;
            z-index: 15;
            pointer-events: auto;
        }

        .zoom-controls.enabled {
            display: flex;
        }

        .zoom-btn {
            width: 32px;
            height: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            user-select: none;
        }

        .zoom-btn:hover {
            background: var(--bg-hover);
            border-color: var(--primary-brown);
            transform: translateY(-1px);
        }

        .zoom-btn:active {
            transform: translateY(0px);
        }

        .zoom-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }

        .zoom-level-display {
            position: absolute;
            bottom: 32px;
            right: 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 10px;
            color: var(--text-light);
            z-index: 15;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            display: none;
            /* Hidden until stem isolation is complete */
        }

        .zoom-level-display.enabled {
            display: block;
        }

        .zoom-level-display.show {
            opacity: 1;
        }

        /* Pan controls styles */
        .pan-controls {
            position: absolute;
            bottom: 8px;
            right: 80px;
            /* Position to the left of zoom controls */
            display: none;
            /* Hidden until stem isolation is complete */
            gap: 4px;
            z-index: 15;
            pointer-events: auto;
        }

        .pan-controls.enabled {
            display: flex;
        }

        .pan-btn {
            width: 32px;
            height: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            user-select: none;
        }

        .pan-btn:hover {
            background: var(--bg-hover);
            border-color: var(--primary-brown);
            transform: translateY(-1px);
        }

        .pan-btn:active {
            transform: translateY(0px);
        }

        .pan-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Waveform canvas styles */
        .waveform-canvas {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            /* Ensure pixel-perfect alignment with track content below */
            box-sizing: border-box;
        }

        /* Canvas waveform styling */

        /* Ensure perfect alignment between waveform and clips */

        /* Popup styles for ??? clips */
        .clip-popup {
            position: fixed;
            background: var(--bg-secondary);
            border: 2px solid var(--primary-brown);
            border-radius: 8px;
            padding: 15px 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            z-index: 2000;
            color: var(--text-primary);
            font-size: 14px;
            max-width: 300px;
            text-align: center;
            backdrop-filter: blur(10px);
            pointer-events: none;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.2s ease;
        }

        .clip-popup.show {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }

        .clip-popup::before {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid var(--primary-brown);
        }
    </style>
</head>

<body>
    <!-- Landing Screen -->
    <!-- Removed landing screen div -->

    <!-- Assembly App -->
    <!-- Removed Assembly app div -->

    <!-- WaveEdit App -->
    <div id="waveedit" class="app waveedit active">
        <div class="title-bar">
            <div class="title-text">
                ðŸŒŠ WaveEdit
            </div>
            <div class="window-controls">
                <button class="window-btn minimize">âˆ’</button>
                <button class="window-btn maximize">â–¡</button>
                <button class="window-btn close">âœ•</button>
            </div>
        </div>

        <div class="menu-bar">
            <span class="menu-item load-menu" onclick="toggleLoadMenu(event)">Load â–¼
                <div class="load-dropdown" id="load-dropdown">
                    <div class="load-option" onclick="loadAudioFile('1_simple_getaway_analysis.wav', event)">
                        1_simple_getaway_analysis.wav</div>
                    <div class="load-option" onclick="loadAudioFile('2_simple_vocal_harmony.wav', event)">
                        2_simple_vocal_harmony.wav</div>
                    <div class="load-option" onclick="loadAudioFile('3_medium_morse_code.wav', event)">
                        3_medium_morse_code.wav
                    </div>
                    <div class="load-option" onclick="loadAudioFile('4_medium_seasonal_birds.wav', event)">
                        4_medium_seasonal_birds.wav</div>
                    <div class="load-option" onclick="loadAudioFile('5_medium_find_the_murderer.wav', event)">
                        5_medium_find_the_murderer.wav</div>
                    <div class="load-option" onclick="loadAudioFile('6_complex_noise_profiling.wav', event)">
                        6_complex_noise_profiling.wav
                    </div>
                    <div class="load-option" onclick="loadAudioFile('7_complex_orchestra_hickups.wav', event)">
                        7_complex_orchestra_hickups.wav
                    </div>
                </div>
            </span>
            <span class="menu-item inactive">Save</span>
            <span class="menu-item inactive">Analyze</span>
            <span class="menu-item inactive">Details</span>
            <span class="menu-item inactive">Plugins</span>
            <span class="menu-item settings-menu" onclick="toggleSettingsMenu(event)">Settings â–¼
                <div class="settings-dropdown" id="settings-dropdown">
                    <div class="settings-option" onclick="removeBaseOverlay(); event.stopPropagation()">
                        <span>Remove base layers overlay</span>
                    </div>
                    <div class="settings-option" onclick="removeBaseTracks(); event.stopPropagation()">
                        <span>Remove base layers below</span>
                    </div>
                </div>
            </span>
            <span class="menu-item inactive">Help</span>
            <span class="menu-item inactive">License</span>
        </div>

        <div class="main-content">
            <!-- Left Control Panel -->
            <div class="left-panel">
                <!-- File Status Section -->
                <div class="left-panel-section">
                    <div class="section-header">ðŸ“ File Status</div>
                    <div class="section-content">
                        <div class="file-info">
                            <div class="current-file" id="current-file-name">1_simple_getaway_analysis.wav</div>
                            <div class="file-stats" id="file-stats">Duration: 00:47.0 â€¢ 44.1kHz</div>
                            <div class="file-goal" id="file-goal">Isolate the target bird call from background noise
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Main Playback Section -->
                <div class="left-panel-section">
                    <div class="section-header">ðŸŽµ Main Playback</div>
                    <div class="section-content">
                        <div class="main-playback-simple">
                            <div class="main-time-section">
                                <div class="time-display">00:00.0 / 00:47.0</div>
                                <div class="main-position-bar" onclick="seekToPosition(event)">
                                    <div class="main-position-fill" id="main-position-fill"></div>
                                </div>
                            </div>

                            <div class="main-controls-section">
                                <div class="main-buttons">
                                    <button class="transport-btn" onclick="toggleMainPlayback(event)">â–¶</button>
                                    <button class="transport-btn" onclick="stopMainPlayback(event)">â¹</button>
                                    <button class="transport-btn" onclick="seekToStart(event)">â®</button>
                                    <button class="transport-btn" onclick="seekToEnd(event)">â­</button>
                                </div>

                                <div class="main-loop-container">
                                    <label class="main-loop-label">
                                        <input type="checkbox" id="main-loop-checkbox">
                                        <span class="loop-text">ðŸ”„ Loop</span>
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- VU Meters Section -->
                <div class="left-panel-section">
                    <div class="section-header">ðŸ“Š VU Meters</div>
                    <div class="vu-meters-container">
                        <div class="vu-meters">
                            <div class="vu-meter vu-meter-large" id="vu-left">
                                <div class="vu-fill"></div>
                                <div class="vu-peak"></div>
                            </div>
                            <div class="vu-meter vu-meter-large" id="vu-right">
                                <div class="vu-fill"></div>
                                <div class="vu-peak"></div>
                            </div>
                        </div>
                        <div class="vu-labels">
                            <div class="vu-label vu-label-large">L</div>
                            <div class="vu-label vu-label-large">R</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="center-panel">
                <div class="timeline-header">
                    <div class="section-header">ðŸ“ˆ Timeline View</div>
                    <div class="timeline-instructions">
                        <span class="instruction-item">ðŸ–±ï¸ <strong>Zoom:</strong> Mouse wheel up/down</span>
                        <span class="instruction-item">ðŸŽ¯ <strong>Pan:</strong> Middle mouse or arrow keys</span>
                        <span class="instruction-item">ðŸ“¦ <strong>Analyze:</strong> Drag w/ left mouse button</span>
                    </div>
                </div>

                <div class="track-layer" id="merged">
                    <div class="track-info">
                        <span style="font-weight: bold; color: #ecf0f1;">Root Layer</span>
                    </div>
                    <div class="track-content"
                        style="background: linear-gradient(90deg, #2c3e50 0%, #2c3e50 100%); position: relative;"
                        onclick="selectClip(event)">
                        <!-- Canvas-based waveform visualization -->
                        <!-- Playback marker -->
                        <div id="playback-marker"
                            style="position: absolute; top: 0; bottom: 0; width: 2px; background: #f39c12; left: 0%; pointer-events: none; z-index: 100;">
                        </div>
                        <!-- Stem Isolation button overlay -->
                        <div class="analyze-overlay">
                            <button class="analyze-btn" onclick="stemIsolation(event)">Isolate Audio Stems</button>
                        </div>

                        <!-- View mode toggle overlay (hidden initially) -->
                        <div class="view-mode-overlay" id="view-mode-overlay" style="display: none;">
                            <button class="mode-btn active" data-mode="waveform" onclick="switchViewMode('waveform')">ðŸ“Š
                                Wave</button>
                            <button class="mode-btn" data-mode="spectrogram" onclick="switchViewMode('spectrogram')">ðŸŒˆ
                                Spec</button>
                        </div>
                        <!-- Zoom controls -->
                        <div class="zoom-controls">
                            <button class="zoom-btn" onclick="zoomOut(event)"
                                title="Zoom Out (Mouse wheel down)">ðŸ”âˆ’</button>
                            <button class="zoom-btn" onclick="zoomIn(event)"
                                title="Zoom In (Mouse wheel up)">ðŸ”+</button>
                        </div>
                        <!-- Pan controls -->
                        <div class="pan-controls">
                            <button class="pan-btn" onclick="panLeft(event)" title="Pan Left (Left arrow)">â—€</button>
                            <button class="pan-btn" onclick="panRight(event)" title="Pan Right (Right arrow)">â–¶</button>
                        </div>
                        <!-- Zoom level display -->
                        <div class="zoom-level-display" id="zoom-level-display">100%</div>
                    </div>
                </div>

                <div class="track-layer" id="evidence-recording">
                    <div class="track-info">
                        <span style="font-size: 0.8em; color: #95a5a6;">Layer 1</span><br>
                        <span style="font-weight: bold; color: #ecf0f1;">Evidence_Recording</span>
                    </div>
                    <div class="track-content"
                        style="background: linear-gradient(90deg, #555 0%, #555 100%); position: relative;"
                        onclick="selectClip(event)">
                        <div class="audio-clip" data-clip="initial_scream"
                            style="left: 15%; width: 15%; height: 18px; top: 6px;" title="Initial scream">initial_scream
                        </div>
                        <div class="audio-clip" data-clip="struggle_sounds"
                            style="left: 45%; width: 20%; height: 18px; top: 6px;" title="Struggle sounds">
                            struggle_sounds</div>
                        <div class="audio-clip" data-clip="last_words"
                            style="left: 80%; width: 15%; height: 18px; top: 6px;" title="Last words">last_words</div>
                    </div>

                </div>

                <div class="track-layer" id="ghost-voices">
                    <div class="track-info">
                        <span style="font-size: 0.8em; color: #95a5a6;">Layer 2</span><br>
                        <span style="font-weight: bold; color: #ecf0f1;">Ghost_Voices</span>
                    </div>
                    <div class="track-content"
                        style="background: linear-gradient(90deg, #2c3e50 0%, #2c3e50 100%); position: relative;"
                        onclick="selectClip(event)">
                        <div class="audio-clip" data-clip="whisper_1"
                            style="left: 20%; width: 10%; height: 18px; top: 6px;" title="Second whisper">whisper_1
                        </div>
                        <div class="audio-clip" data-clip="whisper_2"
                            style="left: 35%; width: 10%; height: 18px; top: 6px;" title="Third whisper">whisper_2</div>
                        <div class="audio-clip" data-clip="whisper_3"
                            style="left: 55%; width: 7%; height: 18px; top: 6px;" title="Fourth whisper">whisper_3</div>
                        <div class="audio-clip" data-clip="whisper_4"
                            style="left: 70%; width: 9%; height: 18px; top: 6px;" title="Fifth whisper">whisper_4</div>
                    </div>

                </div>

                <div class="track-layer" id="investigation">
                    <div class="track-info">
                        <span style="font-size: 0.8em; color: #95a5a6;">Layer 3</span><br>
                        <span style="font-weight: bold; color: #ecf0f1;">Investigation_Notes</span>
                    </div>
                    <div class="track-content"
                        style="background: linear-gradient(90deg, #34495e 0%, #34495e 100%); position: relative;"
                        onclick="selectClip(event)">
                        <div class="audio-clip" data-clip="police_report"
                            style="left: 40%; width: 15%; height: 18px; top: 6px;" title="Police recording">
                            police_report</div>
                        <div class="audio-clip" data-clip="witness_statement"
                            style="left: 70%; width: 20%; height: 18px; top: 6px;" title="Witness statement">
                            witness_statement</div>
                    </div>

                </div>

                <div class="track-layer" id="ambient-static-wave">
                    <div class="track-info">
                        <span style="font-size: 0.8em; color: #95a5a6;">Layer 4</span><br>
                        <span style="font-weight: bold; color: #ecf0f1;">Ambient_Static</span>
                    </div>
                    <div class="track-content"
                        style="background: linear-gradient(90deg, #1a1a1a 0%, #1a1a1a 100%); position: relative;"
                        onclick="selectClip(event)">
                        <div class="audio-clip" data-clip="room_tone"
                            style="left: 10%; width: 20%; height: 18px; top: 6px;" title="Room tone">room_tone</div>
                        <div class="audio-clip" data-clip="static_burst"
                            style="left: 35%; width: 20%; height: 18px; top: 6px;" title="Static burst">static_burst
                        </div>
                        <div class="audio-clip" data-clip="tape_hiss"
                            style="left: 70%; width: 25%; height: 18px; top: 6px;" title="Tape hiss">tape_hiss</div>
                    </div>

                </div>
            </div>

            <div class="right-panel">
                <!-- Current Clip Section -->
                <div class="right-panel-section">
                    <div class="section-header">ðŸŽ¯ Current Clip</div>
                    <div class="section-content">
                        <div id="tools-message" class="tools-message">Run Isolate Audio Stems to separate audio layers
                            and unlock tools.</div>
                        <div id="selected-clip-display" class="selected-clip-display" style="display: none;">
                            <div class="selected-clip-title">Selected Clip:</div>
                            <div class="selected-clip-name"></div>
                            <div class="selected-clip-controls">
                                <div class="clip-buttons">
                                    <button class="selected-clip-play-btn"
                                        onclick="toggleClipPlayback(event)">â–¶</button>
                                    <button class="selected-clip-stop-btn" onclick="stopClipPlayback(event)">â¹</button>
                                </div>
                                <div class="clip-playback-info">
                                    <span class="selected-clip-time">0.0 / 0.0</span>
                                    <label class="clip-loop-label">
                                        <input type="checkbox" id="clip-loop-checkbox"> Loop
                                    </label>
                                </div>
                            </div>
                            <div class="selected-clip-waveform">
                                <div class="selected-clip-playhead"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tools Section -->
                <div class="right-panel-section">
                    <div class="section-header">ðŸ› ï¸ Audio Tools</div>
                    <div class="section-content">
                        <div id="tools-container" class="tools-container" style="display: none;">
                            <!-- Plugins will be generated dynamically -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variable to store current layer configuration
        window.currentLayerConfig = null;

        let selectedPlugin = null;
        let selectedClip = null;
        let draggedClip = null;
        let discoveredClips = new Set();
        let isAnalyzed = false;
        let clipPlaybackInterval = null;
        let mergedMiscClips = []; // Track ??? clips in merged view
        let revealedMiscClips = new Set(); // Once revealed, always visible
        let specOnlyMiscClips = new Set(); // MISC clips only visible in Spec view
        let clipStartTime = 0;
        let clipDuration = 0;
        let clipElapsedTime = 0; // Track elapsed time when paused
        let isClipPlaying = false;
        let currentPopup = null;

        // VU Meter animation
        let vuMeterInterval = null;
        let isMainPlaying = false;
        let vuLeftLevel = 0;
        let vuRightLevel = 0;
        let vuLeftPeak = 0;
        let vuRightPeak = 0;
        let vuLeftPeakHold = 0;
        let vuRightPeakHold = 0;

        // Zoom functionality
        let currentZoom = 1.0; // Current default is min zoom (100%)
        const minZoom = 1.0; // Current default is min (100%)
        const maxZoom = 10.0; // Can zoom in 10x from current (1000%)
        let zoomLevelTimeout = null;
        let waveformOffsetX = 0; // Track horizontal position for zooming
        let waveformCanvas = null;
        let waveformCtx = null;
        let waveformData = []; // Simulated waveform data
        let spectrogramData = []; // 2D spectrogram data [frequency][time]
        let originalClipData = new Map(); // Store original clip positions and sizes
        let zoomEnabled = false; // Track if zoom functionality is enabled

        // View mode state
        let currentViewMode = 'waveform'; // 'waveform', 'spectrogram', or 'combined'
        let viewModePreferences = {}; // Store per-file view mode preferences

        // Show popup for ??? clips
        function showClipPopup(event) {
            event.stopPropagation();

            // Remove any existing popup
            if (currentPopup) {
                currentPopup.remove();
                currentPopup = null;
            }

            // Only show popup for hidden ??? clips
            if (!event.target.classList.contains('hidden-small')) {
                return;
            }

            // Create popup
            const popup = document.createElement('div');
            popup.className = 'clip-popup';
            popup.textContent = 'Zoom into the WAV file to find and identify this clip.';

            // Position popup above the clip
            const rect = event.target.getBoundingClientRect();
            popup.style.left = `${rect.left + (rect.width / 2)}px`;
            popup.style.top = `${rect.top - 10}px`;
            popup.style.transform = 'translate(-50%, -100%) scale(0.8)';

            document.body.appendChild(popup);
            currentPopup = popup;

            // Show popup with animation
            requestAnimationFrame(() => {
                popup.classList.add('show');
                popup.style.transform = 'translate(-50%, -100%) scale(1)';
            });

            // Auto-hide after 3 seconds
            setTimeout(() => {
                if (currentPopup === popup) {
                    popup.classList.remove('show');
                    setTimeout(() => {
                        if (currentPopup === popup) {
                            popup.remove();
                            currentPopup = null;
                        }
                    }, 200);
                }
            }, 3000);
        }

        // Close popup when clicking elsewhere
        document.addEventListener('click', function (event) {
            if (currentPopup && !event.target.classList.contains('hidden-small')) {
                currentPopup.classList.remove('show');
                setTimeout(() => {
                    if (currentPopup) {
                        currentPopup.remove();
                        currentPopup = null;
                    }
                }, 200);
            }
        });

        // Generate realistic transients for different audio types
        function generateTransients(filename, length, random) {
            const transients = new Array(length).fill(0);

            const transientPatterns = {
                '1_simple_getaway_analysis.wav': [
                    { time: 0.08, type: 'car_door_slam', intensity: 0.8 },
                    { time: 0.32, type: 'car_door_slam', intensity: 0.7 },
                    { time: 0.65, type: 'engine_rev', intensity: 0.6 },
                    { time: 0.89, type: 'tire_screech', intensity: 0.9 }
                ],
                '2_simple_vocal_harmony.wav': [
                    { time: 0.15, type: 'breath_intake', intensity: 0.3 },
                    { time: 0.35, type: 'consonant_pop', intensity: 0.4 },
                    { time: 0.58, type: 'breath_intake', intensity: 0.25 },
                    { time: 0.82, type: 'mouth_click', intensity: 0.2 }
                ],
                '3_medium_morse_code.wav': [
                    { time: 0.12, type: 'radio_pop', intensity: 0.7 },
                    { time: 0.45, type: 'static_burst', intensity: 0.8 },
                    { time: 0.67, type: 'carrier_glitch', intensity: 0.5 },
                    { time: 0.85, type: 'radio_pop', intensity: 0.6 }
                ],
                '4_medium_seasonal_birds.wav': [
                    { time: 0.22, type: 'wing_flap', intensity: 0.4 },
                    { time: 0.48, type: 'branch_snap', intensity: 0.6 },
                    { time: 0.73, type: 'bird_alarm', intensity: 0.8 },
                    { time: 0.91, type: 'rustling', intensity: 0.3 }
                ],
                '5_medium_find_the_murderer.wav': [
                    { time: 0.18, type: 'footstep', intensity: 0.5 },
                    { time: 0.41, type: 'door_creak', intensity: 0.7 },
                    { time: 0.59, type: 'glass_break', intensity: 0.9 },
                    { time: 0.78, type: 'metallic_clang', intensity: 0.6 }
                ],
                '6_complex_noise_profiling.wav': [
                    { time: 0.11, type: 'power_surge', intensity: 0.8 },
                    { time: 0.33, type: 'digital_glitch', intensity: 0.6 },
                    { time: 0.56, type: 'motor_start', intensity: 0.7 },
                    { time: 0.79, type: 'electrical_pop', intensity: 0.5 }
                ],
                '7_complex_orchestra_hickups.wav': [
                    { time: 0.21, type: 'string_snap', intensity: 0.8 },
                    { time: 0.44, type: 'bow_scratch', intensity: 0.4 },
                    { time: 0.67, type: 'chair_squeak', intensity: 0.3 },
                    { time: 0.89, type: 'music_stand_bump', intensity: 0.5 }
                ]
            };

            const patterns = transientPatterns[filename] || transientPatterns['5_medium_find_the_murderer.wav'];

            patterns.forEach(transient => {
                const startSample = Math.floor(transient.time * length);
                const transientLength = getTransientLength(transient.type);

                for (let i = 0; i < transientLength && startSample + i < length; i++) {
                    const progress = i / transientLength;
                    const envelope = getTransientEnvelope(transient.type, progress);
                    const amplitude = getTransientAmplitude(transient.type, progress, random) * transient.intensity;

                    transients[startSample + i] += amplitude * envelope;
                }
            });

            return transients;
        }

        // Get transient length in samples
        function getTransientLength(type) {
            const lengths = {
                'car_door_slam': 150,
                'engine_rev': 300,
                'tire_screech': 250,
                'breath_intake': 80,
                'consonant_pop': 20,
                'mouth_click': 15,
                'radio_pop': 40,
                'static_burst': 120,
                'carrier_glitch': 60,
                'wing_flap': 35,
                'branch_snap': 25,
                'bird_alarm': 180,
                'rustling': 90,
                'footstep': 50,
                'door_creak': 200,
                'glass_break': 300,
                'metallic_clang': 180,
                'power_surge': 100,
                'digital_glitch': 80,
                'motor_start': 220,
                'electrical_pop': 30,
                'string_snap': 40,
                'bow_scratch': 70,
                'chair_squeak': 60,
                'music_stand_bump': 45
            };
            return lengths[type] || 50;
        }

        // Get transient envelope shape
        function getTransientEnvelope(type, progress) {
            const envelopes = {
                'car_door_slam': Math.exp(-progress * 8) * (1 - progress),
                'engine_rev': Math.sin(progress * Math.PI) * (1 - progress * 0.3),
                'tire_screech': Math.sin(progress * Math.PI * 0.8) * Math.exp(-progress * 2),
                'breath_intake': Math.sin(progress * Math.PI) * 0.6,
                'consonant_pop': Math.exp(-progress * 12),
                'mouth_click': Math.exp(-progress * 15),
                'radio_pop': Math.exp(-progress * 10),
                'static_burst': Math.sin(progress * Math.PI) * (1 - progress * 0.5),
                'carrier_glitch': Math.abs(Math.sin(progress * Math.PI * 4)) * (1 - progress),
                'wing_flap': Math.sin(progress * Math.PI * 2) * (1 - progress),
                'branch_snap': Math.exp(-progress * 6),
                'bird_alarm': Math.sin(progress * Math.PI) * (1 - progress * 0.2),
                'rustling': Math.sin(progress * Math.PI) * 0.7,
                'footstep': Math.exp(-progress * 5) * (1 - progress),
                'door_creak': Math.sin(progress * Math.PI) * (1 - progress * 0.3),
                'glass_break': Math.exp(-progress * 4) * (1 - progress * 0.5),
                'metallic_clang': Math.exp(-progress * 3) * Math.sin(progress * Math.PI * 2),
                'power_surge': Math.sin(progress * Math.PI) * (1 - progress * 0.4),
                'digital_glitch': Math.abs(Math.sin(progress * Math.PI * 8)) * (1 - progress),
                'motor_start': Math.sin(progress * Math.PI) * (1 - progress * 0.2),
                'electrical_pop': Math.exp(-progress * 12),
                'string_snap': Math.exp(-progress * 8) * Math.sin(progress * Math.PI * 3),
                'bow_scratch': Math.sin(progress * Math.PI) * 0.8,
                'chair_squeak': Math.sin(progress * Math.PI) * 0.6,
                'music_stand_bump': Math.exp(-progress * 6)
            };
            return envelopes[type] || Math.exp(-progress * 5);
        }

        // Get transient amplitude pattern
        function getTransientAmplitude(type, progress, random) {
            const baseAmplitude = 0.6; // Increased from 0.4 for more prominence
            const patterns = {
                'car_door_slam': baseAmplitude * (0.8 + 0.4 * Math.sin(progress * Math.PI * 20)),
                'engine_rev': baseAmplitude * (0.6 + 0.4 * Math.sin(progress * Math.PI * 15)),
                'tire_screech': baseAmplitude * (0.7 + 0.6 * Math.sin(progress * Math.PI * 50)),
                'breath_intake': baseAmplitude * 0.3,
                'consonant_pop': baseAmplitude * (0.9 + 0.2 * (random() - 0.5)),
                'mouth_click': baseAmplitude * 0.4,
                'radio_pop': baseAmplitude * (0.8 + 0.4 * (random() - 0.5)),
                'static_burst': baseAmplitude * (0.6 + 0.8 * (random() - 0.5)),
                'carrier_glitch': baseAmplitude * (0.5 + 0.5 * Math.sin(progress * Math.PI * 12)),
                'wing_flap': baseAmplitude * (0.4 + 0.3 * Math.sin(progress * Math.PI * 8)),
                'branch_snap': baseAmplitude * (0.7 + 0.3 * (random() - 0.5)),
                'bird_alarm': baseAmplitude * (0.8 + 0.4 * Math.sin(progress * Math.PI * 25)),
                'rustling': baseAmplitude * (0.3 + 0.4 * (random() - 0.5)),
                'footstep': baseAmplitude * (0.6 + 0.2 * (random() - 0.5)),
                'door_creak': baseAmplitude * (0.5 + 0.3 * Math.sin(progress * Math.PI * 6)),
                'glass_break': baseAmplitude * (0.9 + 0.2 * (random() - 0.5)),
                'metallic_clang': baseAmplitude * (0.7 + 0.5 * Math.sin(progress * Math.PI * 18)),
                'power_surge': baseAmplitude * (0.8 + 0.4 * Math.sin(progress * Math.PI * 10)),
                'digital_glitch': baseAmplitude * (0.6 + 0.6 * (random() - 0.5)),
                'motor_start': baseAmplitude * (0.7 + 0.3 * Math.sin(progress * Math.PI * 12)),
                'electrical_pop': baseAmplitude * (0.9 + 0.2 * (random() - 0.5)),
                'string_snap': baseAmplitude * (0.8 + 0.4 * Math.sin(progress * Math.PI * 30)),
                'bow_scratch': baseAmplitude * (0.5 + 0.3 * Math.sin(progress * Math.PI * 15)),
                'chair_squeak': baseAmplitude * (0.4 + 0.2 * Math.sin(progress * Math.PI * 8)),
                'music_stand_bump': baseAmplitude * (0.6 + 0.3 * (random() - 0.5))
            };
            return patterns[type] || baseAmplitude * 0.5;
        }

        // Generate realistic waveform data based on filename
        function generateWaveformData(filename, length = 10000) {
            const data = [];

            // Use filename as seed for reproducible randomness
            const seed = hashString(filename);
            let random = seededRandom(seed);

            // Get file-specific characteristics
            const fileParams = getWaveformParams(filename);

            // Generate realistic transients based on file type
            const transients = generateTransients(filename, length, random);

            for (let i = 0; i < length; i++) {
                const t = i / length;
                let amplitude = 0;

                // Dense noise base (much more realistic)
                amplitude += (random() - 0.5) * fileParams.noiseLevel;

                // Multiple frequency components with file-specific characteristics
                for (let freq = 0; freq < fileParams.freqComponents.length; freq++) {
                    const component = fileParams.freqComponents[freq];
                    const phase = component.phase + t * Math.PI * component.frequency;
                    amplitude += Math.sin(phase) * component.amplitude * (0.5 + 0.5 * Math.sin(t * Math.PI * component.modulation));
                }

                // Add file-specific patterns
                if (fileParams.spikes && random() < fileParams.spikeChance) {
                    amplitude += (random() - 0.5) * fileParams.spikeIntensity;
                }

                // Inject realistic transients
                amplitude += transients[i];

                // Envelope shaping
                const envelope = fileParams.envelope(t);
                amplitude *= envelope;

                // Clip to reasonable range
                amplitude = Math.max(-1, Math.min(1, amplitude));

                data.push(amplitude);
            }
            return data;
        }

        // Simple hash function for string
        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            return Math.abs(hash);
        }

        // Seeded random number generator
        function seededRandom(seed) {
            let state = seed;
            return function () {
                state = (state * 1664525 + 1013904223) % Math.pow(2, 32);
                return state / Math.pow(2, 32);
            };
        }

        // Generate realistic spectrogram data based on filename
        function generateSpectrogramData(filename, width = 10000, height = 256) {
            const data = [];

            // Use filename as seed for reproducible randomness
            const seed = hashString(filename);
            let random = seededRandom(seed);

            // Get file-specific spectral characteristics
            const spectralParams = getSpectralParams(filename);

            // Initialize 2D array [frequency][time]
            for (let freq = 0; freq < height; freq++) {
                data[freq] = [];
                for (let time = 0; time < width; time++) {
                    data[freq][time] = 0;
                }
            }

            // Generate frequency content
            for (let time = 0; time < width; time++) {
                const t = time / width;

                // Add base noise floor
                for (let freq = 0; freq < height; freq++) {
                    data[freq][time] = random() * spectralParams.noiseFloor;
                }

                // Add frequency components based on file characteristics
                spectralParams.frequencyBands.forEach(band => {
                    const startFreq = Math.floor((band.freqRange[0] / 20000) * height);
                    const endFreq = Math.floor((band.freqRange[1] / 20000) * height);

                    for (let freq = startFreq; freq < endFreq; freq++) {
                        const freqNorm = endFreq > startFreq ? (freq - startFreq) / (endFreq - startFreq) : 0;
                        const timeVariation = Math.sin(t * Math.PI * band.timeModulation + band.phase);
                        const freqVariation = Math.sin(freqNorm * Math.PI * band.freqModulation);

                        let intensity = band.baseIntensity;
                        intensity *= (0.5 + 0.5 * timeVariation);
                        intensity *= (0.7 + 0.3 * freqVariation);
                        intensity += (random() - 0.5) * band.randomness;

                        data[freq][time] = Math.max(data[freq][time], Math.max(0, Math.min(1, intensity)));
                    }
                });

                // Add transient events
                if (random() < spectralParams.transientChance) {
                    const centerFreq = Math.floor(random() * height);
                    const bandwidth = Math.floor(10 + random() * 30);
                    const intensity = 0.3 + random() * 0.7;

                    for (let f = Math.max(0, centerFreq - bandwidth); f < Math.min(height, centerFreq + bandwidth); f++) {
                        const distance = Math.abs(f - centerFreq);
                        const falloff = Math.max(0, 1 - distance / bandwidth);
                        data[f][time] = Math.max(data[f][time], intensity * falloff);
                    }
                }
            }

            return data;
        }

        // Get spectral parameters for different file types
        function getSpectralParams(filename) {
            const params = {
                '1_simple_getaway_analysis.wav': {
                    noiseFloor: 0.05,
                    transientChance: 0.02,
                    frequencyBands: [
                        { freqRange: [20, 200], baseIntensity: 0.4, timeModulation: 2, freqModulation: 1, phase: 0, randomness: 0.1 }, // Engine rumble
                        { freqRange: [200, 2000], baseIntensity: 0.3, timeModulation: 5, freqModulation: 3, phase: 1.2, randomness: 0.15 }, // Dialogue
                        { freqRange: [2000, 8000], baseIntensity: 0.2, timeModulation: 12, freqModulation: 8, phase: 2.1, randomness: 0.2 }, // Clarity
                        { freqRange: [8000, 20000], baseIntensity: 0.15, timeModulation: 20, freqModulation: 15, phase: 0.5, randomness: 0.25 } // Digital artifacts
                    ]
                },
                '2_simple_vocal_harmony.wav': {
                    noiseFloor: 0.02,
                    transientChance: 0.005,
                    frequencyBands: [
                        { freqRange: [80, 300], baseIntensity: 0.2, timeModulation: 1, freqModulation: 2, phase: 0, randomness: 0.05 }, // Fundamental
                        { freqRange: [300, 1500], baseIntensity: 0.6, timeModulation: 3, freqModulation: 5, phase: 0.3, randomness: 0.1 }, // Vocals
                        { freqRange: [1500, 4000], baseIntensity: 0.4, timeModulation: 8, freqModulation: 12, phase: 1.8, randomness: 0.1 }, // Harmonics
                        { freqRange: [4000, 12000], baseIntensity: 0.25, timeModulation: 15, freqModulation: 20, phase: 2.7, randomness: 0.15 } // Brightness
                    ]
                },
                '3_medium_morse_code.wav': {
                    noiseFloor: 0.08,
                    transientChance: 0.04,
                    frequencyBands: [
                        { freqRange: [600, 1000], baseIntensity: 0.8, timeModulation: 16, freqModulation: 0, phase: 0, randomness: 0.1 }, // Carrier tone
                        { freqRange: [1000, 2000], baseIntensity: 0.3, timeModulation: 16, freqModulation: 2, phase: 0.5, randomness: 0.15 }, // Harmonics
                        { freqRange: [50, 500], baseIntensity: 0.3, timeModulation: 0.5, freqModulation: 3, phase: 1.2, randomness: 0.2 }, // Static
                        { freqRange: [5000, 15000], baseIntensity: 0.2, timeModulation: 25, freqModulation: 30, phase: 2.3, randomness: 0.3 } // Radio noise
                    ]
                },
                '4_medium_seasonal_birds.wav': {
                    noiseFloor: 0.06,
                    transientChance: 0.03,
                    frequencyBands: [
                        { freqRange: [100, 800], baseIntensity: 0.3, timeModulation: 2, freqModulation: 4, phase: 0, randomness: 0.2 }, // Forest ambience
                        { freqRange: [1000, 4000], baseIntensity: 0.4, timeModulation: 8, freqModulation: 15, phase: 1.5, randomness: 0.25 }, // Mid-range calls
                        { freqRange: [4000, 12000], baseIntensity: 0.6, timeModulation: 25, freqModulation: 60, phase: 0.8, randomness: 0.3 }, // Bird chirps
                        { freqRange: [12000, 20000], baseIntensity: 0.3, timeModulation: 80, freqModulation: 80, phase: 2.9, randomness: 0.4 } // High-freq details
                    ]
                },
                '5_medium_find_the_murderer.wav': {
                    noiseFloor: 0.1,
                    transientChance: 0.025,
                    frequencyBands: [
                        { freqRange: [20, 150], baseIntensity: 0.3, timeModulation: 1.5, freqModulation: 2, phase: 0, randomness: 0.15 }, // Low rumble
                        { freqRange: [150, 800], baseIntensity: 0.4, timeModulation: 4, freqModulation: 6, phase: 1.1, randomness: 0.2 }, // Mystery tones
                        { freqRange: [800, 3000], baseIntensity: 0.5, timeModulation: 12, freqModulation: 20, phase: 2.3, randomness: 0.25 }, // Evidence sounds
                        { freqRange: [3000, 8000], baseIntensity: 0.35, timeModulation: 28, freqModulation: 45, phase: 0.7, randomness: 0.3 }, // Clarity range
                        { freqRange: [8000, 20000], baseIntensity: 0.25, timeModulation: 120, freqModulation: 120, phase: 1.9, randomness: 0.35 } // Artifacts
                    ]
                },
                '6_complex_noise_profiling.wav': {
                    noiseFloor: 0.15,
                    transientChance: 0.05,
                    frequencyBands: [
                        { freqRange: [20, 500], baseIntensity: 0.4, timeModulation: 3, freqModulation: 6, phase: 0, randomness: 0.3 }, // Low noise
                        { freqRange: [500, 2000], baseIntensity: 0.5, timeModulation: 18, freqModulation: 35, phase: 0.9, randomness: 0.35 }, // Mid noise
                        { freqRange: [2000, 8000], baseIntensity: 0.6, timeModulation: 70, freqModulation: 70, phase: 1.7, randomness: 0.4 }, // High noise
                        { freqRange: [8000, 20000], baseIntensity: 0.3, timeModulation: 150, freqModulation: 150, phase: 2.5, randomness: 0.45 } // Very high noise
                    ]
                },
                '7_complex_orchestra_hickups.wav': {
                    noiseFloor: 0.03,
                    transientChance: 0.015,
                    frequencyBands: [
                        { freqRange: [40, 200], baseIntensity: 0.4, timeModulation: 1, freqModulation: 3, phase: 0, randomness: 0.08 }, // Double bass, cello
                        { freqRange: [200, 800], baseIntensity: 0.5, timeModulation: 8, freqModulation: 20, phase: 0.6, randomness: 0.1 }, // Viola, low strings
                        { freqRange: [800, 3000], baseIntensity: 0.6, timeModulation: 20, freqModulation: 50, phase: 1.9, randomness: 0.12 }, // Violin, woodwinds
                        { freqRange: [3000, 8000], baseIntensity: 0.4, timeModulation: 50, freqModulation: 100, phase: 2.7, randomness: 0.15 }, // Brass, upper harmonics
                        { freqRange: [8000, 20000], baseIntensity: 0.2, timeModulation: 100, freqModulation: 100, phase: 1.3, randomness: 0.2 } // Shimmer, hall acoustics
                    ]
                }
            };

            return params[filename] || params['5_medium_find_the_murderer.wav']; // Default fallback
        }

        // Get waveform parameters for different file types
        function getWaveformParams(filename) {
            const params = {
                '1_simple_getaway_analysis.wav': {
                    noiseLevel: 0.4,
                    freqComponents: [
                        { frequency: 2, amplitude: 0.3, phase: 0, modulation: 1 },
                        { frequency: 15, amplitude: 0.2, phase: 1.2, modulation: 3 },
                        { frequency: 80, amplitude: 0.15, phase: 2.1, modulation: 8 },
                        { frequency: 320, amplitude: 0.1, phase: 0.5, modulation: 20 }
                    ],
                    spikes: true,
                    spikeChance: 0.03,
                    spikeIntensity: 0.6,
                    envelope: (t) => {
                        // Getaway analysis: Engine revving + dialog gaps
                        const enginePulse = 0.7 + 0.3 * Math.sin(t * Math.PI * 2.1); // Engine rhythm
                        const speechGaps = Math.max(0.1, Math.sin(t * Math.PI * 8.5) * 0.6 + 0.4); // Speech pauses
                        const carEvents = t > 0.3 && t < 0.35 ? 1.2 : 1; // Car door slam
                        return Math.min(1, enginePulse * speechGaps * carEvents);
                    }
                },
                '2_simple_vocal_harmony.wav': {
                    noiseLevel: 0.25,
                    freqComponents: [
                        { frequency: 1, amplitude: 0.4, phase: 0, modulation: 0.5 },
                        { frequency: 8, amplitude: 0.3, phase: 0.3, modulation: 2 },
                        { frequency: 25, amplitude: 0.2, phase: 1.8, modulation: 5 },
                        { frequency: 120, amplitude: 0.15, phase: 2.7, modulation: 12 },
                        { frequency: 480, amplitude: 0.08, phase: 1.1, modulation: 30 }
                    ],
                    spikes: false,
                    envelope: (t) => {
                        // Vocal harmony: Breathing + phrase structure
                        const breathing = 0.3 + 0.7 * Math.sin(t * Math.PI * 1.2); // Natural breathing
                        const phrases = Math.max(0.2, Math.sin(t * Math.PI * 3.8) * 0.6 + 0.4); // Musical phrases
                        const dynamics = 0.8 + 0.2 * Math.sin(t * Math.PI * 0.5); // Overall dynamics
                        return breathing * phrases * dynamics;
                    }
                },
                '3_medium_morse_code.wav': {
                    noiseLevel: 0.35,
                    freqComponents: [
                        { frequency: 12, amplitude: 0.5, phase: 0, modulation: 0 },
                        { frequency: 24, amplitude: 0.3, phase: 0.5, modulation: 0 },
                        { frequency: 180, amplitude: 0.2, phase: 1.2, modulation: 15 },
                        { frequency: 800, amplitude: 0.1, phase: 2.3, modulation: 40 }
                    ],
                    spikes: true,
                    spikeChance: 0.02,
                    spikeIntensity: 0.8,
                    envelope: (t) => {
                        // Morse code: Sharp on/off pulses + static bursts
                        const morsePattern = Math.abs(Math.sin(t * Math.PI * 24)) > 0.6 ? 0.9 : 0.15; // Morse pulses
                        const staticBursts = t > 0.6 && t < 0.65 ? 1.3 : 1; // Static interference
                        const carrierTone = 0.4 + 0.3 * Math.sin(t * Math.PI * 0.8); // Carrier modulation
                        return Math.min(1.2, morsePattern * staticBursts * carrierTone);
                    }
                },
                '4_medium_seasonal_birds.wav': {
                    noiseLevel: 0.45,
                    freqComponents: [
                        { frequency: 3, amplitude: 0.2, phase: 0, modulation: 4 },
                        { frequency: 18, amplitude: 0.25, phase: 1.5, modulation: 8 },
                        { frequency: 75, amplitude: 0.3, phase: 0.8, modulation: 25 },
                        { frequency: 300, amplitude: 0.2, phase: 2.9, modulation: 60 },
                        { frequency: 1200, amplitude: 0.15, phase: 1.7, modulation: 80 }
                    ],
                    spikes: true,
                    spikeChance: 0.04,
                    spikeIntensity: 0.5,
                    envelope: (t) => {
                        // Bird calls: Chirp bursts + forest ambience cycles
                        const birdChirps = Math.sin(t * Math.PI * 12) > 0.4 ? 0.8 + 0.2 * Math.sin(t * Math.PI * 40) : 0.3; // Sharp chirps
                        const forestBreeze = 0.2 + 0.3 * Math.sin(t * Math.PI * 0.6); // Wind through trees
                        const seasonalActivity = 0.6 + 0.4 * Math.sin(t * Math.PI * 2.1); // Seasonal variation
                        return birdChirps * forestBreeze * seasonalActivity;
                    }
                },
                '5_medium_find_the_murderer.wav': {
                    noiseLevel: 0.5,
                    freqComponents: [
                        { frequency: 1.5, amplitude: 0.25, phase: 0, modulation: 2 },
                        { frequency: 6, amplitude: 0.2, phase: 1.1, modulation: 4 },
                        { frequency: 20, amplitude: 0.3, phase: 2.3, modulation: 12 },
                        { frequency: 95, amplitude: 0.25, phase: 0.7, modulation: 28 },
                        { frequency: 380, amplitude: 0.2, phase: 1.9, modulation: 45 },
                        { frequency: 1500, amplitude: 0.1, phase: 2.8, modulation: 120 }
                    ],
                    spikes: true,
                    spikeChance: 0.025,
                    spikeIntensity: 0.7,
                    envelope: (t) => {
                        // Mystery/evidence: Dramatic tension + sudden reveals
                        const tension = 0.4 + 0.3 * Math.sin(t * Math.PI * 1.5); // Building tension
                        const reveals = t > 0.25 && t < 0.3 ? 1.4 : (t > 0.7 && t < 0.75 ? 1.2 : 1); // Evidence reveals
                        const whispers = Math.sin(t * Math.PI * 20) > 0.8 ? 0.6 : 1; // Quiet whisper moments
                        const atmosphericDread = 0.3 + 0.5 * Math.sin(t * Math.PI * 0.4); // Ominous undertone
                        return tension * reveals * whispers * atmosphericDread;
                    }
                },
                '6_complex_noise_profiling.wav': {
                    noiseLevel: 0.6,
                    freqComponents: [
                        { frequency: 4, amplitude: 0.15, phase: 0, modulation: 3 },
                        { frequency: 12, amplitude: 0.2, phase: 0.9, modulation: 6 },
                        { frequency: 35, amplitude: 0.25, phase: 1.7, modulation: 18 },
                        { frequency: 140, amplitude: 0.3, phase: 2.5, modulation: 35 },
                        { frequency: 560, amplitude: 0.2, phase: 0.3, modulation: 70 },
                        { frequency: 2200, amplitude: 0.15, phase: 1.4, modulation: 150 }
                    ],
                    spikes: true,
                    spikeChance: 0.05,
                    spikeIntensity: 0.4,
                    envelope: (t) => {
                        // Complex noise: Variable interference patterns
                        const electricalSurges = 0.5 + 0.4 * Math.sin(t * Math.PI * 4.2); // Power fluctuations
                        const digitalGlitches = Math.sin(t * Math.PI * 15) > 0.7 ? 0.3 : 1; // Digital dropouts
                        const mechanicalNoise = 0.6 + 0.3 * Math.sin(t * Math.PI * 8.7); // Mechanical interference
                        const testToneEvents = t > 0.1 && t < 0.15 ? 1.5 : (t > 0.8 && t < 0.85 ? 1.3 : 1); // Calibration tones
                        return electricalSurges * digitalGlitches * mechanicalNoise * testToneEvents;
                    }
                },
                '7_complex_orchestra_hickups.wav': {
                    noiseLevel: 0.3,
                    freqComponents: [
                        { frequency: 0.8, amplitude: 0.35, phase: 0, modulation: 1 },
                        { frequency: 4, amplitude: 0.3, phase: 0.6, modulation: 3 },
                        { frequency: 16, amplitude: 0.25, phase: 1.9, modulation: 8 },
                        { frequency: 64, amplitude: 0.2, phase: 2.7, modulation: 20 },
                        { frequency: 256, amplitude: 0.15, phase: 1.3, modulation: 50 },
                        { frequency: 1024, amplitude: 0.1, phase: 0.1, modulation: 100 }
                    ],
                    spikes: true,
                    spikeChance: 0.015,
                    spikeIntensity: 0.8,
                    envelope: (t) => {
                        // Orchestra with hiccups: Musical phrases with sudden mistakes
                        const musicalPhrase = 0.7 + 0.2 * Math.sin(t * Math.PI * 1.1); // Natural musical flow
                        const orchestralBuilds = 0.5 + 0.5 * Math.sin(t * Math.PI * 0.3); // Dynamic swells
                        const hiccups = (t > 0.2 && t < 0.22) || (t > 0.55 && t < 0.57) ? 0.1 : 1; // Performance mistakes
                        const recoveries = (t > 0.22 && t < 0.25) || (t > 0.57 && t < 0.6) ? 1.3 : 1; // Post-mistake emphasis
                        return Math.min(1.2, musicalPhrase * orchestralBuilds * hiccups * recoveries);
                    }
                }
            };

            return params[filename] || params['5_medium_find_the_murderer.wav']; // Default fallback
        }

        // Map intensity value to RGB color (traditional spectrogram colors)
        function intensityToColor(intensity) {
            // Clamp intensity to 0-1 range
            intensity = Math.max(0, Math.min(1, intensity));

            // Traditional spectrogram color mapping: Black -> Blue -> Green -> Yellow -> Red -> White
            if (intensity < 0.2) {
                // Black to Blue
                const t = intensity / 0.2;
                return [0, 0, Math.floor(t * 128)];
            } else if (intensity < 0.4) {
                // Blue to Green
                const t = (intensity - 0.2) / 0.2;
                return [0, Math.floor(t * 255), 128 - Math.floor(t * 128)];
            } else if (intensity < 0.6) {
                // Green to Yellow
                const t = (intensity - 0.4) / 0.2;
                return [Math.floor(t * 255), 255, 0];
            } else if (intensity < 0.8) {
                // Yellow to Red
                const t = (intensity - 0.6) / 0.2;
                return [255, 255 - Math.floor(t * 255), 0];
            } else {
                // Red to White
                const t = (intensity - 0.8) / 0.2;
                return [255, Math.floor(t * 255), Math.floor(t * 255)];
            }
        }

        // Draw visualization based on current mode
        function drawVisualization() {
            if (!waveformCanvas || !waveformCtx) return;

            const width = waveformCanvas.width;
            const height = waveformCanvas.height;

            // Clear canvas
            waveformCtx.clearRect(0, 0, width, height);

            if (currentViewMode === 'waveform') {
                drawWaveformMode(width, height);
            } else if (currentViewMode === 'spectrogram') {
                drawSpectrogramMode(width, height);
            } else if (currentViewMode === 'combined') {
                drawCombinedMode(width, height);
            }
        }

        // Draw waveform mode
        function drawWaveformMode(width, height) {
            const centerY = height / 2;

            // Calculate visible range: fewer samples = more zoom (matches spectrogram logic)
            const waveformWidth = waveformData.length; // 10,000 samples
            const visibleSamples = waveformWidth / currentZoom;
            const maxStartSample = Math.max(0, waveformWidth - visibleSamples);
            const startSample = Math.floor(waveformOffsetX * maxStartSample);
            const endSample = Math.min(waveformWidth, startSample + visibleSamples);

            // Set waveform style
            waveformCtx.strokeStyle = getCurrentWaveformColor();
            waveformCtx.lineWidth = 2; // Increased from 1 for better visibility
            waveformCtx.beginPath();

            for (let x = 0; x < width; x++) {
                // Map canvas X to waveform position within visible range
                const timeProgress = x / width;
                const sampleIndex = Math.floor(startSample + timeProgress * (endSample - startSample));

                if (sampleIndex >= 0 && sampleIndex < waveformWidth) {
                    const amplitude = waveformData[sampleIndex];
                    const y = centerY + amplitude * (centerY - 5); // Leave 5px margin top/bottom

                    if (x === 0) {
                        waveformCtx.moveTo(x, y);
                    } else {
                        waveformCtx.lineTo(x, y);
                    }
                }
            }

            waveformCtx.stroke();

            // Draw subtle alignment markers at key percentages (only in waveform mode)
            if (currentViewMode === 'waveform') {
                waveformCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                waveformCtx.lineWidth = 1;

                // 15% mark (where first clip often starts)
                const mark15 = width * 0.15;
                waveformCtx.beginPath();
                waveformCtx.moveTo(mark15, 0);
                waveformCtx.lineTo(mark15, height);
                waveformCtx.stroke();

                // 50% mark (center reference)
                const mark50 = width * 0.5;
                waveformCtx.beginPath();
                waveformCtx.moveTo(mark50, 0);
                waveformCtx.lineTo(mark50, height);
                waveformCtx.stroke();
            }
        }

        // Draw spectrogram mode
        function drawSpectrogramMode(width, height) {
            if (spectrogramData.length === 0) return;

            // Create ImageData for pixel manipulation
            const imageData = waveformCtx.createImageData(width, height);
            const data = imageData.data;

            // Calculate which portion of spectrogram to show based on zoom
            const spectrogramWidth = spectrogramData[0].length; // 10,000 samples
            const spectrogramHeight = spectrogramData.length;   // 256 frequency bins

            // Calculate visible range: fewer samples = more zoom
            const visibleSamples = spectrogramWidth / currentZoom;
            const maxStartSample = Math.max(0, spectrogramWidth - visibleSamples);
            const startSample = Math.floor(waveformOffsetX * maxStartSample);
            const endSample = Math.min(spectrogramWidth, startSample + visibleSamples);

            // Render each pixel
            for (let x = 0; x < width; x++) {
                // Map canvas X to spectrogram time position within visible range
                const timeProgress = x / width;
                const spectrogramX = Math.floor(startSample + timeProgress * (endSample - startSample));

                if (spectrogramX >= 0 && spectrogramX < spectrogramWidth) {
                    for (let y = 0; y < height; y++) {
                        // Map canvas Y to spectrogram frequency (flip Y axis)
                        const spectrogramY = Math.floor(((height - 1 - y) / height) * spectrogramHeight);

                        if (spectrogramY >= 0 && spectrogramY < spectrogramHeight) {
                            const intensity = spectrogramData[spectrogramY][spectrogramX];
                            const [r, g, b] = intensityToColor(intensity);

                            const pixelIndex = (y * width + x) * 4;
                            data[pixelIndex] = r;     // Red
                            data[pixelIndex + 1] = g; // Green
                            data[pixelIndex + 2] = b; // Blue
                            data[pixelIndex + 3] = 255; // Alpha
                        }
                    }
                }
            }

            // Draw the image data to canvas
            waveformCtx.putImageData(imageData, 0, 0);

            // Draw subtle alignment markers at key percentages (for spectrogram mode too)
            waveformCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            waveformCtx.lineWidth = 1;

            // 15% mark (where first clip often starts)
            const mark15 = width * 0.15;
            waveformCtx.beginPath();
            waveformCtx.moveTo(mark15, 0);
            waveformCtx.lineTo(mark15, height);
            waveformCtx.stroke();

            // 50% mark (center reference)
            const mark50 = width * 0.5;
            waveformCtx.beginPath();
            waveformCtx.moveTo(mark50, 0);
            waveformCtx.lineTo(mark50, height);
            waveformCtx.stroke();
        }

        // Draw combined mode (spectrogram on bottom, waveform overlay on top)
        function drawCombinedMode(width, height) {
            // First draw the spectrogram as background
            if (spectrogramData.length > 0) {
                const imageData = waveformCtx.createImageData(width, height);
                const data = imageData.data;

                const spectrogramWidth = spectrogramData[0].length;
                const spectrogramHeight = spectrogramData.length;

                // Calculate visible range
                const visibleSamples = spectrogramWidth / currentZoom;
                const maxStartSample = Math.max(0, spectrogramWidth - visibleSamples);
                const startSample = Math.floor(waveformOffsetX * maxStartSample);
                const endSample = Math.min(spectrogramWidth, startSample + visibleSamples);

                // Render spectrogram pixels
                for (let x = 0; x < width; x++) {
                    const timeProgress = x / width;
                    const spectrogramX = Math.floor(startSample + timeProgress * (endSample - startSample));

                    if (spectrogramX >= 0 && spectrogramX < spectrogramWidth) {
                        for (let y = 0; y < height; y++) {
                            const spectrogramY = Math.floor(((height - 1 - y) / height) * spectrogramHeight);

                            if (spectrogramY >= 0 && spectrogramY < spectrogramHeight) {
                                const intensity = spectrogramData[spectrogramY][spectrogramX];
                                const [r, g, b] = intensityToColor(intensity);

                                const pixelIndex = (y * width + x) * 4;
                                // Dim the spectrogram colors slightly for background
                                data[pixelIndex] = Math.floor(r * 0.7);
                                data[pixelIndex + 1] = Math.floor(g * 0.7);
                                data[pixelIndex + 2] = Math.floor(b * 0.7);
                                data[pixelIndex + 3] = 255;
                            }
                        }
                    }
                }

                waveformCtx.putImageData(imageData, 0, 0);
            }

            // Then draw waveform overlay in center third of canvas
            const centerY = height / 2;
            const waveformHeight = height * 0.4; // Use 40% of height for waveform

            const waveformWidth = waveformData.length;
            const visibleSamples = waveformWidth / currentZoom;
            const maxStartSample = Math.max(0, waveformWidth - visibleSamples);
            const startSample = Math.floor(waveformOffsetX * maxStartSample);
            const endSample = Math.min(waveformWidth, startSample + visibleSamples);

            // Set waveform style with higher opacity for visibility over spectrogram
            waveformCtx.strokeStyle = getCurrentWaveformColor();
            waveformCtx.lineWidth = 3; // Thicker line for better visibility
            waveformCtx.beginPath();

            for (let x = 0; x < width; x++) {
                const timeProgress = x / width;
                const sampleIndex = Math.floor(startSample + timeProgress * (endSample - startSample));

                if (sampleIndex >= 0 && sampleIndex < waveformWidth) {
                    const amplitude = waveformData[sampleIndex];
                    const y = centerY + amplitude * (waveformHeight / 2);

                    if (x === 0) {
                        waveformCtx.moveTo(x, y);
                    } else {
                        waveformCtx.lineTo(x, y);
                    }
                }
            }

            waveformCtx.stroke();

            // Draw alignment markers
            waveformCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            waveformCtx.lineWidth = 1;

            const mark15 = width * 0.15;
            waveformCtx.beginPath();
            waveformCtx.moveTo(mark15, 0);
            waveformCtx.lineTo(mark15, height);
            waveformCtx.stroke();

            const mark50 = width * 0.5;
            waveformCtx.beginPath();
            waveformCtx.moveTo(mark50, 0);
            waveformCtx.lineTo(mark50, height);
            waveformCtx.stroke();
        }

        // Get current waveform color based on loaded file
        function getCurrentWaveformColor() {
            // Colors matching the main gradient themes
            const colors = {
                '1_simple_getaway_analysis.wav': '#e74c3c',
                '2_simple_vocal_harmony.wav': '#e67e22',
                '3_medium_morse_code.wav': '#3498db',
                '4_medium_seasonal_birds.wav': '#27ae60',
                '5_medium_find_the_murderer.wav': '#9b59b6',
                '6_complex_noise_profiling.wav': '#f39c12',
                '7_complex_orchestra_hickups.wav': '#e74c3c'
            };

            const currentFile = document.querySelector('#merged .track-info span:first-child')?.textContent;
            return colors[currentFile] || '#9b59b6';
        }

        // Zoom functionality
        function updateZoom(targetX = null) {
            // Adjust offset position to keep target point in view
            if (targetX !== null && waveformCanvas) {
                const containerWidth = waveformCanvas.width;
                const targetPercent = targetX / containerWidth;

                // Calculate new offset to keep target centered
                const maxOffset = 1 - (1 / currentZoom);
                waveformOffsetX = targetPercent * maxOffset;
                waveformOffsetX = Math.max(0, Math.min(maxOffset, waveformOffsetX));
            }

            // Redraw visualization and update clip positions in the same frame
            requestAnimationFrame(() => {
                drawVisualization();
                updateClipPositions();
            });

            // Update zoom level display
            const zoomDisplay = document.getElementById('zoom-level-display');
            if (zoomDisplay) {
                const percentage = Math.round(100 * currentZoom);
                zoomDisplay.textContent = `${percentage}%`;
                zoomDisplay.classList.add('show');

                // Hide after 2 seconds
                clearTimeout(zoomLevelTimeout);
                zoomLevelTimeout = setTimeout(() => {
                    zoomDisplay.classList.remove('show');
                }, 2000);
            }

            // Update button states
            updateZoomButtons();
        }

        function updateZoomButtons() {
            const zoomInBtn = document.querySelector('.zoom-btn[onclick*="zoomIn"]');
            const zoomOutBtn = document.querySelector('.zoom-btn[onclick*="zoomOut"]');

            if (zoomInBtn) {
                zoomInBtn.classList.toggle('disabled', !zoomEnabled || currentZoom >= maxZoom);
            }
            if (zoomOutBtn) {
                zoomOutBtn.classList.toggle('disabled', !zoomEnabled || currentZoom <= minZoom);
            }

            // Also update pan buttons
            updatePanButtons();
        }

        // Enable zoom functionality and show controls
        function enableZoomControls() {
            zoomEnabled = true;

            // Show zoom controls
            const zoomControls = document.querySelector('.zoom-controls');
            const zoomDisplay = document.getElementById('zoom-level-display');
            const panControls = document.querySelector('.pan-controls');

            if (zoomControls) {
                zoomControls.classList.add('enabled');
            }
            if (zoomDisplay) {
                zoomDisplay.classList.add('enabled');
            }
            if (panControls) {
                panControls.classList.add('enabled');
            }

            // Update button states
            updateZoomButtons();
        }

        function zoomIn(event) {
            event.stopPropagation();
            if (!zoomEnabled || currentZoom >= maxZoom) return;

            currentZoom = Math.min(maxZoom, currentZoom * 1.25);
            // Zoom to center for button clicks
            const container = document.querySelector('#merged .track-content');
            const centerX = container ? container.offsetWidth / 2 : 0;
            updateZoom(centerX);
        }

        function zoomOut(event) {
            event.stopPropagation();
            if (!zoomEnabled || currentZoom <= minZoom) return;

            currentZoom = Math.max(minZoom, currentZoom / 1.25);
            // Zoom to center for button clicks
            const container = document.querySelector('#merged .track-content');
            const centerX = container ? container.offsetWidth / 2 : 0;
            updateZoom(centerX);
        }

        // Pan functionality
        function panLeft(event) {
            event.stopPropagation();
            if (!zoomEnabled || currentZoom <= minZoom) return;

            const panAmount = 0.1 / currentZoom; // Smaller steps when more zoomed in
            const maxOffset = 1 - (1 / currentZoom);
            waveformOffsetX = Math.max(0, waveformOffsetX - panAmount);

            updateVisualizationAndClips();
            updatePanButtons();
        }

        function panRight(event) {
            event.stopPropagation();
            if (!zoomEnabled || currentZoom <= minZoom) return;

            const panAmount = 0.1 / currentZoom; // Smaller steps when more zoomed in
            const maxOffset = 1 - (1 / currentZoom);
            waveformOffsetX = Math.min(maxOffset, waveformOffsetX + panAmount);

            updateVisualizationAndClips();
            updatePanButtons();
        }

        function updateVisualizationAndClips() {
            // Use requestAnimationFrame to ensure both updates happen in the same frame
            requestAnimationFrame(() => {
                drawVisualization();
                updateClipPositions();
            });
        }

        function updatePanButtons() {
            const panLeftBtn = document.querySelector('.pan-btn[onclick*="panLeft"]');
            const panRightBtn = document.querySelector('.pan-btn[onclick*="panRight"]');
            const maxOffset = 1 - (1 / currentZoom);

            if (panLeftBtn) {
                panLeftBtn.classList.toggle('disabled', !zoomEnabled || currentZoom <= minZoom || waveformOffsetX <= 0);
            }
            if (panRightBtn) {
                panRightBtn.classList.toggle('disabled', !zoomEnabled || currentZoom <= minZoom || waveformOffsetX >= maxOffset);
            }
        }

        // Store original clip positions and sizes for zoom calculations
        function storeOriginalClipData() {
            originalClipData.clear();

            // Store data for all visible clips in merged view (including MISC clips)
            const mergedClips = document.querySelectorAll('#merged .audio-clip');
            mergedClips.forEach(clip => {
                const left = parseFloat(clip.style.left.replace('%', ''));
                const width = parseFloat(clip.style.width.replace('%', ''));
                const clipId = clip.dataset.clip;

                originalClipData.set(clipId, {
                    left: left,
                    width: width,
                    element: clip
                });
            });

            // Store data for MISC clips (including hidden ones)
            mergedMiscClips.forEach(miscClip => {
                const left = parseFloat(miscClip.originalLeft.replace('%', ''));
                const width = parseFloat(miscClip.originalWidth.replace('%', ''));

                originalClipData.set(miscClip.clipId, {
                    left: left,
                    width: width,
                    element: miscClip.element
                });
            });
        }

        // Switch between waveform and spectrogram view modes
        function switchViewMode(mode) {
            if (mode === currentViewMode) return;

            currentViewMode = mode;

            // Update button states
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });

            // Store preference for current file
            const currentFile = document.querySelector('#merged .track-info span:first-child')?.textContent;
            if (currentFile) {
                viewModePreferences[currentFile] = mode;
            }

            // Update MISC clip visibility for view mode change
            updateMiscClipVisibility();

            // Synchronize visualization and clip updates for view mode switch
            requestAnimationFrame(() => {
                drawVisualization();
                updateClipPositions();
            });
        }

        // Update clip positions and sizes based on current zoom level
        function updateClipPositions() {
            if (originalClipData.size === 0) return;

            const mergedTrack = document.querySelector('#merged .track-content');
            if (!mergedTrack) return;

            // Calculate visible range in original coordinates (0-100%)
            const visibleStart = waveformOffsetX * 100;
            const visibleEnd = visibleStart + (100 / currentZoom);

            originalClipData.forEach((originalData, clipId) => {
                const clip = originalData.element;
                if (!clip) return;

                // Check if this is a MISC clip
                const isMiscClip = clip.classList.contains('misc-clip-hidden');

                // Calculate original clip boundaries
                const originalLeft = originalData.left;
                const originalRight = originalData.left + originalData.width;

                // Check if clip is visible in current zoom view
                const isInViewport = !(originalRight < visibleStart || originalLeft > visibleEnd);

                if (!isInViewport) {
                    // Clip is completely outside visible area - hide all clips regardless of type
                    clip.style.display = 'none';
                    return;
                }

                // Clip is at least partially visible in viewport
                if (isMiscClip) {
                    // For MISC clips, only show if already revealed
                    if (revealedMiscClips.has(clipId)) {
                        clip.style.display = 'flex';
                    } else {
                        clip.style.display = 'none';
                    }
                } else {
                    // Regular clips show normally when in viewport
                    clip.style.display = 'flex';
                }

                // Calculate new position and size
                // Convert from original coordinates to zoomed coordinates
                const newLeft = ((originalLeft - visibleStart) / (100 / currentZoom)) * 100;
                const newWidth = (originalData.width / (100 / currentZoom)) * 100;

                // Clamp to visible boundaries
                const clampedLeft = Math.max(0, newLeft);
                const clampedRight = Math.min(100, newLeft + newWidth);
                const clampedWidth = clampedRight - clampedLeft;

                // Apply new position and size
                clip.style.left = `${clampedLeft}%`;
                clip.style.width = `${clampedWidth}%`;

                // Fade out clips that are partially visible at edges
                if (clampedLeft <= 1 || clampedRight >= 99) {
                    clip.style.opacity = '0.6';
                } else {
                    clip.style.opacity = '';
                }
            });

            // Update MISC clip visibility
            updateMiscClipVisibility();
        }

        // Initialize waveform canvas
        function initializeWaveformCanvas() {
            const mergedTrack = document.querySelector('#merged .track-content');
            if (!mergedTrack) return;

            // Create canvas element
            waveformCanvas = document.createElement('canvas');
            waveformCanvas.className = 'waveform-canvas';
            mergedTrack.appendChild(waveformCanvas);

            // Get 2D context
            waveformCtx = waveformCanvas.getContext('2d');

            // Set canvas size to match container exactly
            function resizeCanvas() {
                const rect = mergedTrack.getBoundingClientRect();
                waveformCanvas.width = rect.width;
                waveformCanvas.height = rect.height;
                drawVisualization();
            }

            // Initial resize and setup
            resizeCanvas();

            // Handle window resize
            window.addEventListener('resize', resizeCanvas);

            // Canvas is now the primary waveform display

            // Generate waveform data based on current file
            const currentFile = document.querySelector('#merged .track-info span:first-child')?.textContent || '5_medium_find_the_murderer.wav';
            waveformData = generateWaveformData(currentFile, 10000);
            spectrogramData = generateSpectrogramData(currentFile);
            drawVisualization();
        }

        // Mouse wheel zoom functionality
        function initializeZoomControls() {
            const mergedTrack = document.querySelector('#merged .track-content');
            if (mergedTrack) {
                mergedTrack.addEventListener('wheel', function (event) {
                    // Only prevent default and zoom if zoom is enabled
                    if (!zoomEnabled) return;

                    event.preventDefault();

                    // Get mouse X position relative to the container
                    const rect = mergedTrack.getBoundingClientRect();
                    const mouseX = event.clientX - rect.left;

                    if (event.deltaY < 0) {
                        // Scroll up = zoom in
                        if (currentZoom >= maxZoom) return;
                        currentZoom = Math.min(maxZoom, currentZoom * 1.25);
                        updateZoom(mouseX);
                    } else {
                        // Scroll down = zoom out
                        if (currentZoom <= minZoom) return;
                        currentZoom = Math.max(minZoom, currentZoom / 1.25);
                        updateZoom(mouseX);
                    }
                });

                // Add box drawing for MISC clip identification
                mergedTrack.addEventListener('mousedown', startMiscClipIdentification);
                mergedTrack.addEventListener('mousemove', updateMiscClipIdentification);
                mergedTrack.addEventListener('mouseup', endMiscClipIdentification);
            }

            // Initialize button states
            updateZoomButtons();

            // Add keyboard event listeners for arrow key panning
            document.addEventListener('keydown', handleKeyboardPanning);

            // Add middle mouse drag for panning
            if (mergedTrack) {
                mergedTrack.addEventListener('mousedown', handleMiddleMouseDown);
                document.addEventListener('mousemove', handleMiddleMouseMove);
                document.addEventListener('mouseup', handleMiddleMouseUp);
            }
        }

        // Variables for middle mouse dragging
        let isDragging = false;
        let dragStartX = 0;
        let dragStartOffset = 0;

        // Keyboard panning with arrow keys
        function handleKeyboardPanning(event) {
            if (!zoomEnabled || currentZoom <= minZoom) return;

            if (event.key === 'ArrowLeft') {
                event.preventDefault();
                panLeft(event);
            } else if (event.key === 'ArrowRight') {
                event.preventDefault();
                panRight(event);
            }
        }

        // Middle mouse button drag for panning
        function handleMiddleMouseDown(event) {
            if (event.button === 1) { // Middle mouse button
                event.preventDefault();
                if (!zoomEnabled || currentZoom <= minZoom) return;

                isDragging = true;
                dragStartX = event.clientX;
                dragStartOffset = waveformOffsetX;

                // Change cursor to indicate dragging
                document.body.style.cursor = 'grabbing';
            }
        }

        function handleMiddleMouseMove(event) {
            if (!isDragging) return;

            event.preventDefault();
            const deltaX = event.clientX - dragStartX;
            const container = document.querySelector('#merged .track-content');
            if (!container) return;

            // Convert pixel movement to offset percentage
            const containerWidth = container.offsetWidth;
            const offsetDelta = -(deltaX / containerWidth) * (1 / currentZoom);

            const maxOffset = 1 - (1 / currentZoom);
            waveformOffsetX = Math.max(0, Math.min(maxOffset, dragStartOffset + offsetDelta));

            // Synchronize visualization and clip updates for smooth dragging
            requestAnimationFrame(() => {
                drawVisualization();
                updateClipPositions();
                updatePanButtons();
            });
        }

        function handleMiddleMouseUp(event) {
            if (event.button === 1) { // Middle mouse button
                isDragging = false;
                document.body.style.cursor = '';
            }
        }

        // Check if a MISC clip should be visible based on zoom and viewport
        function shouldMiscClipBeVisible(miscClip) {
            const clipWidth = parseFloat(miscClip.originalWidth.replace('%', ''));
            const clipLeft = parseFloat(miscClip.originalLeft.replace('%', ''));
            const clipId = miscClip.clipId;

            // Check if this is a spec-only clip and we're in waveform view
            if (specOnlyMiscClips.has(clipId) && currentViewMode === 'waveform') {
                return false;
            }

            // Check size threshold: 25% of view OR max zoom
            const sizeThresholdMet = (clipWidth * currentZoom >= 25) || (currentZoom >= maxZoom);
            if (!sizeThresholdMet) return false;

            // Check if in viewport
            const visibleStart = waveformOffsetX * 100;
            const visibleEnd = visibleStart + (100 / currentZoom);
            const clipEnd = clipLeft + clipWidth;

            const inViewport = (clipEnd > visibleStart) && (clipLeft < visibleEnd);

            return inViewport;
        }

        // Update MISC clip visibility based on current zoom and scroll
        function updateMiscClipVisibility() {
            if (mergedMiscClips.length === 0) return;

            mergedMiscClips.forEach(miscClip => {
                const clipId = miscClip.clipId;

                // Check if should be revealed now (but don't show yet - let updateClipPositions handle viewport)
                if (!revealedMiscClips.has(clipId) && shouldMiscClipBeVisible(miscClip)) {
                    revealMiscClip(miscClip);
                }
            });
        }

        // Reveal a MISC clip with animation
        function revealMiscClip(miscClip) {
            const element = miscClip.element;
            const clipId = miscClip.clipId;

            // Mark as revealed (permanent)
            revealedMiscClips.add(clipId);

            // Note: Don't set display here - let updateClipPositions handle viewport visibility
            // But only animate if the element will be visible
            const originalLeft = parseFloat(miscClip.originalLeft);
            const originalRight = originalLeft + parseFloat(miscClip.originalWidth);
            const visibleStart = waveformOffsetX * 100;
            const visibleEnd = visibleStart + (100 / currentZoom);
            const isInViewport = !(originalRight < visibleStart || originalLeft > visibleEnd);

            if (isInViewport) {
                // Show the element for animation
                element.style.display = 'flex';

                // Start animation from small scale and transparent
                element.style.transform = 'scale(0.5)';
                element.style.opacity = '0';
                element.style.transition = 'all 0.5s ease-out';
                element.style.zIndex = '50'; // Above regular clips

                // Animate to full size and opacity
                requestAnimationFrame(() => {
                    element.style.transform = 'scale(1.0)';
                    element.style.opacity = '1';

                    // Clean up transition after animation
                    setTimeout(() => {
                        element.style.transition = '';
                    }, 500);
                });
            }
        }

        // Plugin configuration
        const PLUGIN_CONFIG = [
            { id: 'mute', icon: 'ðŸ”‡', name: 'Mute', type: 'toggle', description: 'Toggle clip muting' },
            { id: 'noise', icon: 'ðŸŒ«', name: 'Noise Reduction', type: 'toggle', description: 'Remove noise/reverb/echo' },
            { id: 'voice', icon: 'ðŸŽ¤', name: 'Voice Boost', type: 'toggle', description: 'Enhance voice clarity' },
            { id: 'reverse', icon: 'â†”', name: 'Reverse', type: 'toggle', description: 'Reverse audio playback' },
            { id: 'stereo', icon: 'ðŸŽ§', name: 'Stereo/Mono', type: 'toggle', description: 'Toggle stereo/mono mode' },
            { id: 'volume', icon: 'ðŸ”Š', name: 'Volume', type: 'slider', description: 'Adjust volume levels', range: ['Mute', 'Max'] },
            { id: 'pitch', icon: 'ðŸŽµ', name: 'Pitch', type: 'slider', description: 'Modify pitch', range: ['Lower', 'Higher'] },
            { id: 'speed', icon: 'âš¡', name: 'Speed', type: 'slider', description: 'Adjust playback speed', range: ['Faster', 'Slower'] },
            { id: 'highpass', icon: 'ðŸ“ˆ', name: 'High Pass', type: 'slider', description: 'High frequency cut-off', range: ['Low', 'High'] },
            { id: 'lowpass', icon: 'ðŸ“‰', name: 'Low Pass', type: 'slider', description: 'Low frequency cut-off', range: ['Low', 'High'] },
            { id: 'bitrate', icon: 'ðŸ’¾', name: 'Bit Rate', type: 'slider', description: 'Adjust audio quality', range: ['Low', 'High'] }
        ];

        // Add data structure to track effects per clip
        const clipEffects = new Map(); // Maps clip ID to Set of active effects

        // Task hints for each level
        const TASK_HINTS = {
            '1_simple_getaway_analysis.wav': 'Silence unwanted elements to reveal hidden evidence',
            '2_simple_vocal_harmony.wav': 'Balance vocal levels and clean up the recording',
            '3_medium_morse_code.wav': 'Enhance signal clarity to decode the morse message',
            '4_medium_seasonal_birds.wav': 'Isolate the target bird call from background noise',
            '5_medium_find_the_murderer.wav': 'Process evidence using advanced time manipulation',
            '6_complex_noise_profiling.wav': 'Apply technical precision to separate signal types',
            '7_complex_orchestra_hickups.wav': 'Remove all performance mistakes and disruptions'
        };

        // Get clip color by layer ID
        function getClipColorByLayer(layerId) {
            const layerColors = {
                // find_the_murderer.wav layers
                'evidence-recording': '#e74c3c',
                'ghost-voices': '#8e44ad',
                'investigation': '#27ae60',
                'ambient-static-wave': '#34495e',
                // morse_code.wav layers
                'morse-signals': '#3498db',
                'radio-static': '#95a5a6',
                // noise_profiling.wav layers
                'vocal-track': '#e74c3c',
                'background-noise': '#f39c12',
                'electrical-interference': '#1abc9c',
                'mechanical-sounds': '#e67e22',
                'digital-artifacts': '#9b59b6',
                'frequency-sweeps': '#27ae60',
                'calibration-tones': '#34495e',
                // orchestra_hickups.wav layers
                'violin-section': '#e74c3c',
                'brass-section': '#f39c12',
                'woodwind-section': '#27ae60',
                'percussion-section': '#9b59b6',
                // vocal_harmony.wav layers
                'vocal-harmony': '#e67e22',
                // getaway_analysis.wav layers
                'digital-corruption': '#e74c3c',
                'engine-signature': '#3498db',
                // seasonal_birds.wav layers
                'target-bird-call': '#27ae60',
                'forest-ambience': '#2c3e50',
                'viola-breathing': '#8e44ad',
                'unknown-presence': '#e74c3c'
            };
            return layerColors[layerId] || '#95a5a6'; // Default gray if not found
        }

        // Plugin factory functions
        function createTogglePlugin(plugin) {
            return `
                <div class="plugin-section disabled" onclick="selectPlugin('${plugin.id}')">
                    <div class="plugin-title">${plugin.icon} ${plugin.name}</div>
                    <div style="font-size: 11px; color: var(--text-muted);">${plugin.description}</div>
                    <div class="checkbox"></div>
                </div>
            `;
        }

        function createSliderPlugin(plugin) {
            return `
                <div class="plugin-section disabled">
                    <div class="plugin-title">${plugin.icon} ${plugin.name}</div>
                    <div class="slider-container">
                        <div class="slider-labels">
                            <span>${plugin.range[0]}</span>
                            <span>${plugin.range[1]}</span>
                        </div>
                        <div class="slider-track">
                            <div class="slider-center-mark"></div>
                            <div class="slider-fill"></div>
                            <div class="slider-thumb"></div>
                        </div>
                    </div>
                    <div style="font-size: 11px; color: var(--text-muted);">${plugin.description}</div>
                </div>
            `;
        }

        function generatePluginsHTML(availableTools = []) {
            // Filter plugins to only show available tools for current level
            const filteredPlugins = PLUGIN_CONFIG.filter(plugin =>
                availableTools.length === 0 || availableTools.includes(plugin.id)
            );

            return filteredPlugins.map(plugin =>
                plugin.type === 'slider' ? createSliderPlugin(plugin) : createTogglePlugin(plugin)
            ).join('');
        }

        // Playback state
        let isPlaying = false;
        let currentTime = 0;
        let totalDuration = 47; // Total duration in seconds
        let playbackInterval;
        let playbackSpeed = 1; // Normal speed
        let mainLoopEnabled = false; // Main playback loop state
        let clipLoopEnabled = false; // Clip playback loop state

        // Format time as MM:SS.m
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            const milliseconds = Math.floor((seconds % 1) * 10);
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}.${milliseconds}`;
        }

        // Format time for clips as seconds with 1 decimal place
        function formatClipTime(seconds) {
            return seconds.toFixed(1);
        }

        // Update time display
        function updateTimeDisplay() {
            const timeDisplay = document.querySelector('.time-display');
            timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(totalDuration)}`;
        }

        // Update playback marker position
        function updatePlaybackMarker() {
            const marker = document.getElementById('playback-marker');
            const positionFill = document.getElementById('main-position-fill');
            const percentage = (currentTime / totalDuration) * 100;

            if (marker) {
                marker.style.left = `${percentage}%`;
            }
            if (positionFill) {
                positionFill.style.width = `${percentage}%`;
            }
        }

        function seekToPosition(event) {
            event.stopPropagation();
            const positionBar = event.currentTarget;
            const rect = positionBar.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const percentage = clickX / rect.width;

            currentTime = percentage * totalDuration;
            updateTimeDisplay();
            updatePlaybackMarker();
        }

        // Clip waveform generation
        function generateClipWaveform(clipId) {
            // Create a unique seed based on clip ID for consistent waveforms
            const seed = clipId.split('').reduce((a, b) => a + b.charCodeAt(0), 0);
            const seededRandom = (x) => ((Math.sin(x * seed * 9999) % 1) + 1) / 2;

            // Generate waveform points (using percentages for CSS)
            const points = [];
            const numPoints = 50; // Number of waveform segments

            for (let i = 0; i < numPoints; i++) {
                const x = (i / (numPoints - 1)) * 100; // X position as percentage
                const baseY = 30 + seededRandom(i * 0.3) * 40; // Y height as percentage (30-70%)

                // Add some variation based on clip characteristics
                let amplitude = 1;
                if (clipId.includes('whisper') || clipId.includes('breath')) amplitude = 0.6;
                if (clipId.includes('scream') || clipId.includes('crash')) amplitude = 1.4;
                if (clipId.includes('static') || clipId.includes('noise')) amplitude = 0.8;

                const finalY = 50 + (baseY - 50) * amplitude;
                points.push(`${x}% ${Math.max(10, Math.min(90, finalY))}%`);
            }

            return `polygon(${points.join(', ')})`;
        }

        // Apply waveform to clip
        function applyWaveformToClip(clipElement) {
            let clipId = clipElement.dataset.clip;

            // For selected clip waveform, get the clip ID from the selected clip
            if (!clipId && selectedClip) {
                clipId = selectedClip.dataset.clip;
            }

            if (!clipId) return;

            // Remove existing waveform
            const existingWaveform = clipElement.querySelector('.clip-waveform');
            if (existingWaveform) {
                existingWaveform.remove();
            }

            // Create new waveform element
            const waveform = document.createElement('div');
            waveform.className = 'clip-waveform';
            waveform.style.clipPath = generateClipWaveform(clipId);
            clipElement.appendChild(waveform);
        }

        // Apply waveforms to all clips
        function applyWaveformsToAllClips() {
            document.querySelectorAll('.audio-clip').forEach(clip => {
                applyWaveformToClip(clip);
            });
        }

        // VU Meter animation functions
        function startVUMeterAnimation() {
            if (vuMeterInterval) clearInterval(vuMeterInterval);

            vuMeterInterval = setInterval(() => {
                // Simulate realistic VU meter behavior with music-like patterns
                const time = Date.now() / 100; // Smooth time progression

                // Base level with realistic variation
                let baseLeft = 0.3 + Math.sin(time * 0.1) * 0.1;
                let baseRight = 0.25 + Math.cos(time * 0.12) * 0.1;

                // Add transients and peaks (simulating drums, etc.)
                if (Math.random() < 0.05) { // Occasional peaks
                    baseLeft += Math.random() * 0.4;
                    baseRight += Math.random() * 0.4;
                }

                // Add frequency-based variation
                baseLeft += Math.sin(time * 0.3) * 0.15;
                baseRight += Math.cos(time * 0.35) * 0.15;

                // Clamp values and add some stereo difference
                vuLeftLevel = Math.max(0, Math.min(1, baseLeft + Math.random() * 0.1));
                vuRightLevel = Math.max(0, Math.min(1, baseRight + Math.random() * 0.1));

                updateVUMeters();
            }, 50); // 20fps for smooth animation
        }

        function stopVUMeterAnimation() {
            if (vuMeterInterval) {
                clearInterval(vuMeterInterval);
                vuMeterInterval = null;
            }

            // Fade out VU meters
            const fadeOut = setInterval(() => {
                vuLeftLevel *= 0.9;
                vuRightLevel *= 0.9;
                updateVUMeters();

                if (vuLeftLevel < 0.01 && vuRightLevel < 0.01) {
                    clearInterval(fadeOut);
                    vuLeftLevel = 0;
                    vuRightLevel = 0;
                    vuLeftPeakHold = 0;
                    vuRightPeakHold = 0;
                    updateVUMeters();
                }
            }, 50);
        }

        function updateVUMeters() {
            const leftFill = document.querySelector('#vu-left .vu-fill');
            const rightFill = document.querySelector('#vu-right .vu-fill');
            const leftPeak = document.querySelector('#vu-left .vu-peak');
            const rightPeak = document.querySelector('#vu-right .vu-peak');

            if (leftFill) {
                leftFill.style.height = `${vuLeftLevel * 100}%`;
            }
            if (rightFill) {
                rightFill.style.height = `${vuRightLevel * 100}%`;
            }

            // Update peak hold indicators
            if (vuLeftLevel > vuLeftPeakHold) {
                vuLeftPeakHold = vuLeftLevel;
            } else {
                vuLeftPeakHold *= 0.995; // Slow decay
            }

            if (vuRightLevel > vuRightPeakHold) {
                vuRightPeakHold = vuRightLevel;
            } else {
                vuRightPeakHold *= 0.995; // Slow decay
            }

            if (leftPeak) {
                leftPeak.style.top = `${100 - (vuLeftPeakHold * 100)}%`;
                leftPeak.style.opacity = vuLeftPeakHold > 0.05 ? '0.8' : '0';
            }
            if (rightPeak) {
                rightPeak.style.top = `${100 - (vuRightPeakHold * 100)}%`;
                rightPeak.style.opacity = vuRightPeakHold > 0.05 ? '0.8' : '0';
            }
        }

        // Toggle playback
        function toggleMainPlayback(event) {
            event.stopPropagation();

            // If starting main playback, pause any clip playback first
            if (!isPlaying && isClipPlaying) {
                pauseClipPlayback();
            }

            isPlaying = !isPlaying;
            isMainPlaying = isPlaying;

            // Update button icon
            const playBtn = event.target;
            playBtn.textContent = isPlaying ? 'â¸' : 'â–¶';

            if (isPlaying) {
                // Start VU meter animation
                startVUMeterAnimation();

                // Start playback
                playbackInterval = setInterval(() => {
                    currentTime += 0.1 * playbackSpeed;
                    if (currentTime >= totalDuration) {
                        // Check current loop state dynamically
                        const loopCheckbox = document.getElementById('main-loop-checkbox');
                        const currentLoopState = loopCheckbox ? loopCheckbox.checked : false;

                        if (currentLoopState) {
                            // Loop: reset to start and continue playing
                            currentTime = 0;
                        } else {
                            // No loop: stop playback and update button
                            isPlaying = false;
                            isMainPlaying = false;
                            clearInterval(playbackInterval);
                            currentTime = 0;
                            updateTimeDisplay();
                            updatePlaybackMarker();

                            // Stop VU meter animation
                            stopVUMeterAnimation();

                            // Update play button icon
                            playBtn.textContent = 'â–¶';
                            return;
                        }
                    }
                    updateTimeDisplay();
                    updatePlaybackMarker();
                }, 100);
            } else {
                // Pause playback
                clearInterval(playbackInterval);
                // Stop VU meter animation
                stopVUMeterAnimation();
            }
        }

        // Pause main playback (without resetting time)
        function pauseMainPlayback() {
            isPlaying = false;
            clearInterval(playbackInterval);

            // Update play button icon
            const playBtn = document.querySelector('.transport-controls .transport-btn:first-child');
            playBtn.textContent = 'â–¶';
        }

        // Stop playback
        function stopMainPlayback(event) {
            event.stopPropagation();
            isPlaying = false;
            isMainPlaying = false;
            clearInterval(playbackInterval);
            currentTime = 0;
            updateTimeDisplay();
            updatePlaybackMarker();

            // Stop VU meter animation
            stopVUMeterAnimation();

            // Reset play button icon
            const playBtn = document.querySelector('.transport-controls .transport-btn:first-child');
            playBtn.textContent = 'â–¶';
        }

        // Seek to start
        function seekToStart(event) {
            event.stopPropagation();
            currentTime = 0;
            updateTimeDisplay();
            updatePlaybackMarker();
        }

        // Seek to end
        function seekToEnd(event) {
            event.stopPropagation();
            currentTime = totalDuration;
            updateTimeDisplay();
            updatePlaybackMarker();
        }

        // Stem Isolation function - the new main analysis method
        async function stemIsolation(event) {
            event.stopPropagation();

            if (!window.currentLayerConfig) {
                console.error('No layer configuration loaded');
                return;
            }

            // Remove the button overlay
            const analyzeOverlay = event.target.closest('.analyze-overlay');
            if (analyzeOverlay) {
                analyzeOverlay.remove();
            }

            // Create loading overlay (only covers merged track)
            const loadingOverlay = document.createElement('div');
            loadingOverlay.className = 'stem-isolation-overlay';
            loadingOverlay.innerHTML = `
                <div class="isolation-progress-container">
                    <div class="isolation-title">ðŸŽµ STEM ISOLATION</div>
                    <div class="isolation-status">Initializing AI audio separation...</div>
                    <div class="progress-bar-container">
                        <div class="progress-bar-fill"></div>
                    </div>
                    <div class="layer-status">Preparing multi-band frequency analysis...</div>
                </div>
            `;

            // Add to merged track only so layers can be seen appearing below
            const mergedTrack = document.getElementById('merged');
            mergedTrack.appendChild(loadingOverlay);

            // Hide all existing layers to prevent duplication
            Object.keys(window.currentLayerConfig).forEach(layerId => {
                const layer = document.getElementById(layerId);
                if (layer) {
                    layer.style.display = 'none';
                }
            });

            // Clear merged track of existing clips
            const existingClips = mergedTrack.querySelectorAll('.audio-clip');
            existingClips.forEach(clip => clip.remove());

            // Separate large and small clips
            const largeClips = [];
            const smallClips = [];

            Object.entries(window.currentLayerConfig).forEach(([layerId, layerConfig]) => {
                layerConfig.clips.forEach(clip => {
                    const clipData = { ...clip, layerId, layerConfig };
                    if (clip.type === 'large') {
                        largeClips.push(clipData);
                    } else if (clip.type === 'small') {
                        smallClips.push(clipData);
                    } else {
                        // This should never happen if all clips have type defined
                        console.warn('Clip without type property:', clip);
                    }
                });
            });

            // Create MISC layers for small clips
            const miscLayers = createMiscLayers(smallClips);

            // Start the loading animation
            await performStemIsolation(largeClips, smallClips, miscLayers, loadingOverlay);
        }

        // Auto-analysis function (for menu)
        function autoAnalyzeAll() {
            // Use the same stem isolation process
            const fakeEvent = {
                stopPropagation: () => { },
                target: { closest: () => document.querySelector('.analyze-overlay') }
            };
            stemIsolation(fakeEvent);
        }

        function selectPlugin(pluginName) {
            if (!selectedClip || !isAnalyzed) return;

            const pluginSection = event.target.closest('.plugin-section');
            const isActive = pluginSection.classList.contains('active');
            const clipId = selectedClip.dataset.clip;

            // Initialize effects set for this clip if it doesn't exist
            if (!clipEffects.has(clipId)) {
                clipEffects.set(clipId, new Set());
            }

            const clipEffectSet = clipEffects.get(clipId);

            // Handle mute specifically
            if (pluginName === 'mute') {
                if (isActive) {
                    selectedClip.classList.remove('disabled');
                    clipEffectSet.delete(pluginName);
                } else {
                    selectedClip.classList.add('disabled');
                    clipEffectSet.add(pluginName);
                }
            } else {
                // Toggle effect in our data structure
                if (isActive) {
                    clipEffectSet.delete(pluginName);
                } else {
                    clipEffectSet.add(pluginName);
                }
            }

            // Toggle active state
            pluginSection.classList.toggle('active');

            // Toggle effect on clip
            const effectClass = `clip-${pluginName}`;
            selectedClip.classList.toggle(effectClass);

            // Update effect icons
            updateClipEffects(selectedClip);

            // Also update the clip in the merged view if it exists
            const mergedClip = document.querySelector(`#merged .audio-clip[data-clip="${clipId}"]`);
            if (mergedClip) {
                mergedClip.classList.toggle(effectClass);
            }
        }

        function updateClipEffects(clip) {
            // Remove all existing effect icons
            clip.querySelectorAll('.clip-effect').forEach(icon => icon.remove());

            const clipId = clip.dataset.clip;
            const activeEffects = clipEffects.get(clipId) || new Set();

            // Add icons for each active effect
            const effects = {
                'mute': 'ðŸ”‡',
                'noise': 'ðŸŒ«',
                'voice': 'ðŸŽ¤',
                'reverse': 'â†”',
                'stereo': 'ðŸŽ§',
                'volume': 'ðŸ”Š',
                'pitch': 'ðŸŽµ',
                'speed': 'âš¡',
                'highpass': 'ðŸ“ˆ',
                'lowpass': 'ðŸ“‰',
                'bitrate': 'ðŸ’¾'
            };

            let index = 0;
            for (const [effectName, icon] of Object.entries(effects)) {
                if (activeEffects.has(effectName)) {
                    const effectIcon = document.createElement('div');
                    effectIcon.className = 'clip-effect';
                    effectIcon.textContent = icon;
                    effectIcon.style.left = `${2 + (index * 12)}px`;
                    clip.appendChild(effectIcon);
                    index++;
                }
            }
        }

        // Create MISC layers for small clips
        function createMiscLayers(smallClips) {
            const miscLayers = [];

            // Sort clips by their original timeline position to maintain order
            const sortedClips = [...smallClips].sort((a, b) => {
                const leftA = parseFloat(a.left.replace('%', ''));
                const leftB = parseFloat(b.left.replace('%', ''));
                return leftA - leftB;
            });

            // Group clips into MISC layers while preserving their timeline positions
            let miscLayerIndex = 1;
            const clipsPerLayer = Math.ceil(sortedClips.length / Math.max(1, Math.ceil(sortedClips.length / 8))); // ~8 clips per layer max

            for (let i = 0; i < sortedClips.length; i += clipsPerLayer) {
                const layerClips = sortedClips.slice(i, i + clipsPerLayer);

                // Keep original positions - don't repack them to the left
                const miscLayer = {
                    id: `misc-${miscLayerIndex}`,
                    name: `MISC_${miscLayerIndex}`,
                    displayName: `MISC ${miscLayerIndex}`,
                    clips: layerClips.map(clip => ({
                        ...clip,
                        // Preserve original timeline position
                        left: clip.left,
                        width: clip.width
                    })),
                    baseHeight: 50 + (miscLayerIndex - 1) * 60 // Space them out vertically
                };

                miscLayers.push(miscLayer);
                miscLayerIndex++;
            }

            return miscLayers;
        }

        // Perform the stem isolation with loading animation
        async function performStemIsolation(largeClips, smallClips, miscLayers, loadingOverlay) {
            const progressBar = loadingOverlay.querySelector('.progress-bar-fill');
            const statusText = loadingOverlay.querySelector('.isolation-status');
            const layerStatus = loadingOverlay.querySelector('.layer-status');

            const messages = [
                'Analyzing frequency spectrum...',
                'Detecting harmonic patterns...',
                'Separating instrumental stems...',
                'Isolating vocal components...',
                'Processing digital artifacts...',
                'Finalizing layer separation...'
            ];

            // Get regular layers and sort them by displayName to ensure consistent order
            const regularLayers = [...new Set(largeClips.map(clip => clip.layerId))]
                .sort((a, b) => {
                    const layerA = window.currentLayerConfig[a];
                    const layerB = window.currentLayerConfig[b];
                    return layerA.displayName.localeCompare(layerB.displayName);
                });

            const totalSteps = regularLayers.length + miscLayers.length;
            let currentStep = 0;

            // Pre-create all layers in the correct order (but keep them hidden)
            const allLayersInOrder = [...regularLayers, ...miscLayers.map(m => m.id)];
            const createdLayers = [];

            // Create all regular layers first
            for (const layerId of regularLayers) {
                const trackLayer = createRegularLayerHidden(layerId, largeClips.filter(clip => clip.layerId === layerId));
                createdLayers.push(trackLayer);
            }

            // Create all MISC layers
            for (const miscLayer of miscLayers) {
                const trackLayer = createMiscLayerHidden(miscLayer);
                createdLayers.push(trackLayer);
            }

            // Now reveal layers one by one
            for (let i = 0; i < allLayersInOrder.length; i++) {
                const layerId = allLayersInOrder[i];
                const isRegular = regularLayers.includes(layerId);

                if (isRegular) {
                    statusText.textContent = messages[Math.min(currentStep, messages.length - 1)];
                    layerStatus.textContent = `Processing ${layerId.replace('-', ' ')}...`;
                } else {
                    statusText.textContent = 'Cataloging performance artifacts...';
                    layerStatus.textContent = `Creating ${miscLayers.find(m => m.id === layerId).displayName}...`;
                }

                // Step 1: Reveal the empty layer first
                createdLayers[i].style.display = 'flex';

                // Brief pause to show the empty layer
                await new Promise(resolve => setTimeout(resolve, 300));

                // Get actual clips from the DOM layer and sort them left to right
                let sortedClips = [];
                if (isRegular) {
                    // Get clips from the actual layer DOM element
                    const layerElement = createdLayers[i];
                    const clipElements = layerElement.querySelectorAll('.audio-clip');

                    sortedClips = Array.from(clipElements).map(clipEl => {
                        // Find the corresponding config data
                        const configClip = largeClips.find(c => c.id === clipEl.dataset.clip);
                        return {
                            id: clipEl.dataset.clip,
                            left: clipEl.style.left,
                            width: clipEl.style.width,
                            element: clipEl,
                            config: configClip
                        };
                    }).sort((a, b) => {
                        const leftA = parseFloat(a.left.replace('%', ''));
                        const leftB = parseFloat(b.left.replace('%', ''));
                        return leftA - leftB;
                    });
                } else {
                    // For MISC layers, use the provided clips
                    const miscLayer = miscLayers.find(m => m.id === layerId);
                    sortedClips = [...miscLayer.clips].sort((a, b) => {
                        const leftA = parseFloat(a.left.replace('%', ''));
                        const leftB = parseFloat(b.left.replace('%', ''));
                        return leftA - leftB;
                    });
                }

                // Step 2: Fill the layer with clips left-to-right while animating progress
                const clipsDelay = isRegular ? 2100 : 1300; // Reduced to account for the 300ms pause
                const startProgress = (currentStep / totalSteps) * 100;
                const endProgress = ((currentStep + 1) / totalSteps) * 100;

                // Start progress bar animation
                const progressPromise = animateProgressBar(progressBar, startProgress, endProgress, clipsDelay);

                // Reveal clips one by one from left to right (both in layer and merged view)
                const clipsPromise = revealClipsSequentially(layerId, sortedClips, clipsDelay, isRegular);

                // Wait for both to complete
                await Promise.all([progressPromise, clipsPromise]);

                currentStep++;
            }

            // Final completion
            statusText.textContent = 'Stem isolation complete!';
            layerStatus.textContent = 'All audio layers separated successfully.';
            progressBar.style.width = '100%';

            await new Promise(resolve => setTimeout(resolve, 2000)); // Doubled final delay

            // Remove loading overlay
            loadingOverlay.remove();

            // Store original clip data for zoom functionality
            storeOriginalClipData();

            // Enable zoom controls now that clips are available
            enableZoomControls();

            // Create MISC clips in merged view for zoom discovery
            createMergedMiscClips(smallClips);

            // Enable tools
            enableTools();

            // Set up manual discovery for small clips
            setupSmallClipDiscovery();


        }

        // Create a regular layer with large clips (old function for backwards compatibility)
        function createRegularLayer(layerId, layerClips) {
            const trackLayer = createRegularLayerHidden(layerId, layerClips);
            trackLayer.style.display = 'flex';
            addClipsToMergedView(layerId, layerClips);
        }

        // Create a regular layer but keep it hidden initially
        function createRegularLayerHidden(layerId, layerClips) {
            const layerConfig = window.currentLayerConfig[layerId];
            const centerPanel = document.querySelector('.center-panel');

            // Find the last layer to insert after (to maintain order)
            const existingLayers = centerPanel.querySelectorAll('.track-layer:not(#merged)');
            let insertAfter = document.getElementById('merged');

            // If there are existing layers, insert after the last one
            if (existingLayers.length > 0) {
                insertAfter = existingLayers[existingLayers.length - 1];
            }

            // Create a filtered layer config that only contains the large clips
            const filteredLayerConfig = {
                ...layerConfig,
                clips: layerClips // Only the large clips
            };

            // Create the layer with only large clips
            const trackLayer = createTrackLayer(layerId, filteredLayerConfig, centerPanel, insertAfter);

            // Hide all clips initially - they'll be revealed sequentially
            layerClips.forEach(clip => {
                const clipElement = trackLayer.querySelector(`[data-clip="${clip.id}"]`);
                if (clipElement) {
                    clipElement.style.display = 'none';
                    discoveredClips.add(clip.id); // Mark as discovered for tools
                }
            });

            return trackLayer;
        }

        // Add clips to merged view
        function addClipsToMergedView(layerId, layerClips) {
            const layerConfig = window.currentLayerConfig[layerId];

            layerClips.forEach(clip => {
                // Add to merged view
                const mergedClip = document.createElement('div');
                mergedClip.className = 'audio-clip revealed';
                mergedClip.dataset.clip = clip.id;
                mergedClip.dataset.layer = layerId;
                mergedClip.style.left = clip.left;
                mergedClip.style.width = clip.width;

                // Position in merged view
                const clipHash = clip.id.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                const verticalVariation = (clipHash % 30) - 15;
                mergedClip.style.top = `${layerConfig.baseHeight + verticalVariation}px`;
                mergedClip.textContent = clip.id;

                const mergedTrack = document.querySelector('#merged .track-content');
                if (mergedTrack) {
                    mergedTrack.appendChild(mergedClip);
                    // Apply waveform to the new clip
                    applyWaveformToClip(mergedClip);
                }
            });
        }

        // Create a MISC layer with small clips (old function for backwards compatibility)
        function createMiscLayer(miscLayer) {
            const trackLayer = createMiscLayerHidden(miscLayer);
            trackLayer.style.display = 'flex';
        }

        // Create a MISC layer but keep it hidden initially
        function createMiscLayerHidden(miscLayer) {
            const centerPanel = document.querySelector('.center-panel');

            // Find the last layer to insert after (to maintain order)
            const existingLayers = centerPanel.querySelectorAll('.track-layer:not(#merged)');
            let insertAfter = document.getElementById('merged');

            // If there are existing layers, insert after the last one
            if (existingLayers.length > 0) {
                insertAfter = existingLayers[existingLayers.length - 1];
            }

            const trackLayer = document.createElement('div');
            trackLayer.className = 'track-layer misc-layer';
            trackLayer.id = miscLayer.id;

            trackLayer.innerHTML = `
                <div class="track-info">
                    <span style="font-size: 0.8em; color: #95a5a6;">${miscLayer.displayName}</span><br>
                    <span style="font-weight: bold; color: #ecf0f1;">${miscLayer.name}</span>
                </div>
                <div class="track-content" 
                     style="position: relative;"
                     onclick="selectClip(event)">
                    ${miscLayer.clips.map(clip =>
                `<div class="audio-clip hidden-small" 
                              data-clip="${clip.id}"
                              data-layer="${miscLayer.id}"
                              style="left: ${clip.left}; width: ${clip.width}; height: 18px; top: 6px; display: none;" 
                              title="Zoom into the WAV file to find and identify this clip."
                              onclick="showClipPopup(event)">
                            ???
                        </div>`
            ).join('')}
                </div>
            `;

            // Insert after the last existing layer to maintain order
            insertAfter.parentNode.insertBefore(trackLayer, insertAfter.nextSibling);
            trackLayer.style.display = 'none'; // Start hidden

            return trackLayer;
        }

        // Animate progress bar smoothly from start to end percentage over duration
        function animateProgressBar(progressBar, startPercent, endPercent, duration) {
            return new Promise(resolve => {
                const startTime = Date.now();
                const startWidth = startPercent;
                const endWidth = endPercent;
                const totalChange = endWidth - startWidth;

                function updateProgress() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1); // 0 to 1

                    // Easing function for smooth animation (ease-out)
                    const easedProgress = 1 - Math.pow(1 - progress, 3);

                    const currentWidth = startWidth + (totalChange * easedProgress);
                    progressBar.style.width = `${currentWidth}%`;

                    if (progress < 1) {
                        requestAnimationFrame(updateProgress);
                    } else {
                        // Ensure we end at exactly the target
                        progressBar.style.width = `${endWidth}%`;
                        resolve();
                    }
                }

                requestAnimationFrame(updateProgress);
            });
        }

        // Reveal clips in a layer sequentially from left to right
        function revealClipsSequentially(layerId, sortedClips, totalDuration, isRegular) {
            return new Promise(async (resolve) => {
                if (sortedClips.length === 0) {
                    resolve();
                    return;
                }

                // Calculate delay between each clip
                const delayBetweenClips = totalDuration / sortedClips.length;

                for (let i = 0; i < sortedClips.length; i++) {
                    const clip = sortedClips[i];

                    if (isRegular) {
                        // Reveal clip in regular layer using the element reference
                        if (clip.element) {
                            clip.element.style.display = 'flex';

                            // Simultaneously add clip to merged view using config data
                            addSingleClipToMergedView(layerId, clip.config || clip);
                        }
                    } else {
                        // For MISC layers, reveal the ??? clips one by one
                        const miscLayer = document.getElementById(layerId);
                        if (miscLayer) {
                            const clipElement = miscLayer.querySelector(`[data-clip="${clip.id}"]`);
                            if (clipElement) {
                                clipElement.style.display = 'flex';
                            }
                        }
                    }

                    // Wait before revealing next clip (including after the last one)
                    await new Promise(resolve => setTimeout(resolve, delayBetweenClips));
                }

                resolve();
            });
        }

        // Add a single clip to merged view
        function addSingleClipToMergedView(layerId, clip) {
            const layerConfig = window.currentLayerConfig[layerId];

            // Add to merged view
            const mergedClip = document.createElement('div');
            mergedClip.className = 'audio-clip revealed';
            mergedClip.dataset.clip = clip.id;
            mergedClip.dataset.layer = layerId;
            mergedClip.style.left = clip.left;
            mergedClip.style.width = clip.width;

            // Position in merged view
            const clipHash = clip.id.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
            const verticalVariation = (clipHash % 30) - 15;
            mergedClip.style.top = `${layerConfig.baseHeight + verticalVariation}px`;
            mergedClip.textContent = clip.id;

            const mergedTrack = document.querySelector('#merged .track-content');
            if (mergedTrack) {
                mergedTrack.appendChild(mergedClip);
                // Apply waveform to the new clip
                applyWaveformToClip(mergedClip);

                // Update stored clip data if we're already tracking clips
                if (originalClipData.size > 0) {
                    const left = parseFloat(clip.left.replace('%', ''));
                    const width = parseFloat(clip.width.replace('%', ''));
                    originalClipData.set(clip.id, {
                        left: left,
                        width: width,
                        element: mergedClip
                    });
                }
            }
        }

        // Create MISC clips in merged view for zoom discovery
        function createMergedMiscClips(smallClips) {
            const mergedTrack = document.querySelector('#merged .track-content');
            if (!mergedTrack) return;

            // Clear any existing MISC clips
            mergedMiscClips.forEach(miscClip => {
                if (miscClip.element && miscClip.element.parentNode) {
                    miscClip.element.remove();
                }
            });
            mergedMiscClips = [];

            // Randomly select half of the clips to be spec-only
            specOnlyMiscClips.clear();
            if (smallClips.length > 1) {
                const shuffled = [...smallClips].sort(() => Math.random() - 0.5);
                const specOnlyCount = Math.floor(smallClips.length / 2);
                for (let i = 0; i < specOnlyCount; i++) {
                    specOnlyMiscClips.add(shuffled[i].id);
                }
            }

            // Calculate vertical spread for MISC clips
            const trackHeight = 240; // Merged track height
            const clipHeight = 18;
            const margin = 10; // Margin from top and bottom edges
            const availableHeight = trackHeight - (2 * margin) - clipHeight;

            // Create ??? clips for each small clip
            smallClips.forEach((clip, index) => {
                // Create the ??? clip element
                const miscClip = document.createElement('div');
                miscClip.className = 'audio-clip misc-clip-hidden';
                miscClip.dataset.clip = clip.id;
                miscClip.dataset.layer = clip.layerId;
                miscClip.style.left = clip.left;
                miscClip.style.width = clip.width;
                miscClip.style.height = '18px';

                // Distribute clips vertically across available space
                let topPosition;
                if (smallClips.length === 1) {
                    // Single clip: center it
                    topPosition = margin + (availableHeight / 2);
                } else {
                    // Multiple clips: spread them evenly
                    const step = availableHeight / (smallClips.length - 1);
                    topPosition = margin + (index * step);
                }
                miscClip.style.top = `${topPosition}px`;

                miscClip.style.display = 'none'; // Hidden initially
                miscClip.style.zIndex = '50'; // Above regular clips
                miscClip.style.background = '#555';
                miscClip.style.color = '#bbb';
                miscClip.style.border = '2px solid #888';
                miscClip.style.boxShadow = '0 0 0 0.5px rgba(0, 0, 0, 0.9), 0 2px 6px rgba(0, 0, 0, 0.4)';
                miscClip.style.textShadow = '1px 1px 2px rgba(0, 0, 0, 0.9)';
                miscClip.style.pointerEvents = 'auto';
                miscClip.textContent = '???';
                miscClip.title = 'Zoom into the WAV file to find and identify this clip.';

                // Add click handler for popup
                miscClip.addEventListener('click', showClipPopup);

                // Add to merged track
                mergedTrack.appendChild(miscClip);

                // Store tracking data
                mergedMiscClips.push({
                    clipId: clip.id,
                    layerId: clip.layerId,
                    originalLeft: clip.left,
                    originalWidth: clip.width,
                    element: miscClip
                });

                // Add to zoom tracking data so MISC clips scale with zoom
                const left = parseFloat(clip.left.replace('%', ''));
                const width = parseFloat(clip.width.replace('%', ''));
                originalClipData.set(clip.id, {
                    left: left,
                    width: width,
                    element: miscClip
                });
            });
        }

        // Setup manual discovery for small clips in MISC layers
        function setupSmallClipDiscovery() {
            const trackContent = document.querySelector('#merged .track-content');
            if (trackContent && !trackContent.hasAttribute('data-discovery-setup')) {
                trackContent.setAttribute('data-discovery-setup', 'true');
                trackContent.addEventListener('mousedown', startSmallClipSelection);
                trackContent.addEventListener('mousemove', updateSmallClipSelection);
                trackContent.addEventListener('mouseup', endSmallClipSelection);
            }
        }

        // MISC clip identification system (for merged view)
        let miscIdentificationDrawing = false;
        let miscIdentificationBox = null;
        let miscIdentificationStartX = 0;
        let miscIdentificationStartY = 0;

        function startMiscClipIdentification(event) {
            // Only respond to left mouse button (button 0)
            if (event.button !== 0) return;

            // Only work on revealed MISC clips
            const miscClipElements = document.querySelectorAll('#merged .misc-clip-hidden');

            // Check if any revealed clips are visible
            const visibleRevealedClips = Array.from(miscClipElements).filter(clip =>
                clip.style.display === 'flex' && revealedMiscClips.has(clip.dataset.clip)
            );

            // Always allow box drawing for testing, even if no clips available
            miscIdentificationDrawing = true;
            // Find the track content container, not the canvas
            const trackContent = event.target.closest('.track-content') || document.querySelector('#merged .track-content');
            const rect = trackContent.getBoundingClientRect();

            miscIdentificationStartX = event.clientX - rect.left;
            miscIdentificationStartY = event.clientY - rect.top;

            // Clean up existing boxes
            const existingBoxes = trackContent.querySelectorAll('.selection-box');
            existingBoxes.forEach(box => box.remove());

            // Create selection box
            miscIdentificationBox = document.createElement('div');
            miscIdentificationBox.className = 'selection-box';
            trackContent.appendChild(miscIdentificationBox);
        }

        function updateMiscClipIdentification(event) {
            if (!miscIdentificationDrawing || !miscIdentificationBox) {
                return;
            }

            // Use the same track content container we used for the start
            const trackContent = miscIdentificationBox.parentNode;
            const rect = trackContent.getBoundingClientRect();

            const currentX = event.clientX - rect.left;
            const currentY = event.clientY - rect.top;

            const width = Math.abs(currentX - miscIdentificationStartX);
            const height = Math.abs(currentY - miscIdentificationStartY);

            miscIdentificationBox.style.left = Math.min(miscIdentificationStartX, currentX) + 'px';
            miscIdentificationBox.style.top = Math.min(miscIdentificationStartY, currentY) + 'px';
            miscIdentificationBox.style.width = width + 'px';
            miscIdentificationBox.style.height = height + 'px';
        }

        function endMiscClipIdentification(event) {
            if (!miscIdentificationDrawing || !miscIdentificationBox) return;

            // Find overlapping revealed MISC clips in merged view
            const miscClipElements = document.querySelectorAll('#merged .misc-clip-hidden');
            const boxRect = miscIdentificationBox.getBoundingClientRect();

            // Only process clips if there are revealed MISC clips
            if (miscClipElements.length > 0) {
                miscClipElements.forEach(clip => {
                    // Only process revealed clips that are currently visible
                    if (!revealedMiscClips.has(clip.dataset.clip) || clip.style.display !== 'flex') return;

                    const clipRect = clip.getBoundingClientRect();

                    // Check for overlap
                    if (boxRect.left <= clipRect.right && boxRect.right >= clipRect.left &&
                        boxRect.top <= clipRect.bottom && boxRect.bottom >= clipRect.top) {

                        // Identify the clip - reveal its true name and make it editable
                        identifyMiscClip(clip);
                    }
                });
            }

            // Clean up
            if (miscIdentificationBox && miscIdentificationBox.parentNode) {
                miscIdentificationBox.remove();
            }
            miscIdentificationBox = null;
            miscIdentificationDrawing = false;
        }

        function identifyMiscClip(mergedClip) {
            const clipId = mergedClip.dataset.clip;
            const layerId = mergedClip.dataset.layer;

            // Update the merged view clip
            mergedClip.classList.remove('misc-clip-hidden');
            mergedClip.classList.add('identified');
            mergedClip.textContent = ''; // Clear the ??? text since we'll use ::after for the real name
            mergedClip.title = clipId; // Update hover text to show real name
            mergedClip.style.pointerEvents = 'auto';
            mergedClip.style.cursor = 'pointer';

            // Change click handler from showClipPopup to selectClip
            mergedClip.removeEventListener('click', showClipPopup);
            mergedClip.addEventListener('click', selectClip);

            // Get the layer color and apply it
            const clipColor = getClipColorByLayer(layerId);
            mergedClip.style.background = clipColor;
            mergedClip.style.color = '#fff';
            mergedClip.style.border = `2px solid ${clipColor}`;

            // Find and update the corresponding clip in the MISC layer
            const miscLayerClip = document.querySelector(`.misc-layer .audio-clip[data-clip="${clipId}"]`);
            if (miscLayerClip) {
                miscLayerClip.classList.remove('hidden-small');
                miscLayerClip.textContent = clipId; // Show the real name instead of ???
                miscLayerClip.title = clipId; // Update hover text to show real name
                miscLayerClip.style.background = clipColor;
                miscLayerClip.style.color = '#fff';
                miscLayerClip.style.border = `1px solid ${clipColor}`;
                miscLayerClip.style.pointerEvents = 'auto';
                miscLayerClip.style.cursor = 'pointer';

                // Change click handler from showClipPopup to selectClip
                miscLayerClip.removeAttribute('onclick');
                miscLayerClip.onclick = selectClip;
            }

            // Add to discovered clips for tools access
            if (typeof discoveredClips !== 'undefined') {
                discoveredClips.add(clipId);
            }
        }

        // Small clip discovery system
        let discoveryDrawing = false;
        let discoveryBox = null;
        let discoveryStartX = 0;
        let discoveryStartY = 0;

        function startSmallClipSelection(event) {
            // Only respond to left mouse button (button 0)
            if (event.button !== 0) return;

            const hiddenClips = document.querySelectorAll('.audio-clip.hidden-small');
            if (hiddenClips.length === 0) return;

            discoveryDrawing = true;
            const trackContent = event.target;
            const rect = trackContent.getBoundingClientRect();

            discoveryStartX = event.clientX - rect.left;
            discoveryStartY = event.clientY - rect.top;

            // Clean up existing boxes
            const existingBoxes = event.target.querySelectorAll('.selection-box');
            existingBoxes.forEach(box => box.remove());

            // Create selection box
            discoveryBox = document.createElement('div');
            discoveryBox.className = 'selection-box';
            trackContent.appendChild(discoveryBox);
        }

        function updateSmallClipSelection(event) {
            if (!discoveryDrawing || !discoveryBox) return;

            const trackContent = event.target;
            const rect = trackContent.getBoundingClientRect();

            const currentX = event.clientX - rect.left;
            const currentY = event.clientY - rect.top;

            const width = Math.abs(currentX - discoveryStartX);
            const height = Math.abs(currentY - discoveryStartY);

            discoveryBox.style.left = Math.min(discoveryStartX, currentX) + 'px';
            discoveryBox.style.top = Math.min(discoveryStartY, currentY) + 'px';
            discoveryBox.style.width = width + 'px';
            discoveryBox.style.height = height + 'px';
        }

        function endSmallClipSelection(event) {
            if (!discoveryDrawing || !discoveryBox) return;

            // Find overlapping hidden clips
            const hiddenClips = document.querySelectorAll('.misc-layer .audio-clip.hidden-small');
            const boxRect = discoveryBox.getBoundingClientRect();

            hiddenClips.forEach(clip => {
                const clipRect = clip.getBoundingClientRect();

                // Check for overlap
                if (boxRect.left <= clipRect.right && boxRect.right >= clipRect.left &&
                    boxRect.top <= clipRect.bottom && boxRect.bottom >= clipRect.top) {

                    // Reveal the clip
                    clip.classList.remove('hidden-small');
                    clip.textContent = clip.dataset.clip;
                    clip.style.pointerEvents = 'auto';
                    clip.style.background = '';
                    clip.style.color = '';
                    clip.style.border = '';

                    discoveredClips.add(clip.dataset.clip);
                }
            });

            // Clean up
            if (discoveryBox && discoveryBox.parentNode) {
                discoveryBox.remove();
            }
            discoveryBox = null;
            discoveryDrawing = false;
        }



        // AUDIO CONTROL FUNCTIONS
        function toggleTrackMute(trackId) {
            const track = document.getElementById(trackId);
            if (!track) return;

            track.classList.toggle('track-muted');

            // Update mute button
            const muteBtn = track.querySelector('.audio-control[onclick*="toggleTrackMute"]');
            if (muteBtn) {
                if (track.classList.contains('track-muted')) {
                    muteBtn.textContent = 'ðŸ”‡';
                    muteBtn.classList.add('muted');
                } else {
                    muteBtn.textContent = 'ðŸ”Š';
                    muteBtn.classList.remove('muted');
                }
            }
        }

        function toggleTrackSolo(trackId) {
            const track = document.getElementById(trackId);
            if (!track) return;

            track.classList.toggle('track-soloed');

            // Update solo button
            const soloBtn = track.querySelector('.audio-control[onclick*="toggleTrackSolo"]');
            if (soloBtn) {
                if (track.classList.contains('track-soloed')) {
                    soloBtn.textContent = 'ðŸŽ¯';
                    soloBtn.classList.add('soloed');
                } else {
                    soloBtn.textContent = 'S';
                    soloBtn.classList.remove('soloed');
                }
            }
        }

        function toggleTrackExpansion(trackId) {
            const track = document.getElementById(trackId);
            if (!track) return;

            track.classList.toggle('track-stereo');

            // Update expansion button
            const expandBtn = track.querySelector('.audio-control[onclick*="toggleTrackExpansion"]');
            if (expandBtn) {
                if (track.classList.contains('track-stereo')) {
                    expandBtn.textContent = 'â–¼';
                } else {
                    expandBtn.textContent = 'â–º';
                }
            }
        }

        // Prevent default drag behavior on document
        document.addEventListener('dragover', function (e) {
            e.preventDefault();
        });

        document.addEventListener('drop', function (e) {
            e.preventDefault();
        });

        function enableTools() {
            isAnalyzed = true;
            document.getElementById('tools-message').textContent = 'Select a clip in a layer to use available tools.';
            document.getElementById('tools-container').style.display = 'block';

            // Show view mode overlay
            const viewModeOverlay = document.getElementById('view-mode-overlay');
            if (viewModeOverlay) {
                viewModeOverlay.style.display = 'flex';
            }

            // Make all clips clickable
            document.querySelectorAll('.audio-clip').forEach(clip => {
                clip.style.pointerEvents = 'auto';
                clip.style.cursor = 'pointer';
            });
        }

        function selectClip(event) {
            if (!event.target.classList.contains('audio-clip')) return;
            if (!isAnalyzed) return; // Don't allow selection before analysis
            if (event.target.classList.contains('hidden-small')) return; // Don't allow selection of ??? clips
            if (event.target.classList.contains('misc-clip-hidden') && !event.target.classList.contains('identified')) return; // Don't allow selection of unidentified MISC clips

            event.stopPropagation();

            // Remove selection from all clips
            document.querySelectorAll('.audio-clip').forEach(clip => {
                clip.classList.remove('selected');
            });

            // Select clicked clip
            event.target.classList.add('selected');
            selectedClip = event.target;

            // Update selected clip display
            const selectedClipDisplay = document.getElementById('selected-clip-display');
            const selectedClipName = selectedClipDisplay.querySelector('.selected-clip-name');
            const selectedClipWaveform = selectedClipDisplay.querySelector('.selected-clip-waveform');
            const selectedClipTime = selectedClipDisplay.querySelector('.selected-clip-time');

            // Set clip name and correct waveform color
            selectedClipName.textContent = selectedClip.dataset.clip;

            // Calculate and display clip duration in time format
            const clipWidthPercent = parseFloat(selectedClip.style.width.replace('%', ''));
            const calculatedDuration = (clipWidthPercent / 100) * totalDuration;
            if (selectedClipTime) {
                selectedClipTime.textContent = `0.0 / ${formatClipTime(calculatedDuration)}`;
            }

            // Get the correct color based on the clip's layer
            const clipLayerId = selectedClip.closest('.track-layer').id;
            const clipColor = getClipColorByLayer(clipLayerId);
            selectedClipWaveform.style.background = `linear-gradient(90deg, ${clipColor}22 0%, ${clipColor}11 100%)`;
            selectedClipWaveform.style.color = clipColor;

            // Apply waveform to selected clip display
            applyWaveformToClip(selectedClipWaveform);

            // Reset playhead position
            const playhead = selectedClipWaveform.querySelector('.selected-clip-playhead');
            if (playhead) {
                playhead.style.left = '0%';
            }

            // Show the display and hide the tools message
            selectedClipDisplay.style.display = 'block';
            document.getElementById('tools-message').style.display = 'none';

            // Enable tools and update their active state based on clip effects
            const clipId = selectedClip.dataset.clip;
            const activeEffects = clipEffects.get(clipId) || new Set();

            document.querySelectorAll('.plugin-section').forEach(section => {
                section.classList.remove('disabled');
                // Get the plugin name from the title, removing emoji and spaces
                const pluginName = section.querySelector('.plugin-title').textContent
                    .replace(/[^\w\s]/g, '') // Remove emojis
                    .trim()
                    .toLowerCase()
                    .replace(/\s+/g, ''); // Remove spaces

                // Toggle active state based on whether this effect is in the clip's active effects
                section.classList.toggle('active', activeEffects.has(pluginName));
            });
        }

        function deselectClip() {
            if (selectedClip) {
                selectedClip.classList.remove('selected');
                selectedClip = null;

                // Stop any playing clip
                if (clipPlaybackInterval) {
                    clearInterval(clipPlaybackInterval);
                    clipPlaybackInterval = null;
                }
                isClipPlaying = false;

                // Reset playhead position and time display
                const playhead = document.querySelector('.selected-clip-playhead');
                if (playhead) {
                    playhead.style.left = '0%';
                }

                // Reset time display
                const timeDisplay = document.querySelector('.selected-clip-time');
                if (timeDisplay) {
                    timeDisplay.textContent = '0.0 / 0.0';
                }

                // Hide selected clip display and show tools message
                document.getElementById('selected-clip-display').style.display = 'none';
                const toolsMessage = document.getElementById('tools-message');
                toolsMessage.style.display = 'block';
                toolsMessage.textContent = 'Select a clip to use available tools';

                // Disable tools and reset their appearance
                document.querySelectorAll('.plugin-section').forEach(section => {
                    section.classList.add('disabled');
                    section.classList.remove('active'); // Remove active state to reset color
                });
            }
        }



        // Add click handler to document to deselect when clicking outside or in empty space
        document.addEventListener('click', function (event) {
            // Don't deselect if clicking on tools panel or its buttons
            if (event.target.closest('.right-panel')) {
                return;
            }

            // Don't deselect if clicking on left panel controls or VU meters
            if (event.target.closest('.left-panel')) {
                return;
            }

            // Don't deselect if clicking on interactive elements like buttons or controls
            if (event.target.closest('button, .zoom-controls, .pan-controls, .analyze-overlay, .view-mode-overlay, .slider-track, .slider-thumb')) {
                return;
            }

            // Don't deselect if clicking directly on an audio clip
            if (event.target.classList.contains('audio-clip')) {
                return;
            }

            // Deselect if clicking anywhere else (empty space, track content, center panel, etc.)
            deselectClip();
        });

        // Initially disable all clips
        document.querySelectorAll('.audio-clip').forEach(clip => {
            clip.style.pointerEvents = 'none';
            clip.style.cursor = 'default';
        });

        // Add slider functionality
        function initSliders() {
            document.querySelectorAll('.slider-track').forEach(track => {
                const thumb = track.querySelector('.slider-thumb');
                const fill = track.querySelector('.slider-fill');
                const pluginSection = track.closest('.plugin-section');
                let isDragging = false;
                const SNAP_TOLERANCE = 5; // 5% tolerance around center for snapping

                function updateSlider(e, skipSnap = false) {
                    const rect = track.getBoundingClientRect();
                    const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
                    let percent = (x / rect.width) * 100;

                    // Snap to center if within tolerance (unless explicitly skipped)
                    if (!skipSnap && Math.abs(percent - 50) <= SNAP_TOLERANCE) {
                        percent = 50;
                    }

                    // Update slider position
                    fill.style.width = `${percent}%`;
                    thumb.style.left = `${percent}%`;

                    // Update plugin section active state based on position
                    const isAtCenter = Math.abs(percent - 50) < 1; // Very close to center
                    if (isAtCenter) {
                        pluginSection.classList.remove('active');
                    } else {
                        pluginSection.classList.add('active');
                    }

                    // Handle speed slider specifically
                    if (track.closest('.plugin-section').querySelector('.plugin-title').textContent.includes('Speed')) {
                        const clip = document.querySelector('.audio-clip.selected');
                        if (clip) {
                            // Calculate new width based on slider value
                            // 50% = normal speed, 0% = half speed, 100% = double speed
                            const originalWidth = parseFloat(clip.dataset.originalWidth || clip.style.width);
                            const speedFactor = 1 + (percent - 50) / 50; // 0.5 to 1.5
                            clip.style.width = `${originalWidth * speedFactor}%`;
                        }
                    }
                }

                function handleMouseDown(e) {
                    isDragging = true;
                    // Store original width when starting to drag speed slider
                    if (track.closest('.plugin-section').querySelector('.plugin-title').textContent.includes('Speed')) {
                        const clip = document.querySelector('.audio-clip.selected');
                        if (clip && !clip.dataset.originalWidth) {
                            clip.dataset.originalWidth = clip.style.width;
                        }
                    }
                    // Prevent event bubbling to avoid any parent click handlers
                    e.stopPropagation();
                }

                function handleMouseMove(e) {
                    if (isDragging) {
                        updateSlider(e);
                        e.stopPropagation();
                    }
                }

                function handleMouseUp(e) {
                    if (isDragging) {
                        isDragging = false;
                        e.stopPropagation();
                    }
                }

                function handleTrackClick(e) {
                    if (!isDragging) {
                        updateSlider(e);
                    }
                    e.stopPropagation();
                }

                // Event listeners
                thumb.addEventListener('mousedown', handleMouseDown);
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                track.addEventListener('click', handleTrackClick);

                // Prevent plugin section clicks when interacting with sliders
                track.addEventListener('click', (e) => e.stopPropagation());
                thumb.addEventListener('click', (e) => e.stopPropagation());
            });
        }

        // Initialize application
        function initializeApp() {
            // Generate plugins dynamically (initially empty - will be populated when loading audio)
            const toolsContainer = document.getElementById('tools-container');
            if (toolsContainer) {
                toolsContainer.innerHTML = generatePluginsHTML([]);
            }

            // Initialize sliders
            initSliders();

            // Initialize zoom controls
            initializeZoomControls();

            // Initialize waveform canvas
            initializeWaveformCanvas();

            // Load default file configuration (simplest file)
            const defaultConfig = AUDIO_CONFIGS['1_simple_getaway_analysis.wav'];
            if (defaultConfig) {
                loadAudioConfiguration(defaultConfig);
            }

            // Apply waveforms to initial clips
            setTimeout(() => {
                applyWaveformsToAllClips();
            }, 100);
        }

        // Call initialization after the page loads
        window.addEventListener('load', initializeApp);

        // Load menu functionality
        function toggleLoadMenu(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('load-dropdown');
            dropdown.classList.toggle('show');
        }

        // Settings menu functionality
        function toggleSettingsMenu(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('settings-dropdown');
            dropdown.classList.toggle('show');
        }

        // Remove base layer clips from overlay (one-shot)
        function removeBaseOverlay() {
            const mergedTrack = document.querySelector('#merged .track-content');
            if (!mergedTrack) return;

            const baseClips = mergedTrack.querySelectorAll('.audio-clip.revealed');
            baseClips.forEach(clip => {
                clip.remove();
            });
        }

        // Remove base track layers (one-shot)
        function removeBaseTracks() {
            const allLayers = document.querySelectorAll('.track-layer');
            const baseLayers = Array.from(allLayers).filter(layer => {
                return layer.id !== 'merged' && !layer.classList.contains('misc-layer');
            });

            baseLayers.forEach(layer => {
                layer.remove();
            });
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function (event) {
            const loadDropdown = document.getElementById('load-dropdown');
            const loadMenu = event.target.closest('.load-menu');
            const settingsDropdown = document.getElementById('settings-dropdown');
            const settingsMenu = event.target.closest('.settings-menu');

            if (!loadMenu && loadDropdown.classList.contains('show')) {
                loadDropdown.classList.remove('show');
            }

            if (!settingsMenu && settingsDropdown.classList.contains('show')) {
                settingsDropdown.classList.remove('show');
            }
        });

        // Load audio file and reset state
        function loadAudioFile(filename, event) {
            event.stopPropagation();

            // Close dropdown
            document.getElementById('load-dropdown').classList.remove('show');

            // Get configuration for this file
            const config = AUDIO_CONFIGS[filename];
            if (!config) {
                console.error(`No configuration found for ${filename}`);
                return;
            }

            // Reset all application state
            resetApplicationState();

            // Update the application with new configuration
            loadAudioConfiguration(config);
        }

        // Reset entire application state
        function resetApplicationState() {
            // Reset analysis state
            isAnalyzed = false;
            discoveredClips.clear();
            selectedClip = null;
            selectedPlugin = null;

            // Clear all clip effects
            clipEffects.clear();

            // Clear clip position data
            originalClipData.clear();

            // Reset MISC clip discovery
            mergedMiscClips = [];
            revealedMiscClips.clear();
            specOnlyMiscClips.clear();

            // Disable zoom and hide controls
            zoomEnabled = false;
            const zoomControls = document.querySelector('.zoom-controls');
            const zoomDisplay = document.getElementById('zoom-level-display');
            const viewModeOverlay = document.getElementById('view-mode-overlay');
            if (zoomControls) {
                zoomControls.classList.remove('enabled');
            }
            if (zoomDisplay) {
                zoomDisplay.classList.remove('enabled');
            }
            if (viewModeOverlay) {
                viewModeOverlay.style.display = 'none';
            }

            // Stop any playback
            if (isPlaying) {
                stopMainPlayback({ stopPropagation: () => { } });
            }
            if (clipPlaybackInterval) {
                clearInterval(clipPlaybackInterval);
                clipPlaybackInterval = null;
            }
            isClipPlaying = false;
            clipElapsedTime = 0; // Reset clip elapsed time

            // Reset time
            currentTime = 0;
            updateTimeDisplay();
            updatePlaybackMarker();

            // Reset zoom
            currentZoom = 1.0;
            waveformOffsetX = 0;

            // Reset loop states and checkboxes
            mainLoopEnabled = false;
            clipLoopEnabled = false;
            const mainLoopCheckbox = document.getElementById('main-loop-checkbox');
            const clipLoopCheckbox = document.getElementById('clip-loop-checkbox');
            if (mainLoopCheckbox) mainLoopCheckbox.checked = false;
            if (clipLoopCheckbox) clipLoopCheckbox.checked = false;

            // Note: Don't reset view mode here - let loadAudioConfiguration handle it
            // Reset canvas visualization if it exists
            if (waveformCanvas) {
                // Regenerate data for new file
                const currentFile = document.querySelector('#merged .track-info span:first-child')?.textContent || '5_medium_find_the_murderer.wav';
                waveformData = generateWaveformData(currentFile, 10000);
                spectrogramData = generateSpectrogramData(currentFile);
                drawVisualization();
            }

            updateZoomButtons();

            // Hide and remove all dynamic track layers (keep only merged)
            const trackLayers = document.querySelectorAll('.track-layer:not(#merged)');
            trackLayers.forEach(layer => {
                layer.remove();
            });

            // Clear merged view of revealed clips
            const mergedTrack = document.querySelector('#merged .track-content');
            if (mergedTrack) {
                // Remove all revealed clips but preserve the waveform gradient
                mergedTrack.querySelectorAll('.audio-clip').forEach(clip => clip.remove());

                // Restore stem isolation overlay if it doesn't exist
                if (!mergedTrack.querySelector('.analyze-overlay')) {
                    const analyzeOverlay = document.createElement('div');
                    analyzeOverlay.className = 'analyze-overlay';
                    analyzeOverlay.innerHTML = '<button class="analyze-btn" onclick="stemIsolation(event)">Isolate Audio Stems</button>';
                    mergedTrack.appendChild(analyzeOverlay);
                }
            }

            // Reset tools panel
            document.getElementById('tools-message').textContent = 'Run Isolate Audio Stems to separate audio layers and unlock tools.';
            document.getElementById('tools-message').style.display = 'block';
            document.getElementById('tools-container').style.display = 'none';
            document.getElementById('selected-clip-display').style.display = 'none';

            // Disable all plugins and reset their state
            document.querySelectorAll('.plugin-section').forEach(section => {
                section.classList.remove('active');
                section.classList.add('disabled');

                // Reset sliders to center position and remove active state
                const sliderFill = section.querySelector('.slider-fill');
                const sliderThumb = section.querySelector('.slider-thumb');
                if (sliderFill && sliderThumb) {
                    sliderFill.style.width = '50%';
                    sliderThumb.style.left = '50%';
                    // Sliders at center should not be active
                    section.classList.remove('active');
                }
            });


        }

        // Load audio configuration and create track structure
        function loadAudioConfiguration(config) {
            // Update total duration
            totalDuration = config.totalDuration;
            updateTimeDisplay();



            // Update file status in left panel
            const currentFileName = document.getElementById('current-file-name');
            const fileStats = document.getElementById('file-stats');
            const fileGoal = document.getElementById('file-goal');

            if (currentFileName) {
                currentFileName.textContent = config.name;
            }
            if (fileStats) {
                fileStats.textContent = `Duration: ${formatTime(config.totalDuration)} â€¢ 44.1kHz`;
            }
            if (fileGoal) {
                fileGoal.textContent = TASK_HINTS[config.name] || 'Complete the audio analysis task';
            }

            // Canvas-based waveform is already updated via generateWaveformData

            // Update tools based on available tools for this level
            const toolsContainer = document.getElementById('tools-container');
            if (toolsContainer) {
                toolsContainer.innerHTML = generatePluginsHTML(config.availableTools || []);
                initSliders(); // Re-initialize sliders after regenerating tools
            }

            // Create track layers dynamically
            const centerPanel = document.querySelector('.center-panel');
            const mergedLayer = document.getElementById('merged');

            Object.entries(config.layers).forEach(([layerId, layerConfig]) => {
                createTrackLayer(layerId, layerConfig, centerPanel, mergedLayer);
            });

            // Update global layer config for analysis game
            window.currentLayerConfig = config.layers;

            // Restore view mode preference for this file
            const savedViewMode = viewModePreferences[config.name];
            if (savedViewMode && savedViewMode !== currentViewMode) {
                switchViewMode(savedViewMode);
            } else {
                // Update button states to reflect current mode
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === currentViewMode);
                });
            }

            // Generate both waveform and spectrogram data for the new file
            if (waveformCanvas) {
                waveformData = generateWaveformData(config.name, 10000);
                spectrogramData = generateSpectrogramData(config.name);
                drawVisualization();
            }

            // Apply waveforms to all newly created clips
            setTimeout(() => {
                applyWaveformsToAllClips();
            }, 100);


        }

        // Create a track layer element
        function createTrackLayer(layerId, layerConfig, parentElement, insertAfter) {
            const trackLayer = document.createElement('div');
            trackLayer.className = 'track-layer';
            trackLayer.id = layerId;

            trackLayer.innerHTML = `
                <div class="track-info">
                    <span style="font-size: 0.8em; color: #95a5a6;">${layerConfig.displayName}</span><br>
                    <span style="font-weight: bold; color: #ecf0f1;">${layerConfig.name}</span>
                </div>
                <div class="track-content" 
                     style="position: relative;"
                     onclick="selectClip(event)">
                    ${layerConfig.clips.map(clip =>
                `<div class="audio-clip" 
                              data-clip="${clip.id}"
                              style="left: ${clip.left}; width: ${clip.width}; height: 18px; top: 6px;" 
                              title="${clip.title}">
                            ${clip.id}
                        </div>`
            ).join('')}
                </div>
            `;

            // Insert after the merged layer
            insertAfter.parentNode.insertBefore(trackLayer, insertAfter.nextSibling);

            // Initially hide the layer
            trackLayer.style.display = 'none';

            // Apply waveforms to all clips in this layer
            trackLayer.querySelectorAll('.audio-clip').forEach(clip => {
                applyWaveformToClip(clip);
            });

            // Return the created element
            return trackLayer;
        }

        // Pause clip playback (without resetting time)
        function pauseClipPlayback() {
            // Calculate and store elapsed time before stopping
            if (isClipPlaying && clipStartTime > 0) {
                clipElapsedTime += Date.now() - clipStartTime;
            }

            // Stop playback interval but don't reset time/position
            if (clipPlaybackInterval) {
                clearInterval(clipPlaybackInterval);
                clipPlaybackInterval = null;
            }

            // Update UI state
            isClipPlaying = false;

            // Stop VU meter animation when clip is paused
            stopVUMeterAnimation();

            // Update play button icon
            const playBtn = document.querySelector('.selected-clip-play-btn');
            if (playBtn) {
                playBtn.textContent = 'â–¶';
            }
        }

        function stopClipPlayback(event) {
            event.stopPropagation();
            const playBtn = event.target.parentElement.querySelector('.selected-clip-play-btn');
            const timeDisplay = event.target.parentElement.querySelector('.selected-clip-time');
            const playhead = document.querySelector('.selected-clip-playhead');

            // Stop playback
            if (clipPlaybackInterval) {
                clearInterval(clipPlaybackInterval);
                clipPlaybackInterval = null;
            }

            // Reset UI and elapsed time
            playBtn.textContent = 'â–¶';
            isClipPlaying = false;
            clipElapsedTime = 0; // Reset elapsed time on stop

            // Stop VU meter animation
            stopVUMeterAnimation();

            // Reset time display to show 0 / total duration
            if (selectedClip) {
                const clipWidthPercent = parseFloat(selectedClip.style.width.replace('%', ''));
                const calculatedDuration = (clipWidthPercent / 100) * totalDuration;
                timeDisplay.textContent = `0.0 / ${formatClipTime(calculatedDuration)}`;
            } else {
                timeDisplay.textContent = '0.0 / 0.0';
            }

            // Reset playhead position
            if (playhead) {
                playhead.style.left = '0%';
            }
        }

        function toggleClipPlayback(event) {
            event.stopPropagation();
            const playBtn = event.target;
            const timeDisplay = document.querySelector('.selected-clip-time');
            const playhead = document.querySelector('.selected-clip-playhead');

            if (isClipPlaying) {
                // Stop playback
                clearInterval(clipPlaybackInterval);
                playBtn.textContent = 'â–¶';
                isClipPlaying = false;

                // Stop VU meter animation if no audio is playing
                stopVUMeterAnimation();
            } else {
                // If starting clip playback, pause main playback first
                if (isPlaying) {
                    pauseMainPlayback();
                }

                // Calculate clip duration based on clip width percentage and total duration
                if (selectedClip) {
                    const clipWidthPercent = parseFloat(selectedClip.style.width.replace('%', ''));
                    clipDuration = (clipWidthPercent / 100) * totalDuration * 1000; // Convert to milliseconds
                } else {
                    clipDuration = 5000; // Fallback to 5 seconds
                }

                // Start playback (account for any previously elapsed time)
                clipStartTime = Date.now() - clipElapsedTime;
                playBtn.textContent = 'â¸';
                isClipPlaying = true;

                // Start VU meter animation for clip playback
                startVUMeterAnimation();

                // Update time display and playhead every 50ms
                clipPlaybackInterval = setInterval(() => {
                    const elapsed = Date.now() - clipStartTime;
                    if (elapsed >= clipDuration) {
                        // Check current loop state dynamically
                        const clipLoopCheckbox = document.getElementById('clip-loop-checkbox');
                        const currentLoopState = clipLoopCheckbox ? clipLoopCheckbox.checked : false;

                        if (currentLoopState) {
                            // Loop: reset to start and continue playing
                            clipStartTime = Date.now();
                            clipElapsedTime = 0; // Reset elapsed time on loop
                            if (playhead) {
                                playhead.style.left = '0%';
                            }
                            return;
                        } else {
                            // No loop: stop at end of clip
                            clearInterval(clipPlaybackInterval);
                            playBtn.textContent = 'â–¶';
                            isClipPlaying = false;
                            clipElapsedTime = 0; // Reset elapsed time when finished

                            // Stop VU meter animation when clip finishes
                            stopVUMeterAnimation();

                            // Reset time display to show 0 / total duration
                            const totalTimeInSeconds = clipDuration / 1000;
                            timeDisplay.textContent = `0.0 / ${formatClipTime(totalTimeInSeconds)}`;

                            if (playhead) {
                                playhead.style.left = '100%';
                            }
                            return;
                        }
                    }

                    // Calculate progress percentage
                    const progress = (elapsed / clipDuration) * 100;

                    // Update playhead position
                    if (playhead) {
                        playhead.style.left = `${progress}%`;
                    }

                    // Format time as seconds.decimal / seconds.decimal (current / total)
                    const currentTimeInSeconds = elapsed / 1000;
                    const totalTimeInSeconds = clipDuration / 1000;
                    timeDisplay.textContent = `${formatClipTime(currentTimeInSeconds)} / ${formatClipTime(totalTimeInSeconds)}`;
                }, 50);
            }
        }
    </script>
</body>

</html>