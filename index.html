<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WaveEdit</title>
    <link rel="stylesheet" href="gradients.css">
    <script src="audio-configs.js"></script>
    <style>
        :root {
            /* Color Variables */
            --primary-brown: #8B6F47;
            --primary-brown-dark: #6B5837;
            --primary-red: #e74c3c;
            --primary-red-dark: #c0392b;
            --primary-orange: #f39c12;
            --primary-green: #27ae60;
            --primary-blue: #3498db;
            --primary-teal: #1abc9c;
            --primary-gray: #95a5a6;
            --primary-dark-blue: #34495e;
            --primary-dark-blue-alt: #2c3e50;

            /* Background Colors */
            --bg-primary: #1a1a1a;
            --bg-secondary: #2a2a2a;
            --bg-tertiary: #333;
            --bg-darker: #1e1e1e;
            --bg-transport: #252525;
            --bg-plugin-active: #4A3C2A;
            --bg-menu: #2c2c2c;
            --bg-hover: #404040;
            --bg-hover-light: #505050;
            --border-color: #444;
            --border-color-light: #555;
            --border-color-medium: #666;

            /* Text Colors */
            --text-primary: #ffffff;
            --text-secondary: #ecf0f1;
            --text-muted: #888;
            --text-light: #aaa;
            --text-very-light: #95a5a6;

            /* Effects */
            --shadow-subtle: 0 3px 8px rgba(0, 0, 0, 0.3);
            --shadow-glow: 0 0 10px rgba(243, 156, 18, 0.3);
            --transition-fast: all 0.2s ease;
            --transition-hover: all 0.1s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }

        /* Common Button Base */
        .btn-base {
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: bold;
        }

        .btn-round {
            border-radius: 50%;
        }

        .btn-rounded {
            border-radius: 5px;
        }

        /* Main App Layout */
        .app {
            display: flex;
            height: 100vh;
            flex-direction: column;
            overflow: hidden;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        /* Title Bar */
        .title-bar {
            height: 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            background: linear-gradient(90deg, var(--primary-brown-dark), var(--primary-brown));
        }

        .title-text {
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .window-controls {
            display: flex;
            gap: 10px;
        }

        .window-btn {
            border: none;
            cursor: pointer;
            transition: var(--transition-fast);
            font-weight: bold;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            color: white;
        }

        .minimize {
            background: var(--primary-orange);
        }

        .maximize {
            background: var(--primary-green);
        }

        .close {
            background: var(--primary-red);
        }

        /* Menu Bar */
        .menu-bar {
            height: 30px;
            display: flex;
            align-items: center;
            padding: 0 15px;
            background: var(--bg-menu);
            border-bottom: 1px solid var(--border-color);
            gap: 20px;
            flex-shrink: 0;
        }

        .menu-item {
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 3px;
            transition: var(--transition-fast);
        }

        .menu-item:hover {
            background: var(--bg-hover);
        }

        .menu-item.inactive {
            color: var(--text-muted);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .menu-item.inactive:hover {
            background: transparent;
        }

        /* Load dropdown styles */
        .load-menu {
            position: relative;
        }

        .load-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            min-width: 200px;
            background: var(--bg-menu);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            box-shadow: var(--shadow-subtle);
            z-index: 1000;
            display: none;
        }

        .load-dropdown.show {
            display: block;
        }

        .load-option {
            padding: 8px 12px;
            cursor: pointer;
            transition: var(--transition-fast);
            border-bottom: 1px solid var(--border-color);
        }

        .load-option:last-child {
            border-bottom: none;
        }

        .load-option:hover {
            background: var(--bg-hover);
        }

        /* Settings dropdown styles */
        .settings-menu {
            position: relative;
        }

        .settings-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            min-width: 200px;
            background: var(--bg-menu);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            box-shadow: var(--shadow-subtle);
            z-index: 1000;
            display: none;
        }

        .settings-dropdown.show {
            display: block;
        }

        .settings-option {
            padding: 8px 12px;
            cursor: pointer;
            transition: var(--transition-fast);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .settings-option:hover {
            background: var(--bg-hover);
        }

        .settings-option:last-child {
            border-bottom: none;
        }

        .settings-option:hover {
            background: var(--bg-hover);
        }

        .settings-checkbox {
            margin: 0;
            cursor: pointer;
            accent-color: var(--primary-orange);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        /* Panel Base */
        .panel-base {
            background: var(--bg-secondary);
            padding: 10px;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .left-panel {
            background: var(--bg-secondary);
            padding: 0;
            overflow-y: auto;
            overflow-x: hidden;
            flex-shrink: 0;
            width: 220px;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        .left-panel-section {
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .left-panel-section:last-child {
            border-bottom: none;
            flex: 1;
        }

        .right-panel {
            background: var(--bg-secondary);
            padding: 0;
            overflow-y: auto;
            flex-shrink: 0;
            width: 280px;
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        .right-panel-section {
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .right-panel-section:last-child {
            border-bottom: none;
            flex: 1;
        }

        .section-header {
            background: var(--bg-darker);
            padding: 12px 15px;
            font-size: 11px;
            font-weight: bold;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid var(--border-color);
        }

        .section-content {
            padding: 15px;
        }

        /* File Info Section */
        .file-info {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .current-file {
            font-weight: bold;
            font-size: 11px;
            color: var(--text-primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .file-stats {
            font-size: 11px;
            color: var(--text-muted);
            font-family: 'Courier New', monospace;
        }

        .file-goal {
            font-size: 11px;
            color: var(--primary-orange);
            font-weight: 500;
            font-style: italic;
            line-height: 1.3;
            margin-top: 4px;
        }

        /* Responsive Layout for Widescreen */
        @media (min-width: 1920px) {
            .left-panel {
                width: 260px;
            }

            .right-panel {
                width: 350px;
            }

            .vu-meter-large {
                width: 45px;
                height: 280px;
            }

            .section-content {
                padding: 20px;
            }
        }

        @media (min-width: 2560px) {
            .left-panel {
                width: 280px;
            }

            .right-panel {
                width: 400px;
            }

            .vu-meter-large {
                width: 50px;
                height: 320px;
            }

            .vu-meters-container {
                padding: 25px;
            }


        }

        /* Center Panel */
        .center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-darker);
            overflow: hidden;
            position: relative;
        }

        /* Timeline Header */
        .timeline-header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .timeline-instructions {
            padding: 10px 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            background: var(--bg-transport);
            border-bottom: 1px solid var(--border-color);
        }

        .instruction-item {
            font-size: 11px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .instruction-item strong {
            color: var(--text-primary);
        }

        .vu-meters-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .vu-title {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 15px;
            font-weight: bold;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .vu-meters {
            display: flex;
            gap: 20px;
            align-items: flex-end;
            justify-content: center;
            width: 100%;
        }

        .vu-meter {
            width: 30px;
            height: 200px;
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .vu-meter-large {
            width: 40px;
            height: 250px;
        }

        .vu-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top,
                    #27ae60 0%,
                    #f39c12 70%,
                    #e74c3c 90%);
            transition: height 0.1s ease-out;
            border-radius: 6px;
        }

        .vu-peak {
            position: absolute;
            left: 0;
            right: 0;
            height: 2px;
            background: #ffffff;
            transition: top 0.05s ease-out;
            border-radius: 1px;
            opacity: 0.8;
        }

        .vu-labels {
            display: flex;
            gap: 20px;
            margin-top: 12px;
            justify-content: center;
            width: 100%;
        }

        .vu-label {
            font-size: 14px;
            color: var(--text-muted);
            text-align: center;
            width: 30px;
            font-weight: bold;
        }

        .vu-label-large {
            width: 40px;
            font-size: 16px;
        }

        .main-playback-simple {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .main-time-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .main-position-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            position: relative;
            cursor: pointer;
            transition: height 0.2s ease;
        }

        .main-position-bar:hover {
            height: 8px;
        }

        .main-position-fill {
            height: 100%;
            background: var(--primary-orange);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s ease;
            box-shadow: 0 0 8px rgba(243, 156, 18, 0.4);
        }

        .main-controls-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .main-playback-title {
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 8px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            letter-spacing: 1px;
        }

        .main-playback-controls {
            display: flex;
            align-items: center;
            gap: 18px;
        }

        .main-buttons {
            display: flex;
            gap: 8px;
        }

        .main-loop-container {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .main-loop-label,
        .main-solo-label {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            padding: 6px 12px;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
            backdrop-filter: blur(5px);
        }

        .main-loop-label:hover,
        .main-solo-label:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .main-loop-label input[type="checkbox"],
        .main-solo-label input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
            accent-color: var(--primary-orange);
        }

        .loop-text,
        .solo-text {
            color: var(--text-primary);
            font-size: 12px;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        /* Disabled states for main playback controls */
        .main-buttons button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }

        .main-loop-label:has(input:disabled),
        .main-solo-label:has(input:disabled) {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .main-loop-label:has(input:disabled):hover,
        .main-solo-label:has(input:disabled):hover {
            background: transparent;
            border-color: rgba(255, 255, 255, 0.2);
            transform: none;
        }

        .playback-disabled-message {
            font-size: 11px;
            color: var(--text-muted);
            text-align: center;
            margin-top: 8px;
            font-style: italic;
        }

        /* Clip Focus Mode Styles */
        .audio-clip.clip-focused {
            filter: brightness(1.3) saturate(1.2);
            box-shadow: 0 0 8px rgba(243, 156, 18, 0.6);
            z-index: 10;
        }

        .audio-clip.clip-lowlighted {
            opacity: 0.3;
            filter: brightness(0.7) saturate(0.5);
        }

        .clip-focus-overlay {
            position: absolute;
            top: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            pointer-events: none;
            z-index: 5;
        }

        .clip-focus-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #f39c12;
            pointer-events: none;
            z-index: 15;
            box-shadow: 0 0 4px rgba(243, 156, 18, 0.8);
        }

        .clip-focus-line.in-point {
            border-left: 1px solid #fff;
        }

        .clip-focus-line.out-point {
            border-right: 1px solid #fff;
        }

        .main-time-display {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .transport-btn {
            border: none;
            cursor: pointer;
            transition: var(--transition-fast);
            font-weight: bold;
            border-radius: 8px;
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            line-height: 1;
            backdrop-filter: blur(5px);
        }

        .transport-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .transport-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .time-display {
            font-family: 'Courier New', monospace;
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
            text-align: center;
        }

        /* Timeline */
        .timeline-container {
            flex: 1;
            padding: 20px 20px 100px 20px;
            /* Extra bottom padding for scrolling */
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            max-height: calc(100vh - 140px);
            /* Account for title bar, menu, timeline header */
        }

        /* Custom scrollbar for timeline */
        .timeline-container::-webkit-scrollbar {
            width: 12px;
        }

        .timeline-container::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 6px;
        }

        .timeline-container::-webkit-scrollbar-thumb {
            background: var(--border-color-medium);
            border-radius: 6px;
            border: 2px solid var(--bg-secondary);
        }

        .timeline-container::-webkit-scrollbar-thumb:hover {
            background: var(--text-light);
        }

        /* Custom minimal scrollbars for sidebars */
        .left-panel::-webkit-scrollbar,
        .right-panel::-webkit-scrollbar {
            width: 6px;
        }

        .left-panel::-webkit-scrollbar-track,
        .right-panel::-webkit-scrollbar-track {
            background: transparent;
        }

        .left-panel::-webkit-scrollbar-thumb,
        .right-panel::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
            transition: background 0.2s ease;
        }

        .left-panel::-webkit-scrollbar-thumb:hover,
        .right-panel::-webkit-scrollbar-thumb:hover {
            background: var(--border-color-medium);
        }

        .timeline-ruler {
            height: 30px;
            background: var(--bg-secondary);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            border-radius: 3px;
        }

        .time-marker {
            margin-right: 40px;
            font-size: 12px;
            color: var(--text-light);
        }

        /* Merged View */
        .merged-view {
            min-height: 240px;
            max-height: 400px;
            /* Prevent merged view from becoming too tall */
            background: var(--bg-tertiary);
            margin-bottom: 20px;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }



        .merged-view::before {
            content: "MERGED VIEW";
            position: absolute;
            top: 5px;
            left: 10px;
            font-size: 12px;
            color: var(--text-light);
            z-index: 20;
        }

        /* Track layer in merged view */
        #merged.track-layer {
            min-height: 240px !important;
            max-height: 400px !important;
            /* Scale with merged view height */
        }

        /* Track content in merged view */
        #merged .track-content {
            min-height: 240px !important;
            max-height: 400px !important;
            /* Scale with merged view height */
            background: linear-gradient(90deg, var(--primary-dark-blue-alt) 0%, var(--primary-dark-blue-alt) 100%);
            position: relative;
        }

        .merged-waveform {
            position: absolute;
            bottom: 5px;
            left: 10px;
            right: 30px;
            height: 15px;
            border-radius: 2px;
            opacity: 0.8;
        }

        /* Track Layers */
        .track-layer {
            height: 60px;
            background: var(--bg-secondary);
            margin-bottom: 10px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            padding: 0 15px;
            position: relative;
        }

        .track-info {
            width: 150px;
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 4px 0;
            line-height: 0.6;
        }



        .track-controls {
            display: flex;
            gap: 5px;
            margin-left: auto;
            margin-right: 10px;
        }

        .track-content {
            flex: 1;
            height: 30px;
            margin-left: 20px;
            position: relative;
            border-radius: 3px;
        }

        /* Playback marker styles */
        #playback-marker {
            transition: left 0.1s ease;
            box-shadow: 0 0 8px rgba(243, 156, 18, 0.6);
        }

        /* Analysis mode playhead - distinctive appearance */
        #playback-marker.analysis-mode {
            width: 3px;
            background: linear-gradient(to bottom, #00ff88 0%, #00cc66 100%);
            box-shadow: 0 0 12px rgba(0, 255, 136, 0.8), 0 0 4px rgba(0, 255, 136, 0.4);
            border-radius: 1px;
        }

        /* Analyze button overlay */
        .analyze-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .analyze-btn {
            padding: 8px 16px;
            background: var(--primary-brown);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: var(--transition-fast);
        }

        .analyze-btn:hover {
            background: var(--primary-brown-dark);
            transform: translateY(-2px);
            box-shadow: var(--shadow-subtle);
        }

        /* Analysis minigame styles */
        .track-layer:not(#merged) {
            display: none;
        }

        .analysis-clip {
            position: absolute;
            height: 20px;
            top: 20px;
            border-radius: 3px;
            cursor: pointer;
            border: 2px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #666;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
            user-select: none;
            transition: all 0.2s ease;
            z-index: 20;
            background: #444;
            pointer-events: none;
        }

        .analysis-clip.revealed {
            animation: reveal 0.5s ease-out;
        }

        @keyframes reveal {
            0% {
                transform: scale(1);
                opacity: 0.5;
            }

            50% {
                transform: scale(1.2);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .selection-box {
            position: absolute;
            border: 2px dashed #1abc9c;
            background: rgba(26, 188, 156, 0.1);
            pointer-events: none;
            z-index: 30;
        }

        .selection-box.invalid {
            border-color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
        }

        /* Audio clip styling */
        .audio-clip {
            position: absolute;
            height: 20px;
            top: 5px;
            border-radius: 3px;
            cursor: pointer;
            border: 1.5px solid rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 0 0.5px rgba(0, 0, 0, 0.8), 0 2px 4px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.9);
            user-select: none;
            transition: all 0.2s ease;
            background: rgba(0, 0, 0, 0.1);
            overflow: hidden;
            font-style: normal !important;
            /* Prevent italic */
            z-index: 5;
            /* Base layer for clip */
        }

        /* Override the vertical line pattern from gradients.css with flat color */
        .audio-clip::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.1) !important;
            opacity: 1 !important;
            z-index: 0;
        }

        /* Clip waveform visualization */
        .clip-waveform {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: currentColor;
            opacity: 0.3;
            z-index: 1;
            pointer-events: none;
        }

        /* Clip effect icons container */
        .clip-effects-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 12px;
            z-index: 1;
            /* Below text */
            pointer-events: none;
        }

        /* Clip effect icons */
        .clip-effect {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 8px;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
            line-height: 1;
            font-style: normal !important;
            /* Prevent italic */
        }

        /* Ensure text is always on top */
        .audio-clip::after {
            content: attr(data-clip);
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            /* Above everything */
            font-style: normal !important;
            /* Prevent italic */
        }

        /* Hide the original text content */
        .audio-clip {
            color: transparent;
        }

        .clip-effect+.clip-effect {
            left: 14px;
        }

        .clip-effect+.clip-effect+.clip-effect {
            left: 26px;
        }

        .clip-effect+.clip-effect+.clip-effect+.clip-effect {
            left: 38px;
        }

        /* Hide effect icons in merged view */
        #merged .clip-effects-container {
            display: none;
        }

        /* View mode toggle styles */
        .view-mode-toggle {
            display: flex;
            gap: 2px;
            margin-top: 4px;
        }



        /* Gradual reveal clip styling */
        .audio-clip.gradual-reveal {
            position: relative;
            overflow: hidden;
            transition: width 0.1s ease;
        }

        /* Add styles for merged view clips */
        #merged .audio-clip {
            pointer-events: none !important;
            opacity: 0.8;
            z-index: 1;
            height: 18px;
            top: 0;
            /* Reset top position, will be set by JS */
            cursor: default;
            border: 1.5px solid rgba(255, 255, 255, 0.7);
            box-shadow: 0 0 0 0.5px rgba(0, 0, 0, 0.9), 0 2px 6px rgba(0, 0, 0, 0.4);
        }

        #merged .audio-clip.revealed {
            opacity: 0.9;
            z-index: 2;
            pointer-events: none !important;
        }

        /* Layer-specific colors for merged view */
        /* Demo Level: Viola's First Track */
        #merged .audio-clip[data-layer="viola-vocals"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="acoustic-instrument"] {
            color: #27ae60;
        }

        #merged .audio-clip[data-layer="electronic-elements"] {
            color: #9b59b6;
        }

        #merged .audio-clip[data-layer="misc-hidden-elements"] {
            color: #8e44ad;
        }

        /* Day 1: Daily Life */
        #merged .audio-clip[data-layer="target-conversation"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="surveillance-interference"] {
            color: #34495e;
        }

        #merged .audio-clip[data-layer="mikes-recording"] {
            color: #f39c12;
        }

        #merged .audio-clip[data-layer="environmental-explanation"] {
            color: #27ae60;
        }

        /* Day 2: Inspiration */
        #merged .audio-clip[data-layer="viola-voice"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="tape-degradation"] {
            color: #95a5a6;
        }

        #merged .audio-clip[data-layer="test-signal"] {
            color: #3498db;
        }

        #merged .audio-clip[data-layer="forum-interference"] {
            color: #e67e22;
        }

        /* Day 3: Finding Viola */
        #merged .audio-clip[data-layer="viola-surface-layer"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="hidden-morse"] {
            color: #3498db;
        }

        #merged .audio-clip[data-layer="final-morse"] {
            color: #3498db;
        }

        #merged .audio-clip[data-layer="environmental-sounds"] {
            color: #27ae60;
        }

        /* Day 4: Villa Fossati */
        #merged .audio-clip[data-layer="lock-mechanism"] {
            color: #34495e;
        }

        #merged .audio-clip[data-layer="villa-ambience"] {
            color: #8e44ad;
        }

        #merged .audio-clip[data-layer="evidence-audio"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="police-interference"] {
            color: #3498db;
        }

        /* Day 5: Old Connections */
        #merged .audio-clip[data-layer="death-scene-audio"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="forensic-evidence"] {
            color: #34495e;
        }

        #merged .audio-clip[data-layer="vincent-guitar"] {
            color: #f39c12;
        }

        #merged .audio-clip[data-layer="liguria-memories"] {
            color: #27ae60;
        }

        /* Day 6: Tape 1/92 */
        #merged .audio-clip[data-layer="viola-monologue"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="italian-ambience"] {
            color: #27ae60;
        }

        #merged .audio-clip[data-layer="waveform-recreation"] {
            color: #9b59b6;
        }

        #merged .audio-clip[data-layer="supernatural-buildup"] {
            color: #e74c3c;
        }

        /* Day 7: Hello Vincent */
        #merged .audio-clip[data-layer="impossible-song"] {
            color: #e67e22;
        }

        #merged .audio-clip[data-layer="reality-glitches"] {
            color: #9b59b6;
        }

        #merged .audio-clip[data-layer="mikes-song"] {
            color: #f39c12;
        }

        #merged .audio-clip[data-layer="entity-presence"] {
            color: #e74c3c;
        }

        /* Day 8: Losing Control */
        #merged .audio-clip[data-layer="entity-claudia"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="entity-giorgio"] {
            color: #3498db;
        }

        #merged .audio-clip[data-layer="entity-pavel"] {
            color: #f39c12;
        }

        /* Day 9: Creating the Song */
        #merged .audio-clip[data-layer="viola-explanation"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="imprinted-essence"] {
            color: #2c3e50;
        }

        #merged .audio-clip[data-layer="vincent-creativity"] {
            color: #f39c12;
        }

        #merged .audio-clip[data-layer="viola-foundation"] {
            color: #e74c3c;
        }

        #merged .audio-clip[data-layer="imprinted-influence"] {
            color: #2c3e50;
        }

        /* Day 10: Final Choice */
        #merged .audio-clip[data-layer="memory-fragments"] {
            color: #3498db;
        }

        #merged .audio-clip[data-layer="password-clues"] {
            color: #e74c3c;
        }

        /* MISC Elements (all levels) */
        #merged .audio-clip[data-layer="misc-elements"] {
            color: #8e44ad;
        }

        .audio-clip:hover {
            transform: translateY(-1px);
            box-shadow: 0 0 0 0.5px rgba(0, 0, 0, 0.9), 0 4px 12px rgba(0, 0, 0, 0.4);
            border-color: rgba(255, 255, 255, 0.8);
        }

        .audio-clip.selected {
            border: 2px solid #f39c12;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.3);
        }

        .audio-clip.dragging {
            z-index: 1000;
            transform: rotate(5deg);
            opacity: 0.8;
        }

        .audio-clip.disabled {
            opacity: 0.3;
            filter: grayscale(100%);
            pointer-events: none;
        }

        /* Layer-specific colors */
        /* Demo Level: Viola's First Track */
        #viola-vocals .audio-clip {
            color: #e74c3c;
        }

        #acoustic-instrument .audio-clip {
            color: #27ae60;
        }

        #electronic-elements .audio-clip {
            color: #9b59b6;
        }

        #misc-hidden-elements .audio-clip {
            color: #8e44ad;
        }

        /* Day 1: Daily Life */
        #target-conversation .audio-clip {
            color: #e74c3c;
        }

        #surveillance-interference .audio-clip {
            color: #34495e;
        }

        #mikes-recording .audio-clip {
            color: #f39c12;
        }

        #environmental-explanation .audio-clip {
            color: #27ae60;
        }

        /* Day 2: Inspiration */
        #viola-voice .audio-clip {
            color: #e74c3c;
        }

        #tape-degradation .audio-clip {
            color: #95a5a6;
        }

        #test-signal .audio-clip {
            color: #3498db;
        }

        #forum-interference .audio-clip {
            color: #e67e22;
        }

        /* Day 3: Finding Viola */
        #viola-surface-layer .audio-clip {
            color: #e74c3c;
        }

        #hidden-morse .audio-clip {
            color: #3498db;
        }

        #final-morse .audio-clip {
            color: #3498db;
        }

        #environmental-sounds .audio-clip {
            color: #27ae60;
        }

        /* Day 4: Villa Fossati */
        #lock-mechanism .audio-clip {
            color: #34495e;
        }

        #villa-ambience .audio-clip {
            color: #8e44ad;
        }

        #evidence-audio .audio-clip {
            color: #e74c3c;
        }

        #police-interference .audio-clip {
            color: #3498db;
        }

        /* Day 5: Old Connections */
        #death-scene-audio .audio-clip {
            color: #e74c3c;
        }

        #forensic-evidence .audio-clip {
            color: #34495e;
        }

        #vincent-guitar .audio-clip {
            color: #f39c12;
        }

        #liguria-memories .audio-clip {
            color: #27ae60;
        }

        /* Day 6: Tape 1/92 */
        #viola-monologue .audio-clip {
            color: #e74c3c;
        }

        #italian-ambience .audio-clip {
            color: #27ae60;
        }

        #waveform-recreation .audio-clip {
            color: #9b59b6;
        }

        #supernatural-buildup .audio-clip {
            color: #e74c3c;
        }

        /* Day 7: Hello Vincent */
        #impossible-song .audio-clip {
            color: #e67e22;
        }

        #reality-glitches .audio-clip {
            color: #9b59b6;
        }

        #mikes-song .audio-clip {
            color: #f39c12;
        }

        #entity-presence .audio-clip {
            color: #e74c3c;
        }

        /* Day 8: Losing Control */
        #entity-claudia .audio-clip {
            color: #e74c3c;
        }

        #entity-giorgio .audio-clip {
            color: #3498db;
        }

        #entity-pavel .audio-clip {
            color: #f39c12;
        }

        /* Day 9: Creating the Song */
        #viola-explanation .audio-clip {
            color: #e74c3c;
        }

        #imprinted-essence .audio-clip {
            color: #2c3e50;
        }

        #vincent-creativity .audio-clip {
            color: #f39c12;
        }

        #viola-foundation .audio-clip {
            color: #e74c3c;
        }

        #imprinted-influence .audio-clip {
            color: #2c3e50;
        }

        /* Day 10: Final Choice */
        #memory-fragments .audio-clip {
            color: #3498db;
        }

        #password-clues .audio-clip {
            color: #e74c3c;
        }

        /* MISC Elements (all levels) */
        #misc-elements .audio-clip {
            color: #8e44ad;
        }

        /* Layer background colors to match clip colors with good contrast */
        /* Demo Level: Viola's First Track */
        #viola-vocals {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        #acoustic-instrument {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.15), rgba(39, 174, 96, 0.08));
        }

        #electronic-elements {
            background: linear-gradient(90deg, rgba(155, 89, 182, 0.15), rgba(155, 89, 182, 0.08));
        }

        #misc-hidden-elements {
            background: linear-gradient(90deg, rgba(142, 68, 173, 0.15), rgba(142, 68, 173, 0.08));
        }

        /* Day 1: Daily Life */
        #target-conversation {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        #environmental-noise {
            background: linear-gradient(90deg, rgba(52, 73, 94, 0.15), rgba(52, 73, 94, 0.08));
        }

        #mikes-recording {
            background: linear-gradient(90deg, rgba(243, 156, 18, 0.15), rgba(243, 156, 18, 0.08));
        }

        #environmental-explanation {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.15), rgba(39, 174, 96, 0.08));
        }

        /* Day 2: Inspiration */
        #viola-voice {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        #tape-degradation {
            background: linear-gradient(90deg, rgba(149, 165, 166, 0.15), rgba(149, 165, 166, 0.08));
        }

        #studio-atmosphere {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.15), rgba(39, 174, 96, 0.08));
        }

        #frequency-tests {
            background: linear-gradient(90deg, rgba(52, 152, 219, 0.15), rgba(52, 152, 219, 0.08));
        }

        #stereo-tests {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.15), rgba(39, 174, 96, 0.08));
        }

        #compression-artifacts {
            background: linear-gradient(90deg, rgba(230, 126, 34, 0.15), rgba(230, 126, 34, 0.08));
        }

        #technical-precision {
            background: linear-gradient(90deg, rgba(155, 89, 182, 0.15), rgba(155, 89, 182, 0.08));
        }

        /* Day 3: Finding Viola */
        #viola-surface-layer {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        #morse-signals-primary {
            background: linear-gradient(90deg, rgba(52, 152, 219, 0.15), rgba(52, 152, 219, 0.08));
        }

        #morse-signals-hidden {
            background: linear-gradient(90deg, rgba(243, 156, 18, 0.15), rgba(243, 156, 18, 0.08));
        }

        #radio-interference {
            background: linear-gradient(90deg, rgba(149, 165, 166, 0.15), rgba(149, 165, 166, 0.08));
        }

        #final-morse {
            background: linear-gradient(90deg, rgba(52, 152, 219, 0.15), rgba(52, 152, 219, 0.08));
        }

        #ligurian-atmosphere {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.15), rgba(39, 174, 96, 0.08));
        }

        #human-presence {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        /* Day 4: Villa Fossati */
        #lock-tone-sequence {
            background: linear-gradient(90deg, rgba(52, 73, 94, 0.15), rgba(52, 73, 94, 0.08));
        }

        #mechanical-resonance {
            background: linear-gradient(90deg, rgba(149, 165, 166, 0.15), rgba(149, 165, 166, 0.08));
        }

        #villa-acoustics {
            background: linear-gradient(90deg, rgba(142, 68, 173, 0.15), rgba(142, 68, 173, 0.08));
        }

        #witness-testimonies {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        #crime-scene-audio {
            background: linear-gradient(90deg, rgba(52, 73, 94, 0.15), rgba(52, 73, 94, 0.08));
        }

        #police-communications {
            background: linear-gradient(90deg, rgba(52, 152, 219, 0.15), rgba(52, 152, 219, 0.08));
        }

        #forensic-details {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.15), rgba(39, 174, 96, 0.08));
        }

        #administrative-background {
            background: linear-gradient(90deg, rgba(149, 165, 166, 0.15), rgba(149, 165, 166, 0.08));
        }

        /* Day 5: Old Connections */
        #witness-testimony {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        #death-night-atmosphere {
            background: linear-gradient(90deg, rgba(44, 62, 80, 0.15), rgba(44, 62, 80, 0.08));
        }

        #supernatural-hints {
            background: linear-gradient(90deg, rgba(142, 68, 173, 0.15), rgba(142, 68, 173, 0.08));
        }

        #mike-performance {
            background: linear-gradient(90deg, rgba(243, 156, 18, 0.15), rgba(243, 156, 18, 0.08));
        }

        #liguria-memories {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.15), rgba(39, 174, 96, 0.08));
        }

        /* Day 6: Tape 1/92 */
        #viola-monologue {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        #italian-ambience {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.15), rgba(39, 174, 96, 0.08));
        }

        #waveform-recreation {
            background: linear-gradient(90deg, rgba(155, 89, 182, 0.15), rgba(155, 89, 182, 0.08));
        }

        #supernatural-buildup {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        /* Day 7: Hello Vincent */
        #impossible-song {
            background: linear-gradient(90deg, rgba(230, 126, 34, 0.15), rgba(230, 126, 34, 0.08));
        }

        #reality-glitches {
            background: linear-gradient(90deg, rgba(155, 89, 182, 0.15), rgba(155, 89, 182, 0.08));
        }

        #mikes-song {
            background: linear-gradient(90deg, rgba(243, 156, 18, 0.15), rgba(243, 156, 18, 0.08));
        }

        #entity-presence {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        /* Day 8: Losing Control */
        #entity-claudia {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        #entity-giorgio {
            background: linear-gradient(90deg, rgba(52, 152, 219, 0.15), rgba(52, 152, 219, 0.08));
        }

        #entity-pavel {
            background: linear-gradient(90deg, rgba(243, 156, 18, 0.15), rgba(243, 156, 18, 0.08));
        }

        /* Day 9: Creating the Song */
        #viola-explanation {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        #imprinted-essence {
            background: linear-gradient(90deg, rgba(44, 62, 80, 0.15), rgba(44, 62, 80, 0.08));
        }

        #vincent-musical-soul {
            background: linear-gradient(90deg, rgba(243, 156, 18, 0.15), rgba(243, 156, 18, 0.08));
        }

        #viola-experimental-foundation {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        #imprinted-darkness-integration {
            background: linear-gradient(90deg, rgba(44, 62, 80, 0.15), rgba(44, 62, 80, 0.08));
        }

        #all-previous-levels-echo {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.15), rgba(39, 174, 96, 0.08));
        }

        #technical-creation-process {
            background: linear-gradient(90deg, rgba(155, 89, 182, 0.15), rgba(155, 89, 182, 0.08));
        }

        /* Day 10: Final Choice */
        #memory-fragments {
            background: linear-gradient(90deg, rgba(52, 152, 219, 0.15), rgba(52, 152, 219, 0.08));
        }

        #password-clues {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.08));
        }

        /* MISC Elements (all levels) */
        #misc-elements {
            background: linear-gradient(90deg, rgba(142, 68, 173, 0.15), rgba(142, 68, 173, 0.08));
        }

        /* Plugin applied effects */
        .clip-volume-boost {
            border-top: 2px solid #1abc9c;
        }

        .clip-denoise {
            opacity: 0.8;
            border-top: 2px solid #95a5a6;
        }

        .clip-frequency {
            border-top: 2px solid #3498db;
        }

        .clip-speed {
            font-style: italic;
            border-top: 2px solid #e67e22;
        }

        .clip-volume-boost::before {
            content: '🔊';
            position: absolute;
            top: -12px;
            left: 2px;
            font-size: 8px;
        }

        .clip-denoise::before {
            content: '🌫';
            position: absolute;
            top: -12px;
            left: 2px;
            font-size: 8px;
        }

        .clip-frequency::before {
            content: '📊';
            position: absolute;
            top: -12px;
            left: 2px;
            font-size: 8px;
        }

        .clip-speed::before {
            content: '⚡';
            position: absolute;
            top: -12px;
            left: 2px;
            font-size: 8px;
        }

        /* Track states */
        .track-muted {
            opacity: 0.4;
        }

        .track-soloed {
            box-shadow: 0 0 5px #f39c12;
        }

        .track-stereo .track-content {
            height: 50px;
        }

        .track-stereo .track-content::after {
            content: '';
            position: absolute;
            bottom: 5px;
            left: 0;
            right: 0;
            height: 18px;
            background: inherit;
            opacity: 0.6;
            border-radius: 3px;
        }

        /* Drag and drop zones */
        .drop-zone {
            min-height: 30px;
            border: 2px dashed transparent;
            margin: 2px 0;
            transition: all 0.3s ease;
        }

        .drop-zone.drag-over {
            border-color: #1abc9c;
            background: rgba(26, 188, 156, 0.1);
        }

        /* Audio control buttons */
        .audio-control {
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            transition: all 0.2s ease;
            font-size: 12px;
            border: 1px solid transparent;
        }

        .audio-control:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .audio-control.active {
            background: rgba(243, 156, 18, 0.3);
            border-color: #f39c12;
        }

        .audio-control.muted {
            color: #e74c3c;
        }

        .audio-control.soloed {
            color: #f39c12;
            background: rgba(243, 156, 18, 0.2);
        }

        /* Color themes */
        .waveedit .track-layer {
            border-left: 3px solid var(--primary-brown);
        }

        .waveedit .transport-controls {
            border-bottom-color: var(--primary-brown);
        }

        /* Tools Panel States */
        .tools-message {
            color: #888;
            font-size: 14px;
            text-align: center;
            padding: 20px;
            font-style: italic;
            border-bottom: 1px solid #444;
            margin-bottom: 15px;
        }

        .tools-container {
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        /* Selected Clip Display */
        .selected-clip-display {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 12px;
            margin-bottom: 15px;
            display: none;
            box-shadow: var(--shadow-subtle);
        }

        .selected-clip-title {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: bold;
        }

        .selected-clip-name {
            font-weight: bold;
            margin-bottom: 8px;
            color: var(--text-secondary);
            font-size: 14px;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }



        .selected-clip-waveform {
            height: 20px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            position: relative;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }

        .selected-clip-waveform .clip-waveform {
            opacity: 0.7;
        }

        /* Override the selected clip waveform pattern from gradients.css with flat color */
        .selected-clip-waveform::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.2) !important;
            opacity: 1 !important;
            z-index: 0;
        }



        /* Add slider styles */
        .slider-container {
            margin: 8px 0;
            position: relative;
            height: 20px;
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .slider-track {
            position: relative;
            height: 4px;
            background: var(--border-color);
            border-radius: 2px;
            margin: 8px 0;
        }

        .slider-center-mark {
            position: absolute;
            left: 50%;
            top: -2px;
            bottom: -2px;
            width: 1px;
            background: rgba(255, 255, 255, 0.3);
            transform: translateX(-50%);
            pointer-events: none;
        }

        .slider-fill {
            position: absolute;
            height: 100%;
            background: var(--primary-brown);
            border-radius: 2px;
            width: 50%;
            /* Start at center */
            transition: width 0.1s ease;
        }

        .slider-thumb {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #fff;
            border: 2px solid var(--primary-brown);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            transition: all 0.1s ease;
        }

        .slider-thumb:hover {
            transform: translate(-50%, -50%) scale(1.2);
        }

        .plugin-section.disabled .slider-track,
        .plugin-section.disabled .slider-thumb {
            opacity: 0.2;
            pointer-events: none;
            filter: grayscale(1);
        }

        .plugin-section.disabled .slider-labels {
            opacity: 0.3;
            color: var(--text-muted) !important;
        }

        /* Plugin sections */
        .plugin-section {
            margin-bottom: 15px;
            border: 1px solid var(--border-color-light);
            border-radius: 5px;
            padding: 10px;
            background: var(--bg-tertiary);
            cursor: pointer;
            transition: var(--transition-fast);
            position: relative;
        }

        .plugin-section:has(.slider-container) {
            cursor: default;
        }

        .plugin-section:hover:not(.disabled):not(:has(.slider-container)) {
            background: var(--bg-hover);
            border-color: var(--primary-brown);
        }

        .plugin-section.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            pointer-events: none;
            background: var(--bg-darker) !important;
            border-color: var(--border-color) !important;
            filter: grayscale(1);
        }

        .plugin-section.disabled .plugin-title {
            color: var(--text-muted) !important;
            opacity: 0.4;
        }



        .plugin-section.active {
            border-color: var(--primary-brown);
            background: var(--bg-plugin-active);
        }

        .plugin-section.active .plugin-title {
            color: var(--primary-brown);
        }

        .plugin-section.active .checkbox {
            background: var(--primary-brown);
            border-color: var(--primary-brown);
        }

        .plugin-section.active .checkbox::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            line-height: 1;
        }

        .plugin-section.disabled .checkbox {
            opacity: 0.2;
            pointer-events: none;
            background: var(--bg-darker) !important;
            border-color: var(--text-muted) !important;
        }

        .plugin-title {
            font-weight: bold;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .checkbox {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-radius: 3px;
            background: transparent;
        }

        /* Ensure other track layers maintain their original height */
        .track-layer:not(#merged) {
            height: 60px !important;
        }

        .track-layer:not(#merged) .track-content {
            height: 30px !important;
        }

        /* Stem Isolation Loading Animation */
        .stem-isolation-overlay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            pointer-events: none;
        }

        .isolation-progress-container {
            background: var(--bg-secondary);
            border: 2px solid var(--primary-brown);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            text-align: center;
            min-width: 400px;
            backdrop-filter: blur(10px);
        }

        .isolation-title {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary-brown);
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(139, 111, 71, 0.5);
        }

        .isolation-status {
            font-size: 14px;
            color: var(--text-light);
            margin-bottom: 20px;
            min-height: 20px;
            font-style: italic;
        }

        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-brown), var(--primary-brown-dark));
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(139, 111, 71, 0.3);
        }

        .layer-status {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 10px;
        }

        /* MISC layer styles */
        .misc-layer {
            border-left: 3px solid #95a5a6;
        }

        .misc-layer .track-info span:first-child {
            color: #95a5a6;
        }

        /* Hidden small clips in MISC layers */
        .misc-layer .audio-clip.hidden-small {
            background: #444;
            color: #666;
            border: 2px solid #666;
            pointer-events: none;
        }

        .misc-layer .audio-clip.hidden-small::after {
            content: '???';
        }

        /* MISC layer colors */
        .misc-layer .audio-clip {
            color: #95a5a6;
        }

        .misc-layer {
            background: linear-gradient(90deg, rgba(149, 165, 166, 0.15), rgba(149, 165, 166, 0.08));
        }

        /* Merged view colors for MISC clips */
        #merged .audio-clip[data-layer^="misc-"] {
            color: #95a5a6;
        }

        /* MISC clips in merged view (zoom discovery) */
        .misc-clip-hidden {
            background: #444 !important;
            color: #666 !important;
            border: 2px solid #666 !important;
            pointer-events: auto !important;
            z-index: 50 !important;
            position: absolute !important;
        }

        /* Override the data-clip text display for MISC clips */
        .misc-clip-hidden::after {
            content: '???' !important;
        }

        /* Show true name for identified MISC clips */
        .identified::after {
            content: attr(data-clip) !important;
        }

        /* View mode overlay styles */
        .view-mode-overlay {
            position: absolute;
            bottom: 8px;
            left: 8px;
            display: none;
            gap: 4px;
            z-index: 15;
            pointer-events: auto;
        }

        /* Opacity slider styles */
        .opacity-slider-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 8px 12px;
            min-width: 150px;
        }

        .slider-label {
            font-size: 11px;
            color: var(--text-light);
            white-space: nowrap;
            font-weight: bold;
        }

        .opacity-slider {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: linear-gradient(90deg, #f39c12 0%, #9b59b6 100%);
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
        }

        .opacity-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--text-primary);
            border: 2px solid var(--primary-brown);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }

        .opacity-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
        }

        .opacity-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--text-primary);
            border: 2px solid var(--primary-brown);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }

        .opacity-slider::-moz-range-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
        }

        /* Zoom controls styles */
        .zoom-controls {
            position: absolute;
            bottom: 8px;
            right: 8px;
            display: none;
            /* Hidden until stem isolation is complete */
            gap: 4px;
            z-index: 15;
            pointer-events: auto;
        }

        .zoom-controls.enabled {
            display: flex;
        }

        .zoom-btn {
            width: 32px;
            height: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            user-select: none;
        }

        .zoom-btn:hover {
            background: var(--bg-hover);
            border-color: var(--primary-brown);
            transform: translateY(-1px);
        }

        .zoom-btn:active {
            transform: translateY(0px);
        }

        .zoom-btn.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            pointer-events: none;
            background: var(--bg-darker) !important;
            color: var(--text-muted) !important;
            border-color: var(--border-color) !important;
            filter: grayscale(1);
        }

        .zoom-btn.disabled:hover {
            background: var(--bg-darker) !important;
            border-color: var(--border-color) !important;
            transform: none !important;
        }

        .zoom-level-display {
            position: absolute;
            bottom: 32px;
            right: 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 10px;
            color: var(--text-light);
            z-index: 15;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            display: none;
            /* Hidden until stem isolation is complete */
        }

        .zoom-level-display.enabled {
            display: block;
        }

        .zoom-level-display.show {
            opacity: 1;
        }

        /* Pan controls styles */
        .pan-controls {
            position: absolute;
            bottom: 8px;
            right: 80px;
            /* Position to the left of zoom controls */
            display: none;
            /* Hidden until stem isolation is complete */
            gap: 4px;
            z-index: 15;
            pointer-events: auto;
        }

        .pan-controls.enabled {
            display: flex;
        }

        .pan-btn {
            width: 32px;
            height: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            user-select: none;
        }

        .pan-btn:hover {
            background: var(--bg-hover);
            border-color: var(--primary-brown);
            transform: translateY(-1px);
        }

        .pan-btn:active {
            transform: translateY(0px);
        }

        .pan-btn.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            pointer-events: none;
            background: var(--bg-darker) !important;
            color: var(--text-muted) !important;
            border-color: var(--border-color) !important;
            filter: grayscale(1);
        }

        .pan-btn.disabled:hover {
            background: var(--bg-darker) !important;
            border-color: var(--border-color) !important;
            transform: none !important;
        }

        /* Waveform canvas styles */
        .waveform-canvas {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            /* Ensure pixel-perfect alignment with track content below */
            box-sizing: border-box;
        }

        /* Canvas waveform styling */

        /* Ensure perfect alignment between waveform and clips */

        /* Popup styles for ??? clips */
        .clip-popup {
            position: fixed;
            background: var(--bg-secondary);
            border: 2px solid var(--primary-brown);
            border-radius: 8px;
            padding: 15px 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            z-index: 2000;
            color: var(--text-primary);
            font-size: 14px;
            max-width: 300px;
            text-align: center;
            backdrop-filter: blur(10px);
            pointer-events: none;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.2s ease;
        }

        .clip-popup.show {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }

        .clip-popup::before {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid var(--primary-brown);
        }
    </style>
</head>

<body>
    <!-- Landing Screen -->
    <!-- Removed landing screen div -->

    <!-- Assembly App -->
    <!-- Removed Assembly app div -->

    <!-- WaveEdit App -->
    <div id="waveedit" class="app waveedit active">
        <div class="title-bar">
            <div class="title-text">
                🌊 WaveEdit
            </div>
            <div class="window-controls">
                <button class="window-btn minimize">−</button>
                <button class="window-btn maximize">□</button>
                <button class="window-btn close">✕</button>
            </div>
        </div>

        <div class="menu-bar">
            <span class="menu-item load-menu" onclick="toggleLoadMenu(event)">Load ▼
                <div class="load-dropdown" id="load-dropdown">
                    <!-- Demo Level: Viola's First Track -->
                    <div class="load-option" onclick="loadAudioFile('0_viola_first_track_demo.wav', event)">
                        0_viola_first_track_demo.wav</div>

                    <!-- Day 1: Daily Life -->
                    <div class="load-option" onclick="loadAudioFile('1_police_surveillance.wav', event)">
                        1_police_surveillance.wav</div>
                    <div class="load-option" onclick="loadAudioFile('2_mike_evp_debunk.wav', event)">
                        2_mike_evp_debunk.wav</div>

                    <!-- Day 2: Inspiration -->
                    <div class="load-option" onclick="loadAudioFile('3_first_viola_restoration.wav', event)">
                        3_first_viola_restoration.wav</div>
                    <div class="load-option" onclick="loadAudioFile('4_audiophile_forum_test.wav', event)">
                        4_audiophile_forum_test.wav</div>

                    <!-- Day 3: Finding Viola -->
                    <div class="load-option" onclick="loadAudioFile('5_morse_code_test.wav', event)">
                        5_morse_code_test.wav</div>
                    <div class="load-option" onclick="loadAudioFile('6_coordinate_decode.wav', event)">
                        6_coordinate_decode.wav</div>

                    <!-- Day 4: Villa Fossati -->
                    <div class="load-option" onclick="loadAudioFile('7_villa_sound_lock.wav', event)">
                        7_villa_sound_lock.wav</div>
                    <div class="load-option" onclick="loadAudioFile('8_police_evidence_analysis.wav', event)">
                        8_police_evidence_analysis.wav</div>

                    <!-- Day 5: Old Connections -->
                    <div class="load-option" onclick="loadAudioFile('9_viola_death_scene.wav', event)">
                        9_viola_death_scene.wav</div>
                    <div class="load-option" onclick="loadAudioFile('10_vincent_first_composition.wav', event)">
                        10_vincent_first_composition.wav</div>

                    <!-- Day 6: Tape 1/92 -->
                    <div class="load-option" onclick="loadAudioFile('11_viola_spoken_recordings.wav', event)">
                        11_viola_spoken_recordings.wav</div>
                    <div class="load-option" onclick="loadAudioFile('12_giorgio_diagram_recreation.wav', event)">
                        12_giorgio_diagram_recreation.wav</div>

                    <!-- Day 7: Hello Vincent -->
                    <div class="load-option" onclick="loadAudioFile('13_campy_rock_wrongness.wav', event)">
                        13_campy_rock_wrongness.wav</div>
                    <div class="load-option" onclick="loadAudioFile('14_mike_voice_deletion.wav', event)">
                        14_mike_voice_deletion.wav</div>

                    <!-- Day 8: Losing Control -->
                    <div class="load-option" onclick="loadAudioFile('15_entity_multiple_voices.wav', event)">
                        15_entity_multiple_voices.wav</div>

                    <!-- Day 9: Creating the Song -->
                    <div class="load-option" onclick="loadAudioFile('16_viola_imprinted_explanation.wav', event)">
                        16_viola_imprinted_explanation.wav</div>
                    <div class="load-option" onclick="loadAudioFile('17_final_song_creation.wav', event)">
                        17_final_song_creation.wav</div>

                    <!-- Day 10: Final Choice -->
                    <div class="load-option" onclick="loadAudioFile('18_password_memory_dig.wav', event)">
                        18_password_memory_dig.wav</div>
                </div>
            </span>
            <span class="menu-item inactive">Save</span>
            <span class="menu-item inactive">Analyze</span>
            <span class="menu-item inactive">Details</span>
            <span class="menu-item inactive">Plugins</span>
            <span class="menu-item settings-menu" onclick="toggleSettingsMenu(event)">Settings ▼
                <div class="settings-dropdown" id="settings-dropdown">
                    <div class="settings-option" onclick="removeBaseOverlay(); event.stopPropagation()">
                        <span>Remove base layers overlay</span>
                    </div>
                    <div class="settings-option" onclick="removeBaseTracks(); event.stopPropagation()">
                        <span>Remove base layers below</span>
                    </div>
                </div>
            </span>
            <span class="menu-item inactive">Help</span>
            <span class="menu-item inactive">License</span>
        </div>

        <div class="main-content">
            <!-- Left Control Panel -->
            <div class="left-panel">
                <!-- File Status Section -->
                <div class="left-panel-section">
                    <div class="section-header">📁 File Status</div>
                    <div class="section-content">
                        <div class="file-info">
                            <div class="current-file" id="current-file-name">0_viola_first_track_demo.wav</div>
                            <div class="file-stats" id="file-stats">Duration: 00:47.0 • 44.1kHz</div>
                            <div class="file-goal" id="file-goal">Police forensics: clean up surveillance audio from
                                evening bust</div>
                        </div>
                    </div>
                </div>

                <!-- Main Playback Section -->
                <div class="left-panel-section">
                    <div class="section-header">🎵 Main Playback</div>
                    <div class="section-content">
                        <div class="main-playback-simple">
                            <div class="main-time-section">
                                <div class="time-display">00:00.0 / 00:47.0</div>
                                <div class="main-position-bar" onclick="seekToPosition(event)">
                                    <div class="main-position-fill" id="main-position-fill"></div>
                                </div>
                            </div>

                            <div class="main-controls-section">
                                <div class="main-buttons" id="main-buttons">
                                    <button class="transport-btn" onclick="toggleMainPlayback(event)"
                                        disabled>▶</button>
                                    <button class="transport-btn" onclick="stopMainPlayback(event)" disabled>⏹</button>
                                    <button class="transport-btn" onclick="seekToStart(event)" disabled
                                        title="Previous clip (Left arrow)">⏮</button>
                                    <button class="transport-btn" onclick="seekToEnd(event)" disabled
                                        title="Next clip (Right arrow)">⏭</button>
                                </div>

                                <div class="main-loop-container" id="main-loop-container">
                                    <label class="main-loop-label">
                                        <input type="checkbox" id="main-loop-checkbox" disabled>
                                        <span class="loop-text">🔄 Loop</span>
                                    </label>
                                    <label class="main-solo-label">
                                        <input type="checkbox" id="main-solo-checkbox" disabled>
                                        <span class="solo-text">🎯 Clip solo</span>
                                    </label>
                                </div>

                                <div class="playback-disabled-message">
                                    Analyze the track to enable playback
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- VU Meters Section -->
                <div class="left-panel-section">
                    <div class="section-header">📊 VU Meters</div>
                    <div class="vu-meters-container">
                        <div class="vu-meters">
                            <div class="vu-meter vu-meter-large" id="vu-left">
                                <div class="vu-fill"></div>
                                <div class="vu-peak"></div>
                            </div>
                            <div class="vu-meter vu-meter-large" id="vu-right">
                                <div class="vu-fill"></div>
                                <div class="vu-peak"></div>
                            </div>
                        </div>
                        <div class="vu-labels">
                            <div class="vu-label vu-label-large">L</div>
                            <div class="vu-label vu-label-large">R</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="center-panel">
                <div class="timeline-header">
                    <div class="section-header">📈 Timeline View</div>
                    <div class="timeline-instructions">
                        <span class="instruction-item">▶️ <strong>Play/pause:</strong> Space bar</span>
                        <span class="instruction-item">↔️ <strong>Jump to clip:</strong> Arrow keys</span>
                        <span class="instruction-item">🔍 <strong>Zoom:</strong> Mouse wheel</span>
                        <span class="instruction-item">🖐️ <strong>Pan:</strong> Middle mouse</span>
                        <span class="instruction-item">🎯 <strong>Analyze:</strong> Drag box w/ left mouse</span>
                    </div>
                </div>

                <div class="track-layer" id="merged">
                    <div class="track-info">
                        <span style="font-weight: bold; color: #ecf0f1;">Root Layer</span>
                    </div>
                    <div class="track-content"
                        style="background: linear-gradient(90deg, #2c3e50 0%, #2c3e50 100%); position: relative;"
                        onclick="selectClip(event)">
                        <!-- Canvas-based waveform visualization -->
                        <!-- Playback marker -->
                        <div id="playback-marker"
                            style="position: absolute; top: 0; bottom: 0; width: 2px; background: #f39c12; left: 0%; pointer-events: none; z-index: 100;">
                        </div>
                        <!-- Stem Isolation button overlay -->
                        <div class="analyze-overlay">
                            <button class="analyze-btn" onclick="realTimeAnalysis(event)">Analyze Track</button>
                        </div>

                        <!-- View mode opacity slider overlay (hidden initially) -->
                        <div class="view-mode-overlay" id="view-mode-overlay" style="display: none;">
                            <div class="opacity-slider-container">
                                <label for="opacity-slider" class="slider-label">🌈 Spec ↔ 📊 Wave</label>
                                <input type="range" id="opacity-slider" class="opacity-slider" min="0" max="100"
                                    value="50" oninput="updateViewOpacity(this.value)">
                            </div>
                        </div>
                        <!-- Zoom controls -->
                        <div class="zoom-controls">
                            <button class="zoom-btn" onclick="zoomOut(event)"
                                title="Zoom Out (Mouse wheel down)">🔍−</button>
                            <button class="zoom-btn" onclick="zoomIn(event)"
                                title="Zoom In (Mouse wheel up)">🔍+</button>
                        </div>
                        <!-- Pan controls -->
                        <div class="pan-controls">
                            <button class="pan-btn" onclick="panLeft(event)" title="Pan Left (Left arrow)">◀</button>
                            <button class="pan-btn" onclick="panRight(event)" title="Pan Right (Right arrow)">▶</button>
                        </div>
                        <!-- Zoom level display -->
                        <div class="zoom-level-display" id="zoom-level-display">100%</div>
                    </div>
                </div>

                <div class="timeline-header">
                    <div class="section-header">🎵 Separated Layers</div>
                </div>

                <div class="track-layer" id="evidence-recording">
                    <div class="track-info">
                        <span style="font-size: 0.8em; color: #95a5a6;">Layer 1</span><br>
                        <span style="font-weight: bold; color: #ecf0f1;">Evidence_Recording</span>
                    </div>
                    <div class="track-content"
                        style="background: linear-gradient(90deg, #555 0%, #555 100%); position: relative;"
                        onclick="selectClip(event)">
                        <div class="audio-clip" data-clip="initial_scream"
                            style="left: 15%; width: 15%; height: 18px; top: 6px;" title="Initial scream">initial_scream
                        </div>
                        <div class="audio-clip" data-clip="struggle_sounds"
                            style="left: 45%; width: 20%; height: 18px; top: 6px;" title="Struggle sounds">
                            struggle_sounds</div>
                        <div class="audio-clip" data-clip="last_words"
                            style="left: 80%; width: 15%; height: 18px; top: 6px;" title="Last words">last_words</div>
                    </div>

                </div>

                <div class="track-layer" id="ghost-voices">
                    <div class="track-info">
                        <span style="font-size: 0.8em; color: #95a5a6;">Layer 2</span><br>
                        <span style="font-weight: bold; color: #ecf0f1;">Ghost_Voices</span>
                    </div>
                    <div class="track-content"
                        style="background: linear-gradient(90deg, #2c3e50 0%, #2c3e50 100%); position: relative;"
                        onclick="selectClip(event)">
                        <div class="audio-clip" data-clip="whisper_1"
                            style="left: 20%; width: 10%; height: 18px; top: 6px;" title="Second whisper">whisper_1
                        </div>
                        <div class="audio-clip" data-clip="whisper_2"
                            style="left: 35%; width: 10%; height: 18px; top: 6px;" title="Third whisper">whisper_2</div>
                        <div class="audio-clip" data-clip="whisper_3"
                            style="left: 55%; width: 7%; height: 18px; top: 6px;" title="Fourth whisper">whisper_3</div>
                        <div class="audio-clip" data-clip="whisper_4"
                            style="left: 70%; width: 9%; height: 18px; top: 6px;" title="Fifth whisper">whisper_4</div>
                    </div>

                </div>

                <div class="track-layer" id="investigation">
                    <div class="track-info">
                        <span style="font-size: 0.8em; color: #95a5a6;">Layer 3</span><br>
                        <span style="font-weight: bold; color: #ecf0f1;">Investigation_Notes</span>
                    </div>
                    <div class="track-content"
                        style="background: linear-gradient(90deg, #34495e 0%, #34495e 100%); position: relative;"
                        onclick="selectClip(event)">
                        <div class="audio-clip" data-clip="police_report"
                            style="left: 40%; width: 15%; height: 18px; top: 6px;" title="Police recording">
                            police_report</div>
                        <div class="audio-clip" data-clip="witness_statement"
                            style="left: 70%; width: 20%; height: 18px; top: 6px;" title="Witness statement">
                            witness_statement</div>
                    </div>

                </div>

                <div class="track-layer" id="ambient-static-wave">
                    <div class="track-info">
                        <span style="font-size: 0.8em; color: #95a5a6;">Layer 4</span><br>
                        <span style="font-weight: bold; color: #ecf0f1;">Ambient_Static</span>
                    </div>
                    <div class="track-content"
                        style="background: linear-gradient(90deg, #1a1a1a 0%, #1a1a1a 100%); position: relative;"
                        onclick="selectClip(event)">
                        <div class="audio-clip" data-clip="room_tone"
                            style="left: 10%; width: 20%; height: 18px; top: 6px;" title="Room tone">room_tone</div>
                        <div class="audio-clip" data-clip="static_burst"
                            style="left: 35%; width: 20%; height: 18px; top: 6px;" title="Static burst">static_burst
                        </div>
                        <div class="audio-clip" data-clip="tape_hiss"
                            style="left: 70%; width: 25%; height: 18px; top: 6px;" title="Tape hiss">tape_hiss</div>
                    </div>

                </div>
            </div>

            <div class="right-panel">
                <!-- Current Clip Section -->
                <div class="right-panel-section">
                    <div class="section-header">🎯 Current Clip</div>
                    <div class="section-content">
                        <div id="tools-message" class="tools-message">Run Analyze Track to separate audio layers
                            and unlock tools.</div>
                        <div id="selected-clip-display" class="selected-clip-display" style="display: none;">
                            <div class="selected-clip-title">Selected Clip:</div>
                            <div class="selected-clip-name"></div>
                            <div class="selected-clip-waveform">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tools Section -->
                <div class="right-panel-section">
                    <div class="section-header">🛠️ Audio Tools</div>
                    <div class="section-content">
                        <div id="tools-container" class="tools-container" style="display: none;">
                            <!-- Plugins will be generated dynamically -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variable to store current layer configuration
        window.currentLayerConfig = null;

        let selectedPlugin = null;
        let selectedClip = null;
        let draggedClip = null;
        let discoveredClips = new Set();
        let isAnalyzed = false;

        // Loop preferences tracking
        let userLoopPreferences = {
            withClipSelected: null,    // null = no choice made, true/false = user choice
            withoutClipSelected: null  // null = no choice made, true/false = user choice
        };

        // Solo preferences tracking - per clip basis
        let userSoloPreferences = new Map(); // clipId -> boolean (user preference)
        let mergedMiscClips = []; // Track ??? clips in merged view
        let revealedMiscClips = new Set(); // Once revealed, always visible
        let specOnlyMiscClips = new Set(); // MISC clips only visible in Spec view
        let currentPopup = null;

        // Clip focus mode variables
        let clipFocusMode = false;
        let focusedClipStart = 0; // Absolute timeline position
        let focusedClipEnd = 0; // Absolute timeline position

        // Real-time analysis mode variables
        let isAnalyzing = false; // Track if we're in analysis mode
        let analysisStartTime = 0; // When analysis began
        let revealedClips = new Set(); // Track which clips have been revealed
        let revealedLayers = new Set(); // Track which layers are visible
        let analysisPlaybackInterval = null; // Analysis playback timer

        // VU Meter animation
        let vuMeterInterval = null;
        let isMainPlaying = false;
        let vuLeftLevel = 0;
        let vuRightLevel = 0;
        let vuLeftPeak = 0;
        let vuRightPeak = 0;
        let vuLeftPeakHold = 0;
        let vuRightPeakHold = 0;

        // Zoom functionality
        let currentZoom = 1.0; // Current default is min zoom (100%)
        const minZoom = 1.0; // Current default is min (100%)
        const maxZoom = 10.0; // Can zoom in 10x from current (1000%)
        let zoomLevelTimeout = null;
        let waveformOffsetX = 0; // Track horizontal position for zooming
        let waveformCanvas = null;
        let waveformCtx = null;
        let waveformData = []; // Simulated waveform data
        let spectrogramData = []; // 2D spectrogram data [frequency][time]
        let originalClipData = new Map(); // Store original clip positions and sizes
        let zoomEnabled = false; // Track if zoom functionality is enabled

        // View mode state
        let currentViewMode = 'combined'; // Always combined mode with variable opacity
        let waveformOpacity = 0.5; // 0.0 = invisible, 1.0 = fully visible (default 50/50)
        let spectrogramOpacity = 0.5; // 0.0 = invisible, 1.0 = fully visible (default 50/50)
        let viewModePreferences = {}; // Store per-file opacity preferences

        // Manage loop state based on selection and user preferences
        function updateLoopState() {
            const loopCheckbox = document.getElementById('main-loop-checkbox');
            if (!loopCheckbox || loopCheckbox.disabled) return;

            const hasSelection = selectedClip !== null;
            const currentPreference = hasSelection ?
                userLoopPreferences.withClipSelected :
                userLoopPreferences.withoutClipSelected;

            // If user has made a choice for this mode, use it
            if (currentPreference !== null) {
                loopCheckbox.checked = currentPreference;
            } else {
                // No user choice yet, use automatic behavior
                loopCheckbox.checked = hasSelection; // Loop when clip selected, no loop otherwise
            }
        }

        // Manage solo state based on selection and user preferences
        function updateSoloState() {
            const soloCheckbox = document.getElementById('main-solo-checkbox');
            if (!soloCheckbox) return;

            const hasSelection = selectedClip !== null;

            if (hasSelection) {
                // Enable checkbox when clip is selected
                soloCheckbox.disabled = false;

                // Get clip ID and check for user preference
                const clipId = selectedClip.dataset.clip;
                const userPreference = userSoloPreferences.get(clipId);

                // If user has made a choice for this clip, use it; otherwise default to true
                soloCheckbox.checked = userPreference !== undefined ? userPreference : true;
            } else {
                // Disable and uncheck when no clip selected
                soloCheckbox.disabled = true;
                soloCheckbox.checked = false;
            }
        }

        // Track when user manually changes loop checkbox
        function setupLoopPreferenceTracking() {
            const loopCheckbox = document.getElementById('main-loop-checkbox');
            if (!loopCheckbox) return;

            loopCheckbox.addEventListener('change', function () {
                if (this.disabled) return; // Don't track when disabled

                const hasSelection = selectedClip !== null;
                const newState = this.checked;

                // Store user preference for current mode
                if (hasSelection) {
                    userLoopPreferences.withClipSelected = newState;
                } else {
                    userLoopPreferences.withoutClipSelected = newState;
                }
            });
        }

        // Track when user manually changes solo checkbox
        function setupSoloPreferenceTracking() {
            const soloCheckbox = document.getElementById('main-solo-checkbox');
            if (!soloCheckbox) return;

            soloCheckbox.addEventListener('change', function () {
                if (this.disabled || !selectedClip) return; // Don't track when disabled or no selection

                const clipId = selectedClip.dataset.clip;
                const newState = this.checked;

                // Store user preference for this specific clip
                userSoloPreferences.set(clipId, newState);
            });
        }

        // Show popup for ??? clips
        function showClipPopup(event) {
            event.stopPropagation();

            // Remove any existing popup
            if (currentPopup) {
                currentPopup.remove();
                currentPopup = null;
            }

            // Only show popup for hidden ??? clips
            if (!event.target.classList.contains('hidden-small')) {
                return;
            }

            // Create popup
            const popup = document.createElement('div');
            popup.className = 'clip-popup';
            popup.textContent = 'Zoom into the WAV file to find and identify this clip.';

            // Position popup above the clip
            const rect = event.target.getBoundingClientRect();
            popup.style.left = `${rect.left + (rect.width / 2)}px`;
            popup.style.top = `${rect.top - 10}px`;
            popup.style.transform = 'translate(-50%, -100%) scale(0.8)';

            document.body.appendChild(popup);
            currentPopup = popup;

            // Show popup with animation
            requestAnimationFrame(() => {
                popup.classList.add('show');
                popup.style.transform = 'translate(-50%, -100%) scale(1)';
            });

            // Auto-hide after 3 seconds
            setTimeout(() => {
                if (currentPopup === popup) {
                    popup.classList.remove('show');
                    setTimeout(() => {
                        if (currentPopup === popup) {
                            popup.remove();
                            currentPopup = null;
                        }
                    }, 200);
                }
            }, 3000);
        }

        // Close popup when clicking elsewhere
        document.addEventListener('click', function (event) {
            if (currentPopup && !event.target.classList.contains('hidden-small')) {
                currentPopup.classList.remove('show');
                setTimeout(() => {
                    if (currentPopup) {
                        currentPopup.remove();
                        currentPopup = null;
                    }
                }, 200);
            }
        });

        // Generate realistic transients for different audio types
        function generateTransients(filename, length, random) {
            const transients = new Array(length).fill(0);

            const transientPatterns = {
                '0_viola_first_track_demo.wav': [
                    { time: 0.15, type: 'breath_intake', intensity: 0.4 },
                    { time: 0.32, type: 'electrical_pop', intensity: 0.5 },
                    { time: 0.48, type: 'tape_warble', intensity: 0.6 },
                    { time: 0.65, type: 'microphone_handling', intensity: 0.3 },
                    { time: 0.78, type: 'analog_dropout', intensity: 0.4 },
                    { time: 0.85, type: 'static_burst', intensity: 0.7 }
                ],
                '1_police_surveillance.wav': [
                    { time: 0.15, type: 'radio_pop', intensity: 0.6 },
                    { time: 0.35, type: 'static_burst', intensity: 0.4 },
                    { time: 0.65, type: 'footstep', intensity: 0.5 },
                    { time: 0.85, type: 'door_creak', intensity: 0.3 }
                ],
                '2_mike_evp_debunk.wav': [
                    { time: 0.20, type: 'breath_intake', intensity: 0.4 },
                    { time: 0.45, type: 'static_burst', intensity: 0.6 },
                    { time: 0.65, type: 'heating_system', intensity: 0.5 },
                    { time: 0.85, type: 'wind_through_trees', intensity: 0.3 }
                ],
                '3_medium_morse_code.wav': [
                    { time: 0.12, type: 'radio_pop', intensity: 0.7 },
                    { time: 0.45, type: 'static_burst', intensity: 0.8 },
                    { time: 0.67, type: 'carrier_glitch', intensity: 0.5 },
                    { time: 0.85, type: 'radio_pop', intensity: 0.6 }
                ],
                '4_medium_seasonal_birds.wav': [
                    { time: 0.22, type: 'wing_flap', intensity: 0.4 },
                    { time: 0.48, type: 'branch_snap', intensity: 0.6 },
                    { time: 0.73, type: 'bird_alarm', intensity: 0.8 },
                    { time: 0.91, type: 'rustling', intensity: 0.3 }
                ],
                '5_medium_find_the_murderer.wav': [
                    { time: 0.18, type: 'footstep', intensity: 0.5 },
                    { time: 0.41, type: 'door_creak', intensity: 0.7 },
                    { time: 0.59, type: 'glass_break', intensity: 0.9 },
                    { time: 0.78, type: 'metallic_clang', intensity: 0.6 }
                ],
                '6_complex_noise_profiling.wav': [
                    { time: 0.11, type: 'power_surge', intensity: 0.8 },
                    { time: 0.33, type: 'digital_glitch', intensity: 0.6 },
                    { time: 0.56, type: 'motor_start', intensity: 0.7 },
                    { time: 0.79, type: 'electrical_pop', intensity: 0.5 }
                ],
                '7_complex_orchestra_hickups.wav': [
                    { time: 0.21, type: 'string_snap', intensity: 0.8 },
                    { time: 0.44, type: 'bow_scratch', intensity: 0.4 },
                    { time: 0.67, type: 'chair_squeak', intensity: 0.3 },
                    { time: 0.89, type: 'music_stand_bump', intensity: 0.5 }
                ]
            };

            const patterns = transientPatterns[filename] || transientPatterns['0_viola_first_track_demo.wav'];

            patterns.forEach(transient => {
                const startSample = Math.floor(transient.time * length);
                const transientLength = getTransientLength(transient.type);

                for (let i = 0; i < transientLength && startSample + i < length; i++) {
                    const progress = i / transientLength;
                    const envelope = getTransientEnvelope(transient.type, progress);
                    const amplitude = getTransientAmplitude(transient.type, progress, random) * transient.intensity;

                    transients[startSample + i] += amplitude * envelope;
                }
            });

            return transients;
        }

        // Get transient length in samples
        function getTransientLength(type) {
            const lengths = {
                'car_door_slam': 150,
                'engine_rev': 300,
                'tire_screech': 250,
                'breath_intake': 80,
                'consonant_pop': 20,
                'mouth_click': 15,
                'radio_pop': 40,
                'static_burst': 120,
                'carrier_glitch': 60,
                'wing_flap': 35,
                'branch_snap': 25,
                'bird_alarm': 180,
                'rustling': 90,
                'footstep': 50,
                'door_creak': 200,
                'glass_break': 300,
                'metallic_clang': 180,
                'power_surge': 100,
                'digital_glitch': 80,
                'motor_start': 220,
                'electrical_pop': 30,
                'string_snap': 40,
                'bow_scratch': 70,
                'chair_squeak': 60,
                'music_stand_bump': 45,
                'heating_system': 180,
                'wind_through_trees': 120,
                'tape_warble': 90,
                'microphone_handling': 40,
                'analog_dropout': 60
            };
            return lengths[type] || 50;
        }

        // Get transient envelope shape
        function getTransientEnvelope(type, progress) {
            const envelopes = {
                'car_door_slam': Math.exp(-progress * 8) * (1 - progress),
                'engine_rev': Math.sin(progress * Math.PI) * (1 - progress * 0.3),
                'tire_screech': Math.sin(progress * Math.PI * 0.8) * Math.exp(-progress * 2),
                'breath_intake': Math.sin(progress * Math.PI) * 0.6,
                'consonant_pop': Math.exp(-progress * 12),
                'mouth_click': Math.exp(-progress * 15),
                'radio_pop': Math.exp(-progress * 10),
                'static_burst': Math.sin(progress * Math.PI) * (1 - progress * 0.5),
                'carrier_glitch': Math.abs(Math.sin(progress * Math.PI * 4)) * (1 - progress),
                'wing_flap': Math.sin(progress * Math.PI * 2) * (1 - progress),
                'branch_snap': Math.exp(-progress * 6),
                'bird_alarm': Math.sin(progress * Math.PI) * (1 - progress * 0.2),
                'rustling': Math.sin(progress * Math.PI) * 0.7,
                'footstep': Math.exp(-progress * 5) * (1 - progress),
                'door_creak': Math.sin(progress * Math.PI) * (1 - progress * 0.3),
                'glass_break': Math.exp(-progress * 4) * (1 - progress * 0.5),
                'metallic_clang': Math.exp(-progress * 3) * Math.sin(progress * Math.PI * 2),
                'power_surge': Math.sin(progress * Math.PI) * (1 - progress * 0.4),
                'digital_glitch': Math.abs(Math.sin(progress * Math.PI * 8)) * (1 - progress),
                'motor_start': Math.sin(progress * Math.PI) * (1 - progress * 0.2),
                'electrical_pop': Math.exp(-progress * 12),
                'string_snap': Math.exp(-progress * 8) * Math.sin(progress * Math.PI * 3),
                'bow_scratch': Math.sin(progress * Math.PI) * 0.8,
                'chair_squeak': Math.sin(progress * Math.PI) * 0.6,
                'music_stand_bump': Math.exp(-progress * 6),
                'heating_system': Math.sin(progress * Math.PI) * (1 - progress * 0.2),
                'wind_through_trees': Math.sin(progress * Math.PI) * 0.5,
                'tape_warble': Math.sin(progress * Math.PI * 2) * (1 - progress * 0.3),
                'microphone_handling': Math.exp(-progress * 8) * (1 - progress),
                'analog_dropout': Math.exp(-progress * 10) * (1 - progress * 0.5)
            };
            return envelopes[type] || Math.exp(-progress * 5);
        }

        // Get transient amplitude pattern
        function getTransientAmplitude(type, progress, random) {
            const baseAmplitude = 0.6; // Increased from 0.4 for more prominence
            const patterns = {
                'car_door_slam': baseAmplitude * (0.8 + 0.4 * Math.sin(progress * Math.PI * 20)),
                'engine_rev': baseAmplitude * (0.6 + 0.4 * Math.sin(progress * Math.PI * 15)),
                'tire_screech': baseAmplitude * (0.7 + 0.6 * Math.sin(progress * Math.PI * 50)),
                'breath_intake': baseAmplitude * 0.3,
                'consonant_pop': baseAmplitude * (0.9 + 0.2 * (random() - 0.5)),
                'mouth_click': baseAmplitude * 0.4,
                'radio_pop': baseAmplitude * (0.8 + 0.4 * (random() - 0.5)),
                'static_burst': baseAmplitude * (0.6 + 0.8 * (random() - 0.5)),
                'carrier_glitch': baseAmplitude * (0.5 + 0.5 * Math.sin(progress * Math.PI * 12)),
                'wing_flap': baseAmplitude * (0.4 + 0.3 * Math.sin(progress * Math.PI * 8)),
                'branch_snap': baseAmplitude * (0.7 + 0.3 * (random() - 0.5)),
                'bird_alarm': baseAmplitude * (0.8 + 0.4 * Math.sin(progress * Math.PI * 25)),
                'rustling': baseAmplitude * (0.3 + 0.4 * (random() - 0.5)),
                'footstep': baseAmplitude * (0.6 + 0.2 * (random() - 0.5)),
                'door_creak': baseAmplitude * (0.5 + 0.3 * Math.sin(progress * Math.PI * 6)),
                'glass_break': baseAmplitude * (0.9 + 0.2 * (random() - 0.5)),
                'metallic_clang': baseAmplitude * (0.7 + 0.5 * Math.sin(progress * Math.PI * 18)),
                'power_surge': baseAmplitude * (0.8 + 0.4 * Math.sin(progress * Math.PI * 10)),
                'digital_glitch': baseAmplitude * (0.6 + 0.6 * (random() - 0.5)),
                'motor_start': baseAmplitude * (0.7 + 0.3 * Math.sin(progress * Math.PI * 12)),
                'electrical_pop': baseAmplitude * (0.9 + 0.2 * (random() - 0.5)),
                'string_snap': baseAmplitude * (0.8 + 0.4 * Math.sin(progress * Math.PI * 30)),
                'bow_scratch': baseAmplitude * (0.5 + 0.3 * Math.sin(progress * Math.PI * 15)),
                'chair_squeak': baseAmplitude * (0.4 + 0.2 * Math.sin(progress * Math.PI * 8)),
                'music_stand_bump': baseAmplitude * (0.6 + 0.3 * (random() - 0.5)),
                'heating_system': baseAmplitude * (0.4 + 0.2 * Math.sin(progress * Math.PI * 3)),
                'wind_through_trees': baseAmplitude * (0.3 + 0.3 * (random() - 0.5)),
                'tape_warble': baseAmplitude * (0.5 + 0.3 * Math.sin(progress * Math.PI * 6)),
                'microphone_handling': baseAmplitude * (0.6 + 0.2 * (random() - 0.5)),
                'analog_dropout': baseAmplitude * (0.7 + 0.3 * (random() - 0.5))
            };
            return patterns[type] || baseAmplitude * 0.5;
        }

        // Generate realistic waveform data based on filename
        function generateWaveformData(filename, length = 10000) {
            const data = [];

            // Use filename as seed for reproducible randomness
            const seed = hashString(filename);
            let random = seededRandom(seed);

            // Get file-specific characteristics
            const fileParams = getWaveformParams(filename);

            // Generate realistic transients based on file type
            const transients = generateTransients(filename, length, random);

            for (let i = 0; i < length; i++) {
                const t = i / length;
                let amplitude = 0;

                // Dense noise base (much more realistic)
                amplitude += (random() - 0.5) * fileParams.noiseLevel;

                // Multiple frequency components with file-specific characteristics
                for (let freq = 0; freq < fileParams.freqComponents.length; freq++) {
                    const component = fileParams.freqComponents[freq];
                    const phase = component.phase + t * Math.PI * component.frequency;
                    amplitude += Math.sin(phase) * component.amplitude * (0.5 + 0.5 * Math.sin(t * Math.PI * component.modulation));
                }

                // Add file-specific patterns
                if (fileParams.spikes && random() < fileParams.spikeChance) {
                    amplitude += (random() - 0.5) * fileParams.spikeIntensity;
                }

                // Inject realistic transients
                amplitude += transients[i];

                // Envelope shaping
                const envelope = fileParams.envelope(t);
                amplitude *= envelope;

                // Clip to reasonable range
                amplitude = Math.max(-1, Math.min(1, amplitude));

                data.push(amplitude);
            }
            return data;
        }

        // Simple hash function for string
        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            return Math.abs(hash);
        }

        // Seeded random number generator
        function seededRandom(seed) {
            let state = seed;
            return function () {
                state = (state * 1664525 + 1013904223) % Math.pow(2, 32);
                return state / Math.pow(2, 32);
            };
        }

        // Generate realistic spectrogram data based on filename
        function generateSpectrogramData(filename, width = 10000, height = 256) {
            const data = [];

            // Use filename as seed for reproducible randomness
            const seed = hashString(filename);
            let random = seededRandom(seed);

            // Get file-specific spectral characteristics
            const spectralParams = getSpectralParams(filename);

            // Initialize 2D array [frequency][time]
            for (let freq = 0; freq < height; freq++) {
                data[freq] = [];
                for (let time = 0; time < width; time++) {
                    data[freq][time] = 0;
                }
            }

            // Generate frequency content
            for (let time = 0; time < width; time++) {
                const t = time / width;

                // Add base noise floor
                for (let freq = 0; freq < height; freq++) {
                    data[freq][time] = random() * spectralParams.noiseFloor;
                }

                // Add frequency components based on file characteristics
                spectralParams.frequencyBands.forEach(band => {
                    const startFreq = Math.floor((band.freqRange[0] / 20000) * height);
                    const endFreq = Math.floor((band.freqRange[1] / 20000) * height);

                    for (let freq = startFreq; freq < endFreq; freq++) {
                        const freqNorm = endFreq > startFreq ? (freq - startFreq) / (endFreq - startFreq) : 0;
                        const timeVariation = Math.sin(t * Math.PI * band.timeModulation + band.phase);
                        const freqVariation = Math.sin(freqNorm * Math.PI * band.freqModulation);

                        let intensity = band.baseIntensity;
                        intensity *= (0.5 + 0.5 * timeVariation);
                        intensity *= (0.7 + 0.3 * freqVariation);
                        intensity += (random() - 0.5) * band.randomness;

                        data[freq][time] = Math.max(data[freq][time], Math.max(0, Math.min(1, intensity)));
                    }
                });

                // Add transient events
                if (random() < spectralParams.transientChance) {
                    const centerFreq = Math.floor(random() * height);
                    const bandwidth = Math.floor(10 + random() * 30);
                    const intensity = 0.3 + random() * 0.7;

                    for (let f = Math.max(0, centerFreq - bandwidth); f < Math.min(height, centerFreq + bandwidth); f++) {
                        const distance = Math.abs(f - centerFreq);
                        const falloff = Math.max(0, 1 - distance / bandwidth);
                        data[f][time] = Math.max(data[f][time], intensity * falloff);
                    }
                }
            }

            return data;
        }

        // Get spectral parameters for different file types
        function getSpectralParams(filename) {
            const params = {
                '0_viola_first_track_demo.wav': {
                    noiseFloor: 0.04,
                    transientChance: 0.02,
                    frequencyBands: [
                        { freqRange: [80, 400], baseIntensity: 0.5, timeModulation: 2, freqModulation: 4, phase: 0, randomness: 0.1 }, // Vocal fundamentals
                        { freqRange: [400, 2000], baseIntensity: 0.7, timeModulation: 4, freqModulation: 8, phase: 0.5, randomness: 0.12 }, // Vocal presence
                        { freqRange: [2000, 6000], baseIntensity: 0.4, timeModulation: 12, freqModulation: 15, phase: 1.2, randomness: 0.15 }, // Vocal clarity
                        { freqRange: [100, 800], baseIntensity: 0.6, timeModulation: 1, freqModulation: 2, phase: 2.1, randomness: 0.08 }, // Guitar fundamentals
                        { freqRange: [200, 4000], baseIntensity: 0.3, timeModulation: 6, freqModulation: 10, phase: 0.7, randomness: 0.2 }, // Electronics
                        { freqRange: [6000, 16000], baseIntensity: 0.25, timeModulation: 25, freqModulation: 30, phase: 1.8, randomness: 0.25 } // Tape hiss and brightness
                    ]
                },
                '1_simple_getaway_analysis.wav': {
                    noiseFloor: 0.05,
                    transientChance: 0.02,
                    frequencyBands: [
                        { freqRange: [20, 200], baseIntensity: 0.4, timeModulation: 2, freqModulation: 1, phase: 0, randomness: 0.1 }, // Engine rumble
                        { freqRange: [200, 2000], baseIntensity: 0.3, timeModulation: 5, freqModulation: 3, phase: 1.2, randomness: 0.15 }, // Dialogue
                        { freqRange: [2000, 8000], baseIntensity: 0.2, timeModulation: 12, freqModulation: 8, phase: 2.1, randomness: 0.2 }, // Clarity
                        { freqRange: [8000, 20000], baseIntensity: 0.15, timeModulation: 20, freqModulation: 15, phase: 0.5, randomness: 0.25 } // Digital artifacts
                    ]
                },
                '2_mike_evp_debunk.wav': {
                    noiseFloor: 0.04,
                    transientChance: 0.005,
                    frequencyBands: [
                        { freqRange: [80, 300], baseIntensity: 0.2, timeModulation: 1, freqModulation: 2, phase: 0, randomness: 0.05 }, // Fundamental
                        { freqRange: [300, 1500], baseIntensity: 0.6, timeModulation: 3, freqModulation: 5, phase: 0.3, randomness: 0.1 }, // Vocals
                        { freqRange: [1500, 4000], baseIntensity: 0.4, timeModulation: 8, freqModulation: 12, phase: 1.8, randomness: 0.1 }, // Harmonics
                        { freqRange: [4000, 12000], baseIntensity: 0.25, timeModulation: 15, freqModulation: 20, phase: 2.7, randomness: 0.15 } // Brightness
                    ]
                },
                '3_medium_morse_code.wav': {
                    noiseFloor: 0.08,
                    transientChance: 0.04,
                    frequencyBands: [
                        { freqRange: [600, 1000], baseIntensity: 0.8, timeModulation: 16, freqModulation: 0, phase: 0, randomness: 0.1 }, // Carrier tone
                        { freqRange: [1000, 2000], baseIntensity: 0.3, timeModulation: 16, freqModulation: 2, phase: 0.5, randomness: 0.15 }, // Harmonics
                        { freqRange: [50, 500], baseIntensity: 0.3, timeModulation: 0.5, freqModulation: 3, phase: 1.2, randomness: 0.2 }, // Static
                        { freqRange: [5000, 15000], baseIntensity: 0.2, timeModulation: 25, freqModulation: 30, phase: 2.3, randomness: 0.3 } // Radio noise
                    ]
                },
                '4_medium_seasonal_birds.wav': {
                    noiseFloor: 0.06,
                    transientChance: 0.03,
                    frequencyBands: [
                        { freqRange: [100, 800], baseIntensity: 0.3, timeModulation: 2, freqModulation: 4, phase: 0, randomness: 0.2 }, // Forest ambience
                        { freqRange: [1000, 4000], baseIntensity: 0.4, timeModulation: 8, freqModulation: 15, phase: 1.5, randomness: 0.25 }, // Mid-range calls
                        { freqRange: [4000, 12000], baseIntensity: 0.6, timeModulation: 25, freqModulation: 60, phase: 0.8, randomness: 0.3 }, // Bird chirps
                        { freqRange: [12000, 20000], baseIntensity: 0.3, timeModulation: 80, freqModulation: 80, phase: 2.9, randomness: 0.4 } // High-freq details
                    ]
                },
                '5_medium_find_the_murderer.wav': {
                    noiseFloor: 0.1,
                    transientChance: 0.025,
                    frequencyBands: [
                        { freqRange: [20, 150], baseIntensity: 0.3, timeModulation: 1.5, freqModulation: 2, phase: 0, randomness: 0.15 }, // Low rumble
                        { freqRange: [150, 800], baseIntensity: 0.4, timeModulation: 4, freqModulation: 6, phase: 1.1, randomness: 0.2 }, // Mystery tones
                        { freqRange: [800, 3000], baseIntensity: 0.5, timeModulation: 12, freqModulation: 20, phase: 2.3, randomness: 0.25 }, // Evidence sounds
                        { freqRange: [3000, 8000], baseIntensity: 0.35, timeModulation: 28, freqModulation: 45, phase: 0.7, randomness: 0.3 }, // Clarity range
                        { freqRange: [8000, 20000], baseIntensity: 0.25, timeModulation: 120, freqModulation: 120, phase: 1.9, randomness: 0.35 } // Artifacts
                    ]
                },
                '6_complex_noise_profiling.wav': {
                    noiseFloor: 0.15,
                    transientChance: 0.05,
                    frequencyBands: [
                        { freqRange: [20, 500], baseIntensity: 0.4, timeModulation: 3, freqModulation: 6, phase: 0, randomness: 0.3 }, // Low noise
                        { freqRange: [500, 2000], baseIntensity: 0.5, timeModulation: 18, freqModulation: 35, phase: 0.9, randomness: 0.35 }, // Mid noise
                        { freqRange: [2000, 8000], baseIntensity: 0.6, timeModulation: 70, freqModulation: 70, phase: 1.7, randomness: 0.4 }, // High noise
                        { freqRange: [8000, 20000], baseIntensity: 0.3, timeModulation: 150, freqModulation: 150, phase: 2.5, randomness: 0.45 } // Very high noise
                    ]
                },
                '7_complex_orchestra_hickups.wav': {
                    noiseFloor: 0.03,
                    transientChance: 0.015,
                    frequencyBands: [
                        { freqRange: [40, 200], baseIntensity: 0.4, timeModulation: 1, freqModulation: 3, phase: 0, randomness: 0.08 }, // Double bass, cello
                        { freqRange: [200, 800], baseIntensity: 0.5, timeModulation: 8, freqModulation: 20, phase: 0.6, randomness: 0.1 }, // Viola, low strings
                        { freqRange: [800, 3000], baseIntensity: 0.6, timeModulation: 20, freqModulation: 50, phase: 1.9, randomness: 0.12 }, // Violin, woodwinds
                        { freqRange: [3000, 8000], baseIntensity: 0.4, timeModulation: 50, freqModulation: 100, phase: 2.7, randomness: 0.15 }, // Brass, upper harmonics
                        { freqRange: [8000, 20000], baseIntensity: 0.2, timeModulation: 100, freqModulation: 100, phase: 1.3, randomness: 0.2 } // Shimmer, hall acoustics
                    ]
                }
            };

            return params[filename] || params['0_viola_first_track_demo.wav']; // Default fallback
        }

        // Get waveform parameters for different file types
        function getWaveformParams(filename) {
            const params = {
                '0_viola_first_track_demo.wav': {
                    noiseLevel: 0.3,
                    freqComponents: [
                        { frequency: 1, amplitude: 0.4, phase: 0, modulation: 0.8 },
                        { frequency: 6, amplitude: 0.35, phase: 0.5, modulation: 2 },
                        { frequency: 20, amplitude: 0.3, phase: 1.2, modulation: 6 },
                        { frequency: 80, amplitude: 0.25, phase: 2.1, modulation: 15 },
                        { frequency: 320, amplitude: 0.2, phase: 0.7, modulation: 25 }
                    ],
                    spikes: true,
                    spikeChance: 0.02,
                    spikeIntensity: 0.5,
                    envelope: (t) => {
                        // Viola's demo track: Musical structure + vintage analog warmth
                        const songStructure = t < 0.2 ? 0.6 : (t < 0.5 ? 0.8 : (t < 0.8 ? 0.9 : 0.7)); // Verse-Chorus-Verse-Chorus
                        const analogWarmth = 0.7 + 0.2 * Math.sin(t * Math.PI * 1.3); // Tape warmth
                        const voicePresence = 0.6 + 0.4 * Math.sin(t * Math.PI * 4.2); // Vocal prominence
                        const noiseEvents = (t > 0.12 && t < 0.14) || (t > 0.58 && t < 0.6) ? 1.4 : 1; // Tape noise bursts
                        return songStructure * analogWarmth * voicePresence * noiseEvents;
                    }
                },
                '1_police_surveillance.wav': {
                    noiseLevel: 0.4,
                    freqComponents: [
                        { frequency: 2, amplitude: 0.3, phase: 0, modulation: 1 },
                        { frequency: 15, amplitude: 0.2, phase: 1.2, modulation: 3 },
                        { frequency: 80, amplitude: 0.15, phase: 2.1, modulation: 8 },
                        { frequency: 320, amplitude: 0.1, phase: 0.5, modulation: 20 }
                    ],
                    spikes: true,
                    spikeChance: 0.03,
                    spikeIntensity: 0.6,
                    envelope: (t) => {
                        // Getaway analysis: Engine revving + dialog gaps
                        const enginePulse = 0.7 + 0.3 * Math.sin(t * Math.PI * 2.1); // Engine rhythm
                        const speechGaps = Math.max(0.1, Math.sin(t * Math.PI * 8.5) * 0.6 + 0.4); // Speech pauses
                        const carEvents = t > 0.3 && t < 0.35 ? 1.2 : 1; // Car door slam
                        return Math.min(1, enginePulse * speechGaps * carEvents);
                    }
                },
                '2_mike_evp_debunk.wav': {
                    noiseLevel: 0.35,
                    freqComponents: [
                        { frequency: 1, amplitude: 0.4, phase: 0, modulation: 0.5 },
                        { frequency: 8, amplitude: 0.3, phase: 0.3, modulation: 2 },
                        { frequency: 25, amplitude: 0.2, phase: 1.8, modulation: 5 },
                        { frequency: 120, amplitude: 0.15, phase: 2.7, modulation: 12 },
                        { frequency: 480, amplitude: 0.08, phase: 1.1, modulation: 30 }
                    ],
                    spikes: false,
                    envelope: (t) => {
                        // Vocal harmony: Breathing + phrase structure
                        const breathing = 0.3 + 0.7 * Math.sin(t * Math.PI * 1.2); // Natural breathing
                        const phrases = Math.max(0.2, Math.sin(t * Math.PI * 3.8) * 0.6 + 0.4); // Musical phrases
                        const dynamics = 0.8 + 0.2 * Math.sin(t * Math.PI * 0.5); // Overall dynamics
                        return breathing * phrases * dynamics;
                    }
                },
                '3_medium_morse_code.wav': {
                    noiseFloor: 0.35,
                    freqComponents: [
                        { frequency: 12, amplitude: 0.5, phase: 0, modulation: 0 },
                        { frequency: 24, amplitude: 0.3, phase: 0.5, modulation: 0 },
                        { frequency: 180, amplitude: 0.2, phase: 1.2, modulation: 15 },
                        { frequency: 800, amplitude: 0.1, phase: 2.3, modulation: 40 }
                    ],
                    spikes: true,
                    spikeChance: 0.02,
                    spikeIntensity: 0.8,
                    envelope: (t) => {
                        // Morse code: Sharp on/off pulses + static bursts
                        const morsePattern = Math.abs(Math.sin(t * Math.PI * 24)) > 0.6 ? 0.9 : 0.15; // Morse pulses
                        const staticBursts = t > 0.6 && t < 0.65 ? 1.3 : 1; // Static interference
                        const carrierTone = 0.4 + 0.3 * Math.sin(t * Math.PI * 0.8); // Carrier modulation
                        return Math.min(1.2, morsePattern * staticBursts * carrierTone);
                    }
                },
                '4_medium_seasonal_birds.wav': {
                    noiseFloor: 0.45,
                    freqComponents: [
                        { frequency: 3, amplitude: 0.2, phase: 0, modulation: 4 },
                        { frequency: 18, amplitude: 0.25, phase: 1.5, modulation: 8 },
                        { frequency: 75, amplitude: 0.3, phase: 0.8, modulation: 25 },
                        { frequency: 300, amplitude: 0.2, phase: 2.9, modulation: 60 },
                        { frequency: 1200, amplitude: 0.15, phase: 1.7, modulation: 80 }
                    ],
                    spikes: true,
                    spikeChance: 0.04,
                    spikeIntensity: 0.5,
                    envelope: (t) => {
                        // Bird calls: Chirp bursts + forest ambience cycles
                        const birdChirps = Math.sin(t * Math.PI * 12) > 0.4 ? 0.8 + 0.2 * Math.sin(t * Math.PI * 40) : 0.3; // Sharp chirps
                        const forestBreeze = 0.2 + 0.3 * Math.sin(t * Math.PI * 0.6); // Wind through trees
                        const seasonalActivity = 0.6 + 0.4 * Math.sin(t * Math.PI * 2.1); // Seasonal variation
                        return birdChirps * forestBreeze * seasonalActivity;
                    }
                },
                '5_medium_find_the_murderer.wav': {
                    noiseLevel: 0.5,
                    freqComponents: [
                        { frequency: 1.5, amplitude: 0.25, phase: 0, modulation: 2 },
                        { frequency: 6, amplitude: 0.2, phase: 1.1, modulation: 4 },
                        { frequency: 20, amplitude: 0.3, phase: 2.3, modulation: 12 },
                        { frequency: 95, amplitude: 0.25, phase: 0.7, modulation: 28 },
                        { frequency: 380, amplitude: 0.2, phase: 1.9, modulation: 45 },
                        { frequency: 1500, amplitude: 0.1, phase: 2.8, modulation: 120 }
                    ],
                    spikes: true,
                    spikeChance: 0.025,
                    spikeIntensity: 0.7,
                    envelope: (t) => {
                        // Mystery/evidence: Dramatic tension + sudden reveals
                        const tension = 0.4 + 0.3 * Math.sin(t * Math.PI * 1.5); // Building tension
                        const reveals = t > 0.25 && t < 0.3 ? 1.4 : (t > 0.7 && t < 0.75 ? 1.2 : 1); // Evidence reveals
                        const whispers = Math.sin(t * Math.PI * 20) > 0.8 ? 0.6 : 1; // Quiet whisper moments
                        const atmosphericDread = 0.3 + 0.5 * Math.sin(t * Math.PI * 0.4); // Ominous undertone
                        return tension * reveals * whispers * atmosphericDread;
                    }
                },
                '6_complex_noise_profiling.wav': {
                    noiseLevel: 0.6,
                    freqComponents: [
                        { frequency: 4, amplitude: 0.15, phase: 0, modulation: 3 },
                        { frequency: 12, amplitude: 0.2, phase: 0.9, modulation: 6 },
                        { frequency: 35, amplitude: 0.25, phase: 1.7, modulation: 18 },
                        { frequency: 140, amplitude: 0.3, phase: 2.5, modulation: 35 },
                        { frequency: 560, amplitude: 0.2, phase: 0.3, modulation: 70 },
                        { frequency: 2200, amplitude: 0.15, phase: 1.4, modulation: 150 }
                    ],
                    spikes: true,
                    spikeChance: 0.05,
                    spikeIntensity: 0.4,
                    envelope: (t) => {
                        // Complex noise: Variable interference patterns
                        const electricalSurges = 0.5 + 0.4 * Math.sin(t * Math.PI * 4.2); // Power fluctuations
                        const digitalGlitches = Math.sin(t * Math.PI * 15) > 0.7 ? 0.3 : 1; // Digital dropouts
                        const mechanicalNoise = 0.6 + 0.3 * Math.sin(t * Math.PI * 8.7); // Mechanical interference
                        const testToneEvents = t > 0.1 && t < 0.15 ? 1.5 : (t > 0.8 && t < 0.85 ? 1.3 : 1); // Calibration tones
                        return electricalSurges * digitalGlitches * mechanicalNoise * testToneEvents;
                    }
                },
                '7_complex_orchestra_hickups.wav': {
                    noiseLevel: 0.3,
                    freqComponents: [
                        { frequency: 0.8, amplitude: 0.35, phase: 0, modulation: 1 },
                        { frequency: 4, amplitude: 0.3, phase: 0.6, modulation: 3 },
                        { frequency: 16, amplitude: 0.25, phase: 1.9, modulation: 8 },
                        { frequency: 64, amplitude: 0.2, phase: 2.7, modulation: 20 },
                        { frequency: 256, amplitude: 0.15, phase: 1.3, modulation: 50 },
                        { frequency: 1024, amplitude: 0.1, phase: 0.1, modulation: 100 }
                    ],
                    spikes: true,
                    spikeChance: 0.015,
                    spikeIntensity: 0.8,
                    envelope: (t) => {
                        // Orchestra with hiccups: Musical phrases with sudden mistakes
                        const musicalPhrase = 0.7 + 0.2 * Math.sin(t * Math.PI * 1.1); // Natural musical flow
                        const orchestralBuilds = 0.5 + 0.5 * Math.sin(t * Math.PI * 0.3); // Dynamic swells
                        const hiccups = (t > 0.2 && t < 0.22) || (t > 0.55 && t < 0.57) ? 0.1 : 1; // Performance mistakes
                        const recoveries = (t > 0.22 && t < 0.25) || (t > 0.57 && t < 0.6) ? 1.3 : 1; // Post-mistake emphasis
                        return Math.min(1.2, musicalPhrase * orchestralBuilds * hiccups * recoveries);
                    }
                }
            };

            return params[filename] || params['0_viola_first_track_demo.wav']; // Default fallback
        }

        // Map intensity value to RGB color (traditional spectrogram colors)
        function intensityToColor(intensity) {
            // Clamp intensity to 0-1 range
            intensity = Math.max(0, Math.min(1, intensity));

            // Traditional spectrogram color mapping: Black -> Blue -> Green -> Yellow -> Red -> White
            if (intensity < 0.2) {
                // Black to Blue
                const t = intensity / 0.2;
                return [0, 0, Math.floor(t * 128)];
            } else if (intensity < 0.4) {
                // Blue to Green
                const t = (intensity - 0.2) / 0.2;
                return [0, Math.floor(t * 255), 128 - Math.floor(t * 128)];
            } else if (intensity < 0.6) {
                // Green to Yellow
                const t = (intensity - 0.4) / 0.2;
                return [Math.floor(t * 255), 255, 0];
            } else if (intensity < 0.8) {
                // Yellow to Red
                const t = (intensity - 0.6) / 0.2;
                return [255, 255 - Math.floor(t * 255), 0];
            } else {
                // Red to White
                const t = (intensity - 0.8) / 0.2;
                return [255, Math.floor(t * 255), Math.floor(t * 255)];
            }
        }

        // Draw visualization based on current mode
        function drawVisualization() {
            if (!waveformCanvas || !waveformCtx) return;

            const width = waveformCanvas.width;
            const height = waveformCanvas.height;

            // Clear canvas
            waveformCtx.clearRect(0, 0, width, height);

            // Always draw combined mode with variable opacity
            drawCombinedModeWithOpacity(width, height);
        }

        // Draw waveform mode
        function drawWaveformMode(width, height) {
            const centerY = height / 2;

            // Calculate visible range: fewer samples = more zoom (matches spectrogram logic)
            const waveformWidth = waveformData.length; // 10,000 samples
            const visibleSamples = waveformWidth / currentZoom;
            const maxStartSample = Math.max(0, waveformWidth - visibleSamples);
            const startSample = Math.floor(waveformOffsetX * maxStartSample);
            const endSample = Math.min(waveformWidth, startSample + visibleSamples);

            // Calculate revelation limit during analysis mode
            let revealLimit = width; // Default: show full waveform
            if (isAnalyzing) {
                // During analysis, only show waveform up to current playhead position
                const currentProgress = currentTime / totalDuration;
                revealLimit = width * currentProgress;
            }

            // Set waveform style
            waveformCtx.strokeStyle = getCurrentWaveformColor();
            waveformCtx.lineWidth = 2; // Increased from 1 for better visibility
            waveformCtx.beginPath();

            for (let x = 0; x < width && x <= revealLimit; x++) {
                // Map canvas X to waveform position within visible range
                const timeProgress = x / width;
                const sampleIndex = Math.floor(startSample + timeProgress * (endSample - startSample));

                if (sampleIndex >= 0 && sampleIndex < waveformWidth) {
                    const amplitude = waveformData[sampleIndex];
                    const y = centerY + amplitude * (centerY - 5); // Leave 5px margin top/bottom

                    if (x === 0) {
                        waveformCtx.moveTo(x, y);
                    } else {
                        waveformCtx.lineTo(x, y);
                    }
                }
            }

            waveformCtx.stroke();

            // Note: Alignment markers now handled in drawCombinedModeWithOpacity
        }

        // Draw spectrogram mode
        function drawSpectrogramMode(width, height) {
            if (spectrogramData.length === 0) return;

            // Create ImageData for pixel manipulation
            const imageData = waveformCtx.createImageData(width, height);
            const data = imageData.data;

            // Calculate which portion of spectrogram to show based on zoom
            const spectrogramWidth = spectrogramData[0].length; // 10,000 samples
            const spectrogramHeight = spectrogramData.length;   // 256 frequency bins

            // Calculate visible range: fewer samples = more zoom
            const visibleSamples = spectrogramWidth / currentZoom;
            const maxStartSample = Math.max(0, spectrogramWidth - visibleSamples);
            const startSample = Math.floor(waveformOffsetX * maxStartSample);
            const endSample = Math.min(spectrogramWidth, startSample + visibleSamples);

            // Calculate revelation limit during analysis mode
            let revealLimit = width; // Default: show full spectrogram
            if (isAnalyzing) {
                // During analysis, only show spectrogram up to current playhead position
                const currentProgress = currentTime / totalDuration;
                revealLimit = width * currentProgress;
            }

            // Render each pixel
            for (let x = 0; x < width && x <= revealLimit; x++) {
                // Map canvas X to spectrogram time position within visible range
                const timeProgress = x / width;
                const spectrogramX = Math.floor(startSample + timeProgress * (endSample - startSample));

                if (spectrogramX >= 0 && spectrogramX < spectrogramWidth) {
                    for (let y = 0; y < height; y++) {
                        // Map canvas Y to spectrogram frequency (flip Y axis)
                        const spectrogramY = Math.floor(((height - 1 - y) / height) * spectrogramHeight);

                        if (spectrogramY >= 0 && spectrogramY < spectrogramHeight) {
                            const intensity = spectrogramData[spectrogramY][spectrogramX];
                            const [r, g, b] = intensityToColor(intensity);

                            const pixelIndex = (y * width + x) * 4;
                            data[pixelIndex] = r;     // Red
                            data[pixelIndex + 1] = g; // Green
                            data[pixelIndex + 2] = b; // Blue
                            data[pixelIndex + 3] = 255; // Alpha
                        }
                    }
                }
            }

            // Draw the image data to canvas
            waveformCtx.putImageData(imageData, 0, 0);

            // Draw subtle alignment markers at key percentages (for spectrogram mode too)
            waveformCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            waveformCtx.lineWidth = 1;

            // 15% mark (where first clip often starts)
            const mark15 = width * 0.15;
            waveformCtx.beginPath();
            waveformCtx.moveTo(mark15, 0);
            waveformCtx.lineTo(mark15, height);
            waveformCtx.stroke();

            // 50% mark (center reference)
            const mark50 = width * 0.5;
            waveformCtx.beginPath();
            waveformCtx.moveTo(mark50, 0);
            waveformCtx.lineTo(mark50, height);
            waveformCtx.stroke();
        }

        // Draw combined mode with variable opacity (spectrogram + waveform)
        function drawCombinedModeWithOpacity(width, height) {
            // Calculate revelation limit during analysis mode
            let revealLimit = width; // Default: show full combined view
            if (isAnalyzing) {
                // During analysis, only show up to current playhead position
                const currentProgress = currentTime / totalDuration;
                revealLimit = width * currentProgress;
            }

            // Draw spectrogram as background if it has opacity
            if (spectrogramData.length > 0 && spectrogramOpacity > 0) {
                const imageData = waveformCtx.createImageData(width, height);
                const data = imageData.data;

                const spectrogramWidth = spectrogramData[0].length;
                const spectrogramHeight = spectrogramData.length;

                // Calculate visible range
                const visibleSamples = spectrogramWidth / currentZoom;
                const maxStartSample = Math.max(0, spectrogramWidth - visibleSamples);
                const startSample = Math.floor(waveformOffsetX * maxStartSample);
                const endSample = Math.min(spectrogramWidth, startSample + visibleSamples);

                // Render spectrogram pixels with opacity
                for (let x = 0; x < width && x <= revealLimit; x++) {
                    const timeProgress = x / width;
                    const spectrogramX = Math.floor(startSample + timeProgress * (endSample - startSample));

                    if (spectrogramX >= 0 && spectrogramX < spectrogramWidth) {
                        for (let y = 0; y < height; y++) {
                            const spectrogramY = Math.floor(((height - 1 - y) / height) * spectrogramHeight);

                            if (spectrogramY >= 0 && spectrogramY < spectrogramHeight) {
                                const intensity = spectrogramData[spectrogramY][spectrogramX];
                                const [r, g, b] = intensityToColor(intensity);

                                const pixelIndex = (y * width + x) * 4;
                                // Apply spectrogram opacity
                                data[pixelIndex] = Math.floor(r * spectrogramOpacity);
                                data[pixelIndex + 1] = Math.floor(g * spectrogramOpacity);
                                data[pixelIndex + 2] = Math.floor(b * spectrogramOpacity);
                                data[pixelIndex + 3] = Math.floor(255 * spectrogramOpacity);
                            }
                        }
                    }
                }

                waveformCtx.putImageData(imageData, 0, 0);
            }

            // Draw waveform overlay if it has opacity
            if (waveformOpacity > 0) {
                const centerY = height / 2;
                const waveformHeight = height * 0.8; // Use 80% of height for waveform when overlaid

                const waveformWidth = waveformData.length;
                const visibleSamples = waveformWidth / currentZoom;
                const maxStartSample = Math.max(0, waveformWidth - visibleSamples);
                const startSample = Math.floor(waveformOffsetX * maxStartSample);
                const endSample = Math.min(waveformWidth, startSample + visibleSamples);

                // Set waveform style with opacity
                const waveformColor = getCurrentWaveformColor();
                const colorMatch = waveformColor.match(/^#([0-9a-f]{6})$/i);
                if (colorMatch) {
                    const r = parseInt(colorMatch[1].substr(0, 2), 16);
                    const g = parseInt(colorMatch[1].substr(2, 2), 16);
                    const b = parseInt(colorMatch[1].substr(4, 2), 16);
                    waveformCtx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${waveformOpacity})`;
                } else {
                    waveformCtx.strokeStyle = waveformColor;
                }

                waveformCtx.lineWidth = 3; // Thicker line for better visibility
                waveformCtx.beginPath();

                for (let x = 0; x < width && x <= revealLimit; x++) {
                    const timeProgress = x / width;
                    const sampleIndex = Math.floor(startSample + timeProgress * (endSample - startSample));

                    if (sampleIndex >= 0 && sampleIndex < waveformWidth) {
                        const amplitude = waveformData[sampleIndex];
                        const y = centerY + amplitude * (waveformHeight / 2);

                        if (x === 0) {
                            waveformCtx.moveTo(x, y);
                        } else {
                            waveformCtx.lineTo(x, y);
                        }
                    }
                }

                waveformCtx.stroke();
            }

            // Draw alignment markers (visible if either layer has opacity)
            if (waveformOpacity > 0 || spectrogramOpacity > 0) {
                waveformCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                waveformCtx.lineWidth = 1;

                const mark15 = width * 0.15;
                waveformCtx.beginPath();
                waveformCtx.moveTo(mark15, 0);
                waveformCtx.lineTo(mark15, height);
                waveformCtx.stroke();

                const mark50 = width * 0.5;
                waveformCtx.beginPath();
                waveformCtx.moveTo(mark50, 0);
                waveformCtx.lineTo(mark50, height);
                waveformCtx.stroke();
            }
        }

        // Get current waveform color based on loaded file
        function getCurrentWaveformColor() {
            // Colors matching the main gradient themes
            const colors = {
                '1_simple_getaway_analysis.wav': '#e74c3c',
                '2_simple_vocal_harmony.wav': '#e67e22',
                '3_medium_morse_code.wav': '#3498db',
                '4_medium_seasonal_birds.wav': '#27ae60',
                '5_medium_find_the_murderer.wav': '#9b59b6',
                '6_complex_noise_profiling.wav': '#f39c12',
                '7_complex_orchestra_hickups.wav': '#e74c3c'
            };

            const currentFile = document.querySelector('#merged .track-info span:first-child')?.textContent;
            return colors[currentFile] || '#9b59b6';
        }

        // Zoom functionality
        function updateZoom(targetX = null) {
            // Adjust offset position to keep target point in view
            if (targetX !== null && waveformCanvas) {
                const containerWidth = waveformCanvas.width;
                const targetPercent = targetX / containerWidth;

                // Calculate new offset to keep target centered
                const maxOffset = 1 - (1 / currentZoom);
                waveformOffsetX = targetPercent * maxOffset;
                waveformOffsetX = Math.max(0, Math.min(maxOffset, waveformOffsetX));
            }

            // Redraw visualization and update clip positions in the same frame
            requestAnimationFrame(() => {
                drawVisualization();
                updateClipPositions();
                updateClipFocusVisuals(); // Update clip focus overlays and lines after zoom
            });

            // Update zoom level display
            const zoomDisplay = document.getElementById('zoom-level-display');
            if (zoomDisplay) {
                const percentage = Math.round(100 * currentZoom);
                zoomDisplay.textContent = `${percentage}%`;
                zoomDisplay.classList.add('show');

                // Hide after 2 seconds
                clearTimeout(zoomLevelTimeout);
                zoomLevelTimeout = setTimeout(() => {
                    zoomDisplay.classList.remove('show');
                }, 2000);
            }

            // Update button states
            updateZoomButtons();
        }

        function updateZoomButtons() {
            const zoomInBtn = document.querySelector('.zoom-btn[onclick*="zoomIn"]');
            const zoomOutBtn = document.querySelector('.zoom-btn[onclick*="zoomOut"]');

            if (zoomInBtn) {
                // Disable zoom in if zoom is disabled or at/near max zoom
                const atMaxZoom = currentZoom >= maxZoom || Math.abs(currentZoom - maxZoom) < 0.01;
                zoomInBtn.classList.toggle('disabled', !zoomEnabled || atMaxZoom);
            }
            if (zoomOutBtn) {
                // Disable zoom out if zoom is disabled or at/near min zoom
                const atMinZoom = currentZoom <= minZoom || Math.abs(currentZoom - minZoom) < 0.01;
                zoomOutBtn.classList.toggle('disabled', !zoomEnabled || atMinZoom);
            }

            // Also update pan buttons
            updatePanButtons();
        }

        // Enable zoom functionality and show controls
        function enableZoomControls() {
            zoomEnabled = true;

            // Show zoom controls
            const zoomControls = document.querySelector('.zoom-controls');
            const zoomDisplay = document.getElementById('zoom-level-display');
            const panControls = document.querySelector('.pan-controls');

            if (zoomControls) {
                zoomControls.classList.add('enabled');
            }
            if (zoomDisplay) {
                zoomDisplay.classList.add('enabled');
            }
            if (panControls) {
                panControls.classList.add('enabled');
            }

            // Update button states
            updateZoomButtons();
        }

        function zoomIn(event) {
            event.stopPropagation();
            if (!zoomEnabled || currentZoom >= maxZoom) return;

            currentZoom = Math.min(maxZoom, currentZoom * 1.25);
            // Zoom to center for button clicks
            const container = document.querySelector('#merged .track-content');
            const centerX = container ? container.offsetWidth / 2 : 0;
            updateZoom(centerX);
        }

        function zoomOut(event) {
            event.stopPropagation();
            if (!zoomEnabled || currentZoom <= minZoom) return;

            currentZoom = Math.max(minZoom, currentZoom / 1.25);
            // Zoom to center for button clicks
            const container = document.querySelector('#merged .track-content');
            const centerX = container ? container.offsetWidth / 2 : 0;
            updateZoom(centerX);
        }

        // Pan functionality
        function panLeft(event) {
            event.stopPropagation();
            if (!zoomEnabled || currentZoom <= minZoom) return;

            const panAmount = 0.1 / currentZoom; // Smaller steps when more zoomed in
            const maxOffset = 1 - (1 / currentZoom);
            waveformOffsetX = Math.max(0, waveformOffsetX - panAmount);

            updateVisualizationAndClips();
            updatePanButtons();
        }

        function panRight(event) {
            event.stopPropagation();
            if (!zoomEnabled || currentZoom <= minZoom) return;

            const panAmount = 0.1 / currentZoom; // Smaller steps when more zoomed in
            const maxOffset = 1 - (1 / currentZoom);
            waveformOffsetX = Math.min(maxOffset, waveformOffsetX + panAmount);

            updateVisualizationAndClips();
            updatePanButtons();
        }

        function updateVisualizationAndClips() {
            // Use requestAnimationFrame to ensure both updates happen in the same frame
            requestAnimationFrame(() => {
                drawVisualization();
                updateClipPositions();
                updateClipFocusVisuals(); // Update clip focus overlays and lines after zoom/pan
            });
        }

        function updatePanButtons() {
            const panLeftBtn = document.querySelector('.pan-btn[onclick*="panLeft"]');
            const panRightBtn = document.querySelector('.pan-btn[onclick*="panRight"]');
            const maxOffset = 1 - (1 / currentZoom);

            if (panLeftBtn) {
                // Disable pan left if zoom is disabled, at min zoom (no need to pan), or already at left edge
                const atMinZoom = currentZoom <= minZoom || Math.abs(currentZoom - minZoom) < 0.01;
                const atLeftEdge = waveformOffsetX <= 0 || Math.abs(waveformOffsetX) < 0.001;
                panLeftBtn.classList.toggle('disabled', !zoomEnabled || atMinZoom || atLeftEdge);
            }
            if (panRightBtn) {
                // Disable pan right if zoom is disabled, at min zoom (no need to pan), or already at right edge
                const atMinZoom = currentZoom <= minZoom || Math.abs(currentZoom - minZoom) < 0.01;
                const atRightEdge = waveformOffsetX >= maxOffset || Math.abs(waveformOffsetX - maxOffset) < 0.001;
                panRightBtn.classList.toggle('disabled', !zoomEnabled || atMinZoom || atRightEdge);
            }
        }

        // Store original clip positions and sizes for zoom calculations
        function storeOriginalClipData() {
            originalClipData.clear();

            // Store data for all visible clips in merged view (including MISC clips)
            const mergedClips = document.querySelectorAll('#merged .audio-clip');
            mergedClips.forEach(clip => {
                const left = parseFloat(clip.style.left.replace('%', ''));
                const width = parseFloat(clip.style.width.replace('%', ''));
                const clipId = clip.dataset.clip;

                originalClipData.set(clipId, {
                    left: left,
                    width: width,
                    element: clip
                });
            });

            // Store data for MISC clips (including hidden ones)
            mergedMiscClips.forEach(miscClip => {
                const left = parseFloat(miscClip.originalLeft.replace('%', ''));
                const width = parseFloat(miscClip.originalWidth.replace('%', ''));

                originalClipData.set(miscClip.clipId, {
                    left: left,
                    width: width,
                    element: miscClip.element
                });
            });
        }

        // Update view opacity based on slider value
        function updateViewOpacity(sliderValue) {
            // Convert slider value (0-100) to opacity values
            // 0 = full spectrogram, 100 = full waveform
            const normalizedValue = sliderValue / 100;

            waveformOpacity = normalizedValue;
            spectrogramOpacity = 1.0 - normalizedValue;

            // Store preference for current file
            const currentFile = document.querySelector('#merged .track-info span:first-child')?.textContent;
            if (currentFile) {
                viewModePreferences[currentFile] = sliderValue;
            }

            // Update MISC clip visibility for view mode change
            updateMiscClipVisibility();

            // Synchronize visualization and clip updates for view mode switch
            requestAnimationFrame(() => {
                drawVisualization();
                updateClipPositions();
                updateClipFocusVisuals(); // Update clip focus overlays and lines after view mode change
            });
        }

        // Update clip positions and sizes based on current zoom level
        function updateClipPositions() {
            if (originalClipData.size === 0) return;

            const mergedTrack = document.querySelector('#merged .track-content');
            if (!mergedTrack) return;

            // Calculate visible range in original coordinates (0-100%)
            const visibleStart = waveformOffsetX * 100;
            const visibleEnd = visibleStart + (100 / currentZoom);

            originalClipData.forEach((originalData, clipId) => {
                const clip = originalData.element;
                if (!clip) return;

                // Check if this is a MISC clip
                const isMiscClip = clip.classList.contains('misc-clip-hidden');

                // Calculate original clip boundaries
                const originalLeft = originalData.left;
                const originalRight = originalData.left + originalData.width;

                // Check if clip is visible in current zoom view
                const isInViewport = !(originalRight < visibleStart || originalLeft > visibleEnd);

                if (!isInViewport) {
                    // Clip is completely outside visible area - hide all clips regardless of type
                    clip.style.display = 'none';
                    return;
                }

                // Clip is at least partially visible in viewport
                if (isMiscClip) {
                    // For MISC clips, only show if already revealed
                    if (revealedMiscClips.has(clipId)) {
                        clip.style.display = 'flex';
                    } else {
                        clip.style.display = 'none';
                    }
                } else {
                    // Regular clips show normally when in viewport
                    clip.style.display = 'flex';
                }

                // Calculate new position and size
                // Convert from original coordinates to zoomed coordinates
                const newLeft = ((originalLeft - visibleStart) / (100 / currentZoom)) * 100;
                const newWidth = (originalData.width / (100 / currentZoom)) * 100;

                // Clamp to visible boundaries
                const clampedLeft = Math.max(0, newLeft);
                const clampedRight = Math.min(100, newLeft + newWidth);
                const clampedWidth = clampedRight - clampedLeft;

                // Apply new position and size
                clip.style.left = `${clampedLeft}%`;
                clip.style.width = `${clampedWidth}%`;

                // Fade out clips that are partially visible at edges
                if (clampedLeft <= 1 || clampedRight >= 99) {
                    clip.style.opacity = '0.6';
                } else {
                    clip.style.opacity = '';
                }
            });

            // Update MISC clip visibility
            updateMiscClipVisibility();
        }

        // Initialize waveform canvas
        function initializeWaveformCanvas() {
            const mergedTrack = document.querySelector('#merged .track-content');
            if (!mergedTrack) return;

            // Create canvas element
            waveformCanvas = document.createElement('canvas');
            waveformCanvas.className = 'waveform-canvas';
            mergedTrack.appendChild(waveformCanvas);

            // Get 2D context
            waveformCtx = waveformCanvas.getContext('2d');

            // Set canvas size to match container exactly
            function resizeCanvas() {
                const rect = mergedTrack.getBoundingClientRect();
                waveformCanvas.width = rect.width;
                waveformCanvas.height = rect.height;
                drawVisualization();
            }

            // Initial resize and setup
            resizeCanvas();

            // Handle window resize
            window.addEventListener('resize', resizeCanvas);

            // Canvas is now the primary waveform display

            // Generate waveform data based on current file
            const currentFile = document.querySelector('#merged .track-info span:first-child')?.textContent || '5_medium_find_the_murderer.wav';
            waveformData = generateWaveformData(currentFile, 10000);
            spectrogramData = generateSpectrogramData(currentFile);
            drawVisualization();
        }

        // Mouse wheel zoom functionality
        function initializeZoomControls() {
            const mergedTrack = document.querySelector('#merged .track-content');
            if (mergedTrack) {
                mergedTrack.addEventListener('wheel', function (event) {
                    // Only prevent default and zoom if zoom is enabled
                    if (!zoomEnabled) return;

                    event.preventDefault();

                    // Get mouse X position relative to the container
                    const rect = mergedTrack.getBoundingClientRect();
                    const mouseX = event.clientX - rect.left;

                    if (event.deltaY < 0) {
                        // Scroll up = zoom in
                        if (currentZoom >= maxZoom) return;
                        currentZoom = Math.min(maxZoom, currentZoom * 1.25);
                        updateZoom(mouseX);
                    } else {
                        // Scroll down = zoom out
                        if (currentZoom <= minZoom) return;
                        currentZoom = Math.max(minZoom, currentZoom / 1.25);
                        updateZoom(mouseX);
                    }
                });

                // Add box drawing for MISC clip identification
                mergedTrack.addEventListener('mousedown', startMiscClipIdentification);
                mergedTrack.addEventListener('mousemove', updateMiscClipIdentification);
                mergedTrack.addEventListener('mouseup', endMiscClipIdentification);
            }

            // Initialize button states
            updateZoomButtons();

            // Add keyboard event listeners for arrow key panning
            document.addEventListener('keydown', handleKeyboardPanning);

            // Add middle mouse drag for panning
            if (mergedTrack) {
                mergedTrack.addEventListener('mousedown', handleMiddleMouseDown);
                document.addEventListener('mousemove', handleMiddleMouseMove);
                document.addEventListener('mouseup', handleMiddleMouseUp);
            }
        }

        // Variables for middle mouse dragging
        let isDragging = false;
        let dragStartX = 0;
        let dragStartOffset = 0;

        // Keyboard controls for playback and clip navigation
        function handleKeyboardPanning(event) {
            // Don't allow any keyboard controls during analysis
            if (isAnalyzing) {
                return;
            }

            // Handle spacebar for play/pause
            if (event.key === ' ' || event.key === 'Space') {
                event.preventDefault();
                // Find the play button and simulate click
                const playBtn = document.querySelector('#main-buttons .transport-btn:first-child');
                if (playBtn && !playBtn.disabled) {
                    toggleMainPlayback({ target: playBtn, stopPropagation: () => { } });
                }
                return;
            }

            // Handle left/right arrows for clip navigation
            if (event.key === 'ArrowLeft') {
                event.preventDefault();
                jumpToClip('left');
            } else if (event.key === 'ArrowRight') {
                event.preventDefault();
                jumpToClip('right');
            }
        }

        // Jump to the beginning of the next selectable clip in the specified direction
        function jumpToClip(direction) {
            // Get all selectable clips from the merged track (excluding ??? and unidentified clips)
            const clips = Array.from(document.querySelectorAll('#merged .audio-clip')).filter(clip => {
                // Exclude hidden-small clips (???)
                if (clip.classList.contains('hidden-small')) return false;

                // Exclude unidentified MISC clips
                if (clip.classList.contains('misc-clip-hidden') && !clip.classList.contains('identified')) return false;

                return true;
            });

            if (clips.length === 0) return;

            // Get clip positions as percentages and sort them
            const clipPositions = clips.map(clip => {
                const left = parseFloat(clip.style.left.replace('%', ''));
                return {
                    element: clip,
                    left: left,
                    timePosition: (left / 100) * totalDuration
                };
            }).sort((a, b) => a.left - b.left);

            let targetClip = null;
            let referenceTimePosition = currentTime;

            // If a clip is selected, use its position as reference
            if (selectedClip) {
                const currentClipLeft = parseFloat(selectedClip.style.left.replace('%', ''));
                referenceTimePosition = (currentClipLeft / 100) * totalDuration;
            }

            if (direction === 'left') {
                // Find the closest selectable clip to the left of reference position
                for (let i = clipPositions.length - 1; i >= 0; i--) {
                    if (clipPositions[i].timePosition < referenceTimePosition - 0.1) { // Small tolerance
                        targetClip = clipPositions[i];
                        break;
                    }
                }
                // If no clip found to the left, go to the beginning (0:00) or leftmost clip
                if (targetClip === null) {
                    if (selectedClip) {
                        // If clip is selected, select the leftmost clip
                        if (clipPositions.length > 0) {
                            targetClip = clipPositions[0];
                        }
                    } else {
                        // If no clip selected, just go to beginning
                        currentTime = 0;
                        updateTimeDisplay();
                        updatePlaybackMarker();
                        return;
                    }
                }
            } else if (direction === 'right') {
                // Find the closest selectable clip to the right of reference position
                for (let i = 0; i < clipPositions.length; i++) {
                    if (clipPositions[i].timePosition > referenceTimePosition + 0.1) { // Small tolerance
                        targetClip = clipPositions[i];
                        break;
                    }
                }
                // If no clip found to the right, don't move
                if (targetClip === null) {
                    return;
                }
            }

            // Update time position to beginning of target clip
            if (targetClip !== null) {
                currentTime = targetClip.timePosition;
                updateTimeDisplay();
                updatePlaybackMarker();

                // If a clip was selected, update the selection to the target clip
                if (selectedClip) {
                    // Remove selection from current clip
                    selectedClip.classList.remove('selected');

                    // Select the target clip
                    targetClip.element.classList.add('selected');
                    selectedClip = targetClip.element;

                    // Update selected clip display
                    const selectedClipDisplay = document.getElementById('selected-clip-display');
                    const selectedClipName = selectedClipDisplay.querySelector('.selected-clip-name');
                    const selectedClipWaveform = selectedClipDisplay.querySelector('.selected-clip-waveform');

                    selectedClipName.textContent = selectedClip.dataset.clip;

                    // Get the correct color based on the clip's layer
                    const clipLayerId = selectedClip.closest('.track-layer').id;
                    const clipColor = getClipColorByLayer(clipLayerId);
                    selectedClipWaveform.style.background = `linear-gradient(90deg, ${clipColor}22 0%, ${clipColor}11 100%)`;
                    selectedClipWaveform.style.color = clipColor;

                    // Apply waveform to selected clip display
                    applyWaveformToClip(selectedClipWaveform);

                    // Update clip focus mode if active
                    if (clipFocusMode) {
                        exitClipFocusMode();
                        enterClipFocusMode(selectedClip);
                    }

                    // Update tools for the new selection
                    const clipId = selectedClip.dataset.clip;
                    const activeEffects = clipEffects.get(clipId) || new Set();

                    document.querySelectorAll('.plugin-section').forEach(section => {
                        const pluginName = section.querySelector('.plugin-title').textContent
                            .replace(/[^\w\s]/g, '') // Remove emojis
                            .trim()
                            .toLowerCase()
                            .replace(/\s+/g, ''); // Remove spaces

                        const hasEffect = activeEffects.has(pluginName);
                        section.classList.toggle('active', hasEffect);
                    });

                    // Update loop state when selection changes via arrow keys
                    updateLoopState();
                }
            }
        }

        // Middle mouse button drag for panning
        function handleMiddleMouseDown(event) {
            if (event.button === 1) { // Middle mouse button
                event.preventDefault();
                if (!zoomEnabled || currentZoom <= minZoom) return;

                isDragging = true;
                dragStartX = event.clientX;
                dragStartOffset = waveformOffsetX;

                // Change cursor to indicate dragging
                document.body.style.cursor = 'grabbing';
            }
        }

        function handleMiddleMouseMove(event) {
            if (!isDragging) return;

            event.preventDefault();
            const deltaX = event.clientX - dragStartX;
            const container = document.querySelector('#merged .track-content');
            if (!container) return;

            // Convert pixel movement to offset percentage
            const containerWidth = container.offsetWidth;
            const offsetDelta = -(deltaX / containerWidth) * (1 / currentZoom);

            const maxOffset = 1 - (1 / currentZoom);
            waveformOffsetX = Math.max(0, Math.min(maxOffset, dragStartOffset + offsetDelta));

            // Synchronize visualization and clip updates for smooth dragging
            requestAnimationFrame(() => {
                drawVisualization();
                updateClipPositions();
                updatePanButtons();
            });
        }

        function handleMiddleMouseUp(event) {
            if (event.button === 1) { // Middle mouse button
                isDragging = false;
                document.body.style.cursor = '';
            }
        }

        // Check if a MISC clip should be visible based on zoom and viewport
        function shouldMiscClipBeVisible(miscClip) {
            const clipWidth = parseFloat(miscClip.originalWidth.replace('%', ''));
            const clipLeft = parseFloat(miscClip.originalLeft.replace('%', ''));
            const clipId = miscClip.clipId;

            // Check if this is a spec-only clip and spectrogram is not visible
            if (specOnlyMiscClips.has(clipId) && spectrogramOpacity <= 0) {
                return false;
            }

            // Check size threshold: 25% of view OR max zoom
            const sizeThresholdMet = (clipWidth * currentZoom >= 25) || (currentZoom >= maxZoom);
            if (!sizeThresholdMet) return false;

            // Check if in viewport
            const visibleStart = waveformOffsetX * 100;
            const visibleEnd = visibleStart + (100 / currentZoom);
            const clipEnd = clipLeft + clipWidth;

            const inViewport = (clipEnd > visibleStart) && (clipLeft < visibleEnd);

            return inViewport;
        }

        // Update MISC clip visibility based on current zoom and scroll
        function updateMiscClipVisibility() {
            if (mergedMiscClips.length === 0) return;

            mergedMiscClips.forEach(miscClip => {
                const clipId = miscClip.clipId;

                // Check if should be revealed now (but don't show yet - let updateClipPositions handle viewport)
                if (!revealedMiscClips.has(clipId) && shouldMiscClipBeVisible(miscClip)) {
                    revealMiscClipInLayer(miscClip);
                }
            });
        }

        // Reveal a MISC clip with animation
        function revealMiscClipInLayer(miscClip) {
            const element = miscClip.element;
            const clipId = miscClip.clipId;

            // Mark as revealed (permanent)
            revealedMiscClips.add(clipId);

            // Check if in viewport for animation
            const originalLeft = parseFloat(miscClip.originalLeft);
            const originalRight = originalLeft + parseFloat(miscClip.originalWidth);
            const visibleStart = waveformOffsetX * 100;
            const visibleEnd = visibleStart + (100 / currentZoom);
            const isInViewport = !(originalRight < visibleStart || originalLeft > visibleEnd);

            if (isInViewport) {
                // Force show the element for animation (updateClipPositions will manage it after)
                element.style.display = 'flex';

                // Start animation from small scale and transparent
                element.style.transform = 'scale(0.5)';
                element.style.opacity = '0';
                element.style.transition = 'all 0.5s ease-out';
                element.style.zIndex = '50'; // Above regular clips

                // Animate to full size and opacity
                requestAnimationFrame(() => {
                    element.style.transform = 'scale(1.0)';
                    element.style.opacity = '1';

                    // Clean up transition after animation
                    setTimeout(() => {
                        element.style.transition = '';
                    }, 500);
                });
            }
        }

        // Plugin configuration
        const PLUGIN_CONFIG = [
            { id: 'mute', icon: '🔇', name: 'Mute', type: 'toggle', description: 'Toggle clip muting' },
            { id: 'noise', icon: '🌫', name: 'Noise Reduction', type: 'toggle', description: 'Remove noise/reverb/echo' },
            { id: 'voice', icon: '🎤', name: 'Voice Boost', type: 'toggle', description: 'Enhance voice clarity' },
            { id: 'reverse', icon: '↔', name: 'Reverse', type: 'toggle', description: 'Reverse audio playback' },
            { id: 'stereo', icon: '🎧', name: 'Stereo/Mono', type: 'toggle', description: 'Toggle stereo/mono mode' },
            { id: 'volume', icon: '🔊', name: 'Volume', type: 'slider', description: 'Adjust volume levels', range: ['Mute', 'Max'] },
            { id: 'pitch', icon: '🎵', name: 'Pitch', type: 'slider', description: 'Modify pitch', range: ['Lower', 'Higher'] },
            { id: 'speed', icon: '⚡', name: 'Speed', type: 'slider', description: 'Adjust playback speed', range: ['Faster', 'Slower'] },
            { id: 'highpass', icon: '📈', name: 'High Pass', type: 'slider', description: 'High frequency cut-off', range: ['Low', 'High'] },
            { id: 'lowpass', icon: '📉', name: 'Low Pass', type: 'slider', description: 'Low frequency cut-off', range: ['Low', 'High'] },
            { id: 'bitrate', icon: '💾', name: 'Bit Rate', type: 'slider', description: 'Adjust audio quality', range: ['Low', 'High'] }
        ];

        // Add data structure to track effects per clip
        const clipEffects = new Map(); // Maps clip ID to Set of active effects

        // Task hints for each level - Vincent's complete journey
        const TASK_HINTS = {
            // DEMO LEVEL: Viola's First Track
            '0_viola_first_track_demo.wav': {
                guidance: 'Vince: Clean up Viola\'s track and make the vocals pop for me! (Pavel)',
                solution: 'Max vocals volume, de-noise electronics track, mute all MISC noise sounds. Can increase spooky voice volume and reverse it to hear a scary message.'
            },

            // DAY 1: Daily Life
            '1_police_surveillance.wav': {
                guidance: 'Police forensics: clean up surveillance audio from evening bust',
                solution: 'Use the mute tool to remove environmental noise layer, revealing the clear target conversation.'
            },
            '2_mike_evp_debunk.wav': {
                guidance: 'Mike claims EVP recording from old building - needs professional analysis',
                solution: 'Isolate the supposed ghost voices and reveal them as natural building sounds and interference.'
            },

            // DAY 2: Inspiration
            '3_first_viola_restoration.wav': {
                guidance: 'Pavel sent mysterious tape from 1972 - first encounter with Viola Fossati',
                solution: 'Balance the multiple vocal layers and clean analog artifacts. Viola\'s signature is hidden in the studio atmosphere. Check all MISC elements for additional clues.'
            },
            '4_audiophile_forum_test.wav': {
                guidance: 'Forum membership requires passing 25+ technical precision tests',
                solution: 'PRECISION CHALLENGE: Each test signal must be isolated perfectly. Target tiny timing tests, frequency sweeps, and compression artifacts with surgical accuracy.'
            },

            // DAY 3: Finding Viola
            '5_morse_code_test.wav': {
                guidance: 'Viola\'s music contains hidden morse code - multiple layers of reverse engineering',
                solution: 'Complex multi-layer analysis: Reveal both forward and reverse morse signals. Primary coordinates in main morse layer, verification data hidden in backwards signals.'
            },
            '6_coordinate_decode.wav': {
                guidance: 'Complete morse sequence points to Villa Fossati - atmospheric field recording',
                solution: 'Focus on the complete coordinate sequences while preserving the beautiful Ligurian mountain atmosphere. Vincent and Claudia\'s reactions provide context.'
            },

            // DAY 4: Villa Fossati
            '7_villa_sound_lock.wav': {
                guidance: 'Mike found sound-activated lock requiring specific musical sequence',
                solution: 'MECHANICAL PUZZLE: Isolate the required tone sequence (C-E-G-Bb) from mechanical resonance. Balance acoustic environment while targeting precise lock components.'
            },
            '8_police_evidence_analysis.wav': {
                guidance: 'Giorgio provides complete 1987 police case file - 58 evidence pieces',
                solution: 'EVIDENCE ANALYSIS MARATHON: Systematic forensic review across 6 layers. Witness testimonies, crime scene recordings, police communications, forensic details, administrative background. Watch for supernatural MISC hints throughout.'
            },

            // DAY 5: Old Connections
            '9_viola_death_scene.wav': {
                guidance: 'Witness account from Viola\'s neighbor about the night she died',
                solution: 'Clean up the elderly witness testimony and environmental sounds to understand the circumstances of Viola\'s death.'
            },
            '10_vincent_first_composition.wav': {
                guidance: 'Vincent inspired by Viola to attempt his own musical creation',
                solution: 'Balance Vincent\'s creative elements with Viola\'s influence, revealing the supernatural guidance in his composition process.'
            },

            // DAY 6: Tape 1/92
            '11_viola_spoken_recordings.wav': {
                guidance: 'Tape 1 of 92 - Viola\'s final spoken thoughts about her experimental work',
                solution: 'Isolate Viola\'s voice from the distorted background to hear her theories about music and supernatural manipulation.'
            },
            '12_giorgio_diagram_recreation.wav': {
                guidance: 'Giorgio recreates Villa Fossati layout based on police evidence',
                solution: 'Enhance the room acoustics and technical discussion to understand the spatial arrangement of Viola\'s final recording session.'
            },

            // DAY 7: Hello Vincent
            '13_campy_rock_wrongness.wav': {
                guidance: 'Vincent tries different musical styles but something is fundamentally wrong',
                solution: 'Identify and remove the artificial elements to reveal what the supernatural entity is doing to Vincent\'s creative process.'
            },
            '14_mike_voice_deletion.wav': {
                guidance: 'Vincent realizes Mike\'s voice is being systematically erased from recordings',
                solution: 'Recover traces of Mike\'s deleted voice fragments and compare with the entity\'s manipulation patterns.'
            },

            // DAY 8: Losing Control
            '15_entity_multiple_voices.wav': {
                guidance: 'The entity now speaks through multiple familiar voices to control Vincent',
                solution: 'Separate the false voices (Claudia, Giorgio, Pavel) to reveal the entity\'s true nature and Vincent\'s resistance attempts.'
            },

            // DAY 9: Creating the Song
            '16_viola_imprinted_explanation.wav': {
                guidance: 'Viola\'s spirit explains the nature of "The Imprinted" - accumulated human darkness',
                solution: 'Focus on Viola\'s teaching about dark places and supernatural manifestation while noting the entity\'s growing influence.'
            },
            '17_final_song_creation.wav': {
                guidance: 'Vincent creates the final song - THE ULTIMATE CREATION (85+ clips)',
                solution: 'FINAL CHALLENGE: Master all 6 layers. Vincent\'s musical soul (12 clips), Viola\'s experimental methods (11 clips), Imprinted darkness (12 clips), all previous levels echoing (18 clips), technical creation process (16 clips), plus 15 MISC fragments. Perfect surgical precision required.'
            },

            // DAY 10: Final Choice
            '18_password_memory_dig.wav': {
                guidance: 'Vincent must excavate his memories to find the password and access the final folder',
                solution: 'Reconstruct password elements from Vincent\'s life experiences: coordinates, dates, and personal moments to unlock his destiny.'
            }
        };

        // Get clip color by layer ID from current audio config
        function getClipColorByLayer(layerId) {
            // First try to get color from current loaded config
            if (window.currentLayerConfig && window.currentLayerConfig[layerId]) {
                const layer = window.currentLayerConfig[layerId];
                if (layer && layer.color) {
                    return layer.color;
                }
            }

            // Fallback to hardcoded mapping for backwards compatibility
            const layerColors = {
                // Demo Level: Viola's First Track
                'viola-vocals': '#e74c3c',
                'acoustic-instrument': '#27ae60',
                'electronic-elements': '#9b59b6',
                'misc-hidden-elements': '#8e44ad',

                // Level 1: Police Surveillance
                'target-conversation': '#e74c3c',
                'environmental-noise': '#34495e',

                // Level 2: Mike's EVP Session
                'mikes-recording': '#f39c12',
                'environmental-explanation': '#27ae60',

                // Level 3: First Viola Restoration
                'viola-voice': '#e74c3c',
                'tape-degradation': '#95a5a6',
                'studio-atmosphere': '#27ae60',
                'misc-elements': '#8e44ad',

                // Level 4: Forum Entry Test
                'frequency-tests': '#3498db',
                'stereo-tests': '#27ae60',
                'compression-artifacts': '#e67e22',
                'technical-precision': '#9b59b6',

                // Level 5: Morse Code Test
                'viola-surface-layer': '#e74c3c',
                'morse-signals-primary': '#3498db',
                'morse-signals-hidden': '#f39c12',
                'radio-interference': '#95a5a6',

                // Level 6: Coordinate Revelation
                'final-morse': '#3498db',
                'ligurian-atmosphere': '#27ae60',
                'human-presence': '#e74c3c',

                // Level 7: Villa Sound Lock
                'lock-tone-sequence': '#34495e',
                'mechanical-resonance': '#95a5a6',
                'villa-acoustics': '#8e44ad',

                // Level 8: Police Evidence Analysis
                'witness-testimonies': '#e74c3c',
                'crime-scene-audio': '#34495e',
                'police-communications': '#3498db',
                'forensic-details': '#27ae60',
                'administrative-background': '#95a5a6',

                // Level 9: Death Investigation
                'witness-testimony': '#e74c3c',
                'death-night-atmosphere': '#2c3e50',
                'supernatural-hints': '#8e44ad',

                // Level 10: Mike's Basement Session
                'mike-performance': '#f39c12',
                'liguria-memories': '#27ae60',

                // Level 11: Viola's Voice
                'viola-monologue': '#e74c3c',
                'italian-ambience': '#27ae60',

                // Level 12: Waveform Ritual
                'waveform-recreation': '#9b59b6',
                'supernatural-buildup': '#e74c3c',

                // Level 13: Everything's Wrong
                'impossible-song': '#e67e22',
                'reality-glitches': '#9b59b6',

                // Level 14: Mike's Erasure
                'mikes-song': '#f39c12',
                'entity-presence': '#e74c3c',

                // Level 15: Can't Escape
                'entity-claudia': '#e74c3c',
                'entity-giorgio': '#3498db',
                'entity-pavel': '#f39c12',

                // Level 16: Understanding the Imprinted
                'viola-explanation': '#e74c3c',
                'imprinted-essence': '#2c3e50',

                // Level 17: Final Song Creation
                'vincent-musical-soul': '#f39c12',
                'viola-experimental-foundation': '#e74c3c',
                'imprinted-darkness-integration': '#2c3e50',
                'all-previous-levels-echo': '#27ae60',
                'technical-creation-process': '#9b59b6',

                // Level 18: Memory Excavation
                'memory-fragments': '#3498db',
                'password-clues': '#e74c3c',

                // Common layer types across levels
                'misc-elements': '#8e44ad',
                'hidden-details': '#8e44ad'
            };
            return layerColors[layerId] || '#95a5a6'; // Default gray if not found
        }

        // Plugin factory functions
        function createTogglePlugin(plugin) {
            return `
                <div class="plugin-section disabled" onclick="selectPlugin('${plugin.id}')">
                    <div class="plugin-title">${plugin.icon} ${plugin.name}</div>
                    <div style="font-size: 11px; color: var(--text-muted);">${plugin.description}</div>
                    <div class="checkbox"></div>
                </div>
            `;
        }

        function createSliderPlugin(plugin) {
            return `
                <div class="plugin-section disabled">
                    <div class="plugin-title">${plugin.icon} ${plugin.name}</div>
                    <div class="slider-container">
                        <div class="slider-labels">
                            <span>${plugin.range[0]}</span>
                            <span>${plugin.range[1]}</span>
                        </div>
                        <div class="slider-track">
                            <div class="slider-center-mark"></div>
                            <div class="slider-fill"></div>
                            <div class="slider-thumb"></div>
                        </div>
                    </div>
                    <div style="font-size: 11px; color: var(--text-muted);">${plugin.description}</div>
                </div>
            `;
        }

        function generatePluginsHTML(availableTools = []) {
            // Filter plugins to only show available tools for current level
            const filteredPlugins = PLUGIN_CONFIG.filter(plugin =>
                availableTools.length === 0 || availableTools.includes(plugin.id)
            );

            return filteredPlugins.map(plugin =>
                plugin.type === 'slider' ? createSliderPlugin(plugin) : createTogglePlugin(plugin)
            ).join('');
        }

        // Playback state
        let isPlaying = false;
        let currentTime = 0;
        let totalDuration = 47; // Total duration in seconds
        let playbackInterval;
        let playbackSpeed = 1; // Normal speed
        let mainLoopEnabled = false; // Main playback loop state
        let clipLoopEnabled = false; // Clip playback loop state

        // Format time as MM:SS.m
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            const milliseconds = Math.floor((seconds % 1) * 10);
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}.${milliseconds}`;
        }

        // Format time for clips as seconds with 1 decimal place
        function formatClipTime(seconds) {
            return seconds.toFixed(1);
        }

        // Update time display
        function updateTimeDisplay() {
            const timeDisplay = document.querySelector('.time-display');
            timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(totalDuration)}`;
        }

        // Update playback marker position
        function updatePlaybackMarker() {
            const marker = document.getElementById('playback-marker');
            const positionFill = document.getElementById('main-position-fill');
            const percentage = (currentTime / totalDuration) * 100;

            if (marker) {
                marker.style.left = `${percentage}%`;
            }
            if (positionFill) {
                positionFill.style.width = `${percentage}%`;
            }
        }

        function seekToPosition(event) {
            event.stopPropagation();
            const positionBar = event.currentTarget;
            const rect = positionBar.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const percentage = clickX / rect.width;

            currentTime = percentage * totalDuration;
            updateTimeDisplay();
            updatePlaybackMarker();
        }

        // Clip waveform generation
        function generateClipWaveform(clipId) {
            // Create a unique seed based on clip ID for consistent waveforms
            const seed = clipId.split('').reduce((a, b) => a + b.charCodeAt(0), 0);
            const seededRandom = (x) => ((Math.sin(x * seed * 9999) % 1) + 1) / 2;

            // Generate waveform points (using percentages for CSS)
            const points = [];
            const numPoints = 50; // Number of waveform segments

            for (let i = 0; i < numPoints; i++) {
                const x = (i / (numPoints - 1)) * 100; // X position as percentage
                const baseY = 30 + seededRandom(i * 0.3) * 40; // Y height as percentage (30-70%)

                // Add some variation based on clip characteristics
                let amplitude = 1;
                if (clipId.includes('whisper') || clipId.includes('breath')) amplitude = 0.6;
                if (clipId.includes('scream') || clipId.includes('crash')) amplitude = 1.4;
                if (clipId.includes('static') || clipId.includes('noise')) amplitude = 0.8;

                const finalY = 50 + (baseY - 50) * amplitude;
                points.push(`${x}% ${Math.max(10, Math.min(90, finalY))}%`);
            }

            return `polygon(${points.join(', ')})`;
        }

        // Apply waveform to clip
        function applyWaveformToClip(clipElement) {
            let clipId = clipElement.dataset.clip;

            // For selected clip waveform, get the clip ID from the selected clip
            if (!clipId && selectedClip) {
                clipId = selectedClip.dataset.clip;
            }

            if (!clipId) return;

            // Remove existing waveform
            const existingWaveform = clipElement.querySelector('.clip-waveform');
            if (existingWaveform) {
                existingWaveform.remove();
            }

            // Create new waveform element
            const waveform = document.createElement('div');
            waveform.className = 'clip-waveform';
            waveform.style.clipPath = generateClipWaveform(clipId);
            clipElement.appendChild(waveform);
        }

        // Apply waveforms to all clips
        function applyWaveformsToAllClips() {
            document.querySelectorAll('.audio-clip').forEach(clip => {
                applyWaveformToClip(clip);
            });
        }

        // VU Meter animation functions
        function startVUMeterAnimation() {
            if (vuMeterInterval) clearInterval(vuMeterInterval);

            vuMeterInterval = setInterval(() => {
                // Simulate realistic VU meter behavior with music-like patterns
                const time = Date.now() / 100; // Smooth time progression

                // Base level with realistic variation
                let baseLeft = 0.3 + Math.sin(time * 0.1) * 0.1;
                let baseRight = 0.25 + Math.cos(time * 0.12) * 0.1;

                // Add transients and peaks (simulating drums, etc.)
                if (Math.random() < 0.05) { // Occasional peaks
                    baseLeft += Math.random() * 0.4;
                    baseRight += Math.random() * 0.4;
                }

                // Add frequency-based variation
                baseLeft += Math.sin(time * 0.3) * 0.15;
                baseRight += Math.cos(time * 0.35) * 0.15;

                // Clamp values and add some stereo difference
                vuLeftLevel = Math.max(0, Math.min(1, baseLeft + Math.random() * 0.1));
                vuRightLevel = Math.max(0, Math.min(1, baseRight + Math.random() * 0.1));

                updateVUMeters();
            }, 50); // 20fps for smooth animation
        }

        function stopVUMeterAnimation() {
            if (vuMeterInterval) {
                clearInterval(vuMeterInterval);
                vuMeterInterval = null;
            }

            // Fade out VU meters
            const fadeOut = setInterval(() => {
                vuLeftLevel *= 0.9;
                vuRightLevel *= 0.9;
                updateVUMeters();

                if (vuLeftLevel < 0.01 && vuRightLevel < 0.01) {
                    clearInterval(fadeOut);
                    vuLeftLevel = 0;
                    vuRightLevel = 0;
                    vuLeftPeakHold = 0;
                    vuRightPeakHold = 0;
                    updateVUMeters();
                }
            }, 50);
        }

        function updateVUMeters() {
            const leftFill = document.querySelector('#vu-left .vu-fill');
            const rightFill = document.querySelector('#vu-right .vu-fill');
            const leftPeak = document.querySelector('#vu-left .vu-peak');
            const rightPeak = document.querySelector('#vu-right .vu-peak');

            if (leftFill) {
                leftFill.style.height = `${vuLeftLevel * 100}%`;
            }
            if (rightFill) {
                rightFill.style.height = `${vuRightLevel * 100}%`;
            }

            // Update peak hold indicators
            if (vuLeftLevel > vuLeftPeakHold) {
                vuLeftPeakHold = vuLeftLevel;
            } else {
                vuLeftPeakHold *= 0.995; // Slow decay
            }

            if (vuRightLevel > vuRightPeakHold) {
                vuRightPeakHold = vuRightLevel;
            } else {
                vuRightPeakHold *= 0.995; // Slow decay
            }

            if (leftPeak) {
                leftPeak.style.top = `${100 - (vuLeftPeakHold * 100)}%`;
                leftPeak.style.opacity = vuLeftPeakHold > 0.05 ? '0.8' : '0';
            }
            if (rightPeak) {
                rightPeak.style.top = `${100 - (vuRightPeakHold * 100)}%`;
                rightPeak.style.opacity = vuRightPeakHold > 0.05 ? '0.8' : '0';
            }
        }

        // Toggle playback
        function toggleMainPlayback(event) {
            event.stopPropagation();



            isPlaying = !isPlaying;
            isMainPlaying = isPlaying;

            // Update button icon
            const playBtn = event.target;
            playBtn.textContent = isPlaying ? '⏸' : '▶';

            if (isPlaying) {
                // Start VU meter animation
                startVUMeterAnimation();

                // Start playback
                playbackInterval = setInterval(() => {
                    currentTime += 0.1 * playbackSpeed;

                    // Check boundaries - either clip focus mode or full track
                    const maxTime = clipFocusMode ? focusedClipEnd : totalDuration;

                    if (currentTime >= maxTime) {
                        // Check current loop state dynamically
                        const loopCheckbox = document.getElementById('main-loop-checkbox');
                        const currentLoopState = loopCheckbox ? loopCheckbox.checked : false;

                        if (currentLoopState) {
                            // Loop: reset to start (either clip start or track start)
                            currentTime = clipFocusMode ? focusedClipStart : 0;
                        } else {
                            // No loop: stop playback and update button
                            isPlaying = false;
                            isMainPlaying = false;
                            clearInterval(playbackInterval);
                            currentTime = clipFocusMode ? focusedClipStart : 0;
                            updateTimeDisplay();
                            updatePlaybackMarker();

                            // Stop VU meter animation
                            stopVUMeterAnimation();

                            // Update play button icon
                            playBtn.textContent = '▶';
                            return;
                        }
                    }
                    updateTimeDisplay();
                    updatePlaybackMarker();
                }, 100);
            } else {
                // Pause playback
                clearInterval(playbackInterval);
                // Stop VU meter animation
                stopVUMeterAnimation();
            }
        }

        // Pause main playback (without resetting time)
        function pauseMainPlayback() {
            isPlaying = false;
            clearInterval(playbackInterval);

            // Update play button icon
            const playBtn = document.querySelector('#main-buttons .transport-btn:first-child');
            playBtn.textContent = '▶';
        }

        // Stop playback
        function stopMainPlayback(event) {
            event.stopPropagation();
            isPlaying = false;
            isMainPlaying = false;
            clearInterval(playbackInterval);
            currentTime = clipFocusMode ? focusedClipStart : 0;
            updateTimeDisplay();
            updatePlaybackMarker();

            // Stop VU meter animation
            stopVUMeterAnimation();

            // Reset play button icon
            const playBtn = document.querySelector('#main-buttons .transport-btn:first-child');
            playBtn.textContent = '▶';
        }

        // Seek to start - jump to previous clip like left arrow key
        function seekToStart(event) {
            event.stopPropagation();
            jumpToClip('left');
        }

        // Seek to end - jump to next clip like right arrow key  
        function seekToEnd(event) {
            event.stopPropagation();
            jumpToClip('right');
        }

        // Real-time Analysis function - progressive revelation during playback
        async function realTimeAnalysis(event) {
            event.stopPropagation();

            if (!window.currentLayerConfig) {
                console.error('No layer configuration loaded');
                return;
            }

            // Remove the button overlay
            const analyzeOverlay = event.target.closest('.analyze-overlay');
            if (analyzeOverlay) {
                analyzeOverlay.remove();
            }

            // Enter analysis mode
            isAnalyzing = true;
            analysisStartTime = Date.now();

            // Reset revelation tracking
            revealedClips.clear();
            revealedLayers.clear();

            // IMPORTANT: Remove all existing layers completely to ensure clean slate
            const trackLayers = document.querySelectorAll('.track-layer:not(#merged)');
            trackLayers.forEach(layer => {
                layer.remove();
            });

            // Clear merged track of existing clips
            const mergedTrack = document.getElementById('merged');
            const existingClips = mergedTrack.querySelectorAll('.audio-clip');
            existingClips.forEach(clip => clip.remove());

            // Clear any existing MISC clips data
            mergedMiscClips.length = 0;
            revealedMiscClips.clear();
            specOnlyMiscClips.clear();

            // Clear original clip data
            originalClipData.clear();

            // Disable all controls during analysis
            disableControlsDuringAnalysis();

            // Apply analysis mode styling to playhead
            const playhead = document.getElementById('playback-marker');
            if (playhead) {
                playhead.classList.add('analysis-mode');
            }

            // Separate clips by type for processing
            const regularClips = [];
            const miscClips = [];

            Object.entries(window.currentLayerConfig).forEach(([layerId, layerConfig]) => {
                layerConfig.clips.forEach(clip => {
                    const clipData = { ...clip, layerId, layerConfig };
                    if (clip.type === 'large') {
                        regularClips.push(clipData);
                    } else if (clip.type === 'small') {
                        miscClips.push(clipData);
                    }
                });
            });

            // Create MISC layers (but keep them hidden) - these won't have clips in merged view
            const miscLayers = createMiscLayers(miscClips);
            miscLayers.forEach(miscLayer => {
                createMiscLayerHidden(miscLayer);
            });

            // Start analysis playback
            startAnalysisPlayback(regularClips, miscClips, miscLayers);
        }

        // Auto-analysis function (for menu)
        function autoAnalyzeAll() {
            // Use the same real-time analysis process
            const fakeEvent = {
                stopPropagation: () => { },
                target: { closest: () => document.querySelector('.analyze-overlay') }
            };
            realTimeAnalysis(fakeEvent);
        }

        // Disable controls during analysis to prevent interruption
        function disableControlsDuringAnalysis() {
            // Disable all transport buttons
            document.querySelectorAll('#main-buttons button').forEach(button => {
                button.disabled = true;
            });

            // Disable loop checkbox
            const loopCheckbox = document.getElementById('main-loop-checkbox');
            if (loopCheckbox) {
                loopCheckbox.disabled = true;
            }

            // Disable solo checkbox
            const soloCheckbox = document.getElementById('main-solo-checkbox');
            if (soloCheckbox) {
                soloCheckbox.disabled = true;
            }

            // Disable zoom and pan controls
            document.querySelectorAll('.zoom-btn, .pan-btn').forEach(button => {
                button.disabled = true;
                button.style.pointerEvents = 'none';
                button.style.opacity = '0.3';
            });

            // Disable view mode controls
            const opacitySlider = document.getElementById('opacity-slider');
            if (opacitySlider) {
                opacitySlider.disabled = true;
                opacitySlider.style.pointerEvents = 'none';
                opacitySlider.style.opacity = '0.3';
            }

            // Disable tools
            document.querySelectorAll('.plugin-section').forEach(section => {
                section.classList.add('disabled');
                section.style.pointerEvents = 'none';
                section.style.opacity = '0.3';
            });
        }

        // Start the analysis playback that reveals clips progressively
        function startAnalysisPlayback(regularClips, miscClips, miscLayers) {
            // Reset playback state
            currentTime = 0;
            updateTimeDisplay();
            updatePlaybackMarker();

            // Start VU meter animation for visual feedback
            startVUMeterAnimation();

            // Create analysis playback loop - uninterruptible, normal speed
            analysisPlaybackInterval = setInterval(() => {
                currentTime += 0.1; // Increment by 100ms (normal speed)

                // Update display and marker
                updateTimeDisplay();
                updatePlaybackMarker();

                // Redraw waveform with progressive revelation
                drawVisualization();

                // Check for clip revelation
                checkClipRevelation(regularClips, miscClips, miscLayers);

                // Check if analysis is complete
                if (currentTime >= totalDuration) {
                    completeAnalysis(miscClips);
                }
            }, 100); // 100ms intervals for smooth playback
        }

        // Check which clips should be revealed at current playhead position
        function checkClipRevelation(regularClips, miscClips, miscLayers) {
            const currentProgress = (currentTime / totalDuration) * 100; // Current position as percentage

            // Check regular clips for revelation
            regularClips.forEach(clipData => {
                const clipLeft = parseFloat(clipData.left.replace('%', ''));
                const clipWidth = parseFloat(clipData.width.replace('%', ''));
                const clipRight = clipLeft + clipWidth;

                // Gradual revelation: reveal clip when playhead touches its left edge
                if (currentProgress >= clipLeft && !revealedClips.has(clipData.id)) {
                    revealRegularClipGradually(clipData);
                }

                // Update gradual revelation progress for clips being revealed
                if (revealedClips.has(clipData.id) && currentProgress >= clipLeft && currentProgress < clipRight) {
                    updateClipGradualReveal(clipData, currentProgress, clipLeft, clipWidth);
                }

                // Name and show in other layers when fully passed
                if (currentProgress >= clipRight && !revealedClips.has(clipData.id + '_completed')) {
                    completeRegularClipRevelation(clipData);
                }
            });

            // Check MISC clips for revelation - show when playhead passes their END
            miscClips.forEach(clipData => {
                const clipLeft = parseFloat(clipData.left.replace('%', ''));
                const clipWidth = parseFloat(clipData.width.replace('%', ''));
                const clipRight = clipLeft + clipWidth;

                // Reveal MISC clip when playhead passes its right edge (end)
                if (currentProgress >= clipRight && !revealedClips.has(clipData.id)) {
                    revealMiscClipInSpecificLayer(clipData, miscLayers);
                }
            });
        }

        // Gradually reveal a regular clip in merged view only (no name, no other layers yet)
        function revealRegularClipGradually(clipData) {
            revealedClips.add(clipData.id);

            // Add clip to merged view without name
            addClipToMergedViewGradually(clipData);
        }

        // Complete revelation when playhead fully passes the clip
        function completeRegularClipRevelation(clipData) {
            revealedClips.add(clipData.id + '_completed');

            // Add name to the clip in merged view
            addNameToMergedClip(clipData);

            // Ensure layer exists and is visible
            ensureLayerVisible(clipData.layerId, clipData.layerConfig);

            // Add clip to its specific layer
            addClipToLayer(clipData);
        }

        // Reveal a MISC clip only in its MISC layer (not in merged view)
        function revealMiscClipInSpecificLayer(clipData, miscLayers) {
            revealedClips.add(clipData.id);

            // Find which MISC layer this clip belongs to
            const miscLayer = miscLayers.find(layer =>
                layer.clips.some(clip => clip.id === clipData.id)
            );

            if (miscLayer) {
                // Ensure MISC layer is visible
                ensureMiscLayerVisible(miscLayer.id);

                // Show the clip in the MISC layer
                const layerElement = document.getElementById(miscLayer.id);
                if (layerElement) {
                    const clipElement = layerElement.querySelector(`[data-clip="${clipData.id}"]`);
                    if (clipElement) {
                        clipElement.style.display = 'flex';
                        animateClipReveal(clipElement);
                    }
                }
            }
        }

        // Ensure a regular layer is visible, create if needed
        function ensureLayerVisible(layerId, layerConfig) {
            if (revealedLayers.has(layerId)) return; // Already visible

            revealedLayers.add(layerId);

            let layerElement = document.getElementById(layerId);
            if (!layerElement) {
                // Create the layer if it doesn't exist
                layerElement = createRegularLayerHidden(layerId, []);
            }

            // Make layer visible with animation
            layerElement.style.display = 'flex';
            animateLayerReveal(layerElement);
        }

        // Ensure a MISC layer is visible
        function ensureMiscLayerVisible(miscLayerId) {
            if (revealedLayers.has(miscLayerId)) return; // Already visible

            revealedLayers.add(miscLayerId);

            const layerElement = document.getElementById(miscLayerId);
            if (layerElement) {
                layerElement.style.display = 'flex';
                animateLayerReveal(layerElement);
            }
        }

        // Add a clip to the merged view gradually (without name)
        function addClipToMergedViewGradually(clipData) {
            const mergedTrack = document.querySelector('#merged .track-content');
            if (!mergedTrack) return;

            // Create clip element without name, starting with 0 width
            const clipElement = document.createElement('div');
            clipElement.className = 'audio-clip revealed gradual-reveal';
            clipElement.dataset.clip = clipData.id;
            clipElement.dataset.layer = clipData.layerId;
            clipElement.style.left = clipData.left;
            clipElement.style.width = '0%'; // Start with 0 width
            clipElement.textContent = ''; // No name initially

            // Store the target width for progressive reveal
            clipElement.dataset.targetWidth = clipData.width;

            // Position in merged view using layer config
            const clipHash = clipData.id.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
            const verticalVariation = (clipHash % 30) - 15;
            clipElement.style.top = `${clipData.layerConfig.baseHeight + verticalVariation}px`;

            mergedTrack.appendChild(clipElement);

            // Apply waveform and animate reveal
            applyWaveformToClip(clipElement);
            animateClipReveal(clipElement);

            // Store for zoom functionality
            const left = parseFloat(clipData.left.replace('%', ''));
            const width = parseFloat(clipData.width.replace('%', ''));
            originalClipData.set(clipData.id, {
                left: left,
                width: width,
                element: clipElement
            });
        }

        // Update the gradual reveal progress of a clip
        function updateClipGradualReveal(clipData, currentProgress, clipLeft, clipWidth) {
            const mergedTrack = document.querySelector('#merged .track-content');
            if (!mergedTrack) return;

            const clipElement = mergedTrack.querySelector(`[data-clip="${clipData.id}"]`);
            if (!clipElement) return;

            // Calculate how much of the clip has been revealed (0-1)
            const clipProgress = (currentProgress - clipLeft) / clipWidth;
            const revealedPercent = Math.min(Math.max(clipProgress, 0), 1);

            // Get the target width and calculate current revealed width
            const targetWidth = parseFloat(clipElement.dataset.targetWidth.replace('%', ''));
            const currentWidth = targetWidth * revealedPercent;

            // Update clip width to show only the revealed portion
            clipElement.style.width = `${currentWidth}%`;
        }

        // Add name to an existing clip in merged view
        function addNameToMergedClip(clipData) {
            const mergedTrack = document.querySelector('#merged .track-content');
            if (!mergedTrack) return;

            const clipElement = mergedTrack.querySelector(`[data-clip="${clipData.id}"]`);
            if (clipElement) {
                // Set the clip to its full target width since it's now fully revealed
                clipElement.style.width = clipElement.dataset.targetWidth;

                clipElement.textContent = clipData.id;
                // Add a subtle animation when name appears
                clipElement.style.transition = 'all 0.3s ease-out';
                clipElement.style.transform = 'scale(1.05)';
                setTimeout(() => {
                    clipElement.style.transform = 'scale(1)';
                    setTimeout(() => {
                        clipElement.style.transition = '';
                    }, 300);
                }, 100);
            }
        }

        // Add a clip to its specific layer
        function addClipToLayer(clipData) {
            const layerElement = document.getElementById(clipData.layerId);
            if (!layerElement) {
                console.warn(`❌ Layer not found: ${clipData.layerId}`);
                return;
            }

            const trackContent = layerElement.querySelector('.track-content');
            if (!trackContent) {
                console.warn(`❌ Track content not found in layer: ${clipData.layerId}`);
                return;
            }

            // Check if clip already exists in layer
            if (trackContent.querySelector(`[data-clip="${clipData.id}"]`)) {
                console.warn(`⚠️  Clip already exists in layer: ${clipData.id}`);
                return;
            }

            // Create clip element for layer
            const clipElement = document.createElement('div');
            clipElement.className = 'audio-clip';
            clipElement.dataset.clip = clipData.id;
            clipElement.style.left = clipData.left;
            clipElement.style.width = clipData.width;
            clipElement.style.height = '18px';
            clipElement.style.top = '6px';
            clipElement.title = clipData.title || clipData.id;
            clipElement.textContent = clipData.id;

            trackContent.appendChild(clipElement);

            // Apply waveform and animate reveal
            applyWaveformToClip(clipElement);
            animateClipReveal(clipElement);

            // Mark as discovered for tools
            discoveredClips.add(clipData.id);
        }

        // Animate clip reveal with subtle effect
        function animateClipReveal(clipElement) {
            clipElement.style.transform = 'scale(0.8)';
            clipElement.style.opacity = '0';

            requestAnimationFrame(() => {
                clipElement.style.transition = 'all 0.3s ease-out';
                clipElement.style.transform = 'scale(1)';
                clipElement.style.opacity = '1';

                setTimeout(() => {
                    clipElement.style.transition = '';
                }, 300);
            });
        }

        // Animate layer reveal
        function animateLayerReveal(layerElement) {
            layerElement.style.opacity = '0';
            layerElement.style.transform = 'translateY(-10px)';

            requestAnimationFrame(() => {
                layerElement.style.transition = 'all 0.4s ease-out';
                layerElement.style.opacity = '1';
                layerElement.style.transform = 'translateY(0)';

                setTimeout(() => {
                    layerElement.style.transition = '';
                }, 400);
            });
        }

        // Complete the analysis process
        function completeAnalysis(miscClips) {


            // Stop analysis playback
            clearInterval(analysisPlaybackInterval);
            analysisPlaybackInterval = null;

            // Stop VU meter
            stopVUMeterAnimation();

            // Exit analysis mode
            isAnalyzing = false;


            // Remove analysis mode styling from playhead
            const playhead = document.getElementById('playback-marker');
            if (playhead) {
                playhead.classList.remove('analysis-mode');
            }

            // Reset playhead to start
            currentTime = 0;
            updateTimeDisplay();
            updatePlaybackMarker();

            // Create MISC clips in merged view for zoom discovery
            const miscClipArray = Array.from(miscClips.values());
            createMergedMiscClips(miscClipArray);

            // Enable all functionality
            isAnalyzed = true;
            enablePlaybackControls();
            enableZoomControls();
            enableTools();
            setupSmallClipDiscovery();

            // Re-enable controls that were disabled during analysis
            enableControlsAfterAnalysis();

            // Store original clip data for zoom functionality
            storeOriginalClipData();

            // Apply waveforms to all clips
            setTimeout(() => {
                applyWaveformsToAllClips();
            }, 100);
        }

        // Re-enable controls after analysis
        function enableControlsAfterAnalysis() {
            // Re-enable zoom and pan controls
            document.querySelectorAll('.zoom-btn, .pan-btn').forEach(button => {
                button.disabled = false;
                button.style.pointerEvents = 'auto';
                button.style.opacity = '1';
            });

            // Re-enable view mode controls
            const opacitySlider = document.getElementById('opacity-slider');
            if (opacitySlider) {
                opacitySlider.disabled = false;
                opacitySlider.style.pointerEvents = 'auto';
                opacitySlider.style.opacity = '1';
            }

            // Tools are enabled separately by enableTools()
        }

        function selectPlugin(pluginName) {
            if (!selectedClip || !isAnalyzed) return;

            const pluginSection = event.target.closest('.plugin-section');
            const isActive = pluginSection.classList.contains('active');
            const clipId = selectedClip.dataset.clip;

            // Initialize effects set for this clip if it doesn't exist
            if (!clipEffects.has(clipId)) {
                clipEffects.set(clipId, new Set());
            }

            const clipEffectSet = clipEffects.get(clipId);

            // Handle mute specifically
            if (pluginName === 'mute') {
                if (isActive) {
                    selectedClip.classList.remove('disabled');
                    clipEffectSet.delete(pluginName);
                } else {
                    selectedClip.classList.add('disabled');
                    clipEffectSet.add(pluginName);
                }
            } else {
                // Toggle effect in our data structure
                if (isActive) {
                    clipEffectSet.delete(pluginName);
                } else {
                    clipEffectSet.add(pluginName);
                }
            }

            // Toggle active state
            pluginSection.classList.toggle('active');

            // Toggle effect on clip
            const effectClass = `clip-${pluginName}`;
            selectedClip.classList.toggle(effectClass);

            // Update effect icons
            updateClipEffects(selectedClip);

            // Also update the clip in the merged view if it exists
            const mergedClip = document.querySelector(`#merged .audio-clip[data-clip="${clipId}"]`);
            if (mergedClip) {
                mergedClip.classList.toggle(effectClass);
            }
        }

        function updateClipEffects(clip) {
            // Remove all existing effect icons
            clip.querySelectorAll('.clip-effect').forEach(icon => icon.remove());

            const clipId = clip.dataset.clip;
            const activeEffects = clipEffects.get(clipId) || new Set();

            // Add icons for each active effect
            const effects = {
                'mute': '🔇',
                'noise': '🌫',
                'voice': '🎤',
                'reverse': '↔',
                'stereo': '🎧',
                'volume': '🔊',
                'pitch': '🎵',
                'speed': '⚡',
                'highpass': '📈',
                'lowpass': '📉',
                'bitrate': '💾'
            };

            let index = 0;
            for (const [effectName, icon] of Object.entries(effects)) {
                if (activeEffects.has(effectName)) {
                    const effectIcon = document.createElement('div');
                    effectIcon.className = 'clip-effect';
                    effectIcon.textContent = icon;
                    effectIcon.style.left = `${2 + (index * 12)}px`;
                    clip.appendChild(effectIcon);
                    index++;
                }
            }
        }

        // Create MISC layers for small clips
        function createMiscLayers(smallClips) {
            const miscLayers = [];

            // Sort clips by their original timeline position to maintain order
            const sortedClips = [...smallClips].sort((a, b) => {
                const leftA = parseFloat(a.left.replace('%', ''));
                const leftB = parseFloat(b.left.replace('%', ''));
                return leftA - leftB;
            });

            // Group clips into MISC layers while preserving their timeline positions
            let miscLayerIndex = 1;
            const clipsPerLayer = Math.ceil(sortedClips.length / Math.max(1, Math.ceil(sortedClips.length / 8))); // ~8 clips per layer max

            for (let i = 0; i < sortedClips.length; i += clipsPerLayer) {
                const layerClips = sortedClips.slice(i, i + clipsPerLayer);

                // Keep original positions - don't repack them to the left
                const miscLayer = {
                    id: `misc-${miscLayerIndex}`,
                    name: `MISC_${miscLayerIndex}`,
                    displayName: `MISC ${miscLayerIndex}`,
                    clips: layerClips.map(clip => ({
                        ...clip,
                        // Preserve original timeline position
                        left: clip.left,
                        width: clip.width
                    })),
                    baseHeight: 50 + (miscLayerIndex - 1) * 60 // Space them out vertically
                };

                miscLayers.push(miscLayer);
                miscLayerIndex++;
            }

            return miscLayers;
        }

        // Perform the stem isolation with loading animation
        async function performStemIsolation(largeClips, smallClips, miscLayers, loadingOverlay) {
            const progressBar = loadingOverlay.querySelector('.progress-bar-fill');
            const statusText = loadingOverlay.querySelector('.isolation-status');
            const layerStatus = loadingOverlay.querySelector('.layer-status');

            const messages = [
                'Analyzing frequency spectrum...',
                'Detecting harmonic patterns...',
                'Separating instrumental stems...',
                'Isolating vocal components...',
                'Processing digital artifacts...',
                'Finalizing layer separation...'
            ];

            // Get regular layers and sort them by displayName to ensure consistent order
            const regularLayers = [...new Set(largeClips.map(clip => clip.layerId))]
                .sort((a, b) => {
                    const layerA = window.currentLayerConfig[a];
                    const layerB = window.currentLayerConfig[b];
                    return layerA.displayName.localeCompare(layerB.displayName);
                });

            const totalSteps = regularLayers.length + miscLayers.length;
            let currentStep = 0;

            // Pre-create all layers in the correct order (but keep them hidden)
            const allLayersInOrder = [...regularLayers, ...miscLayers.map(m => m.id)];
            const createdLayers = [];

            // Create all regular layers first
            for (const layerId of regularLayers) {
                const trackLayer = createRegularLayerHidden(layerId, largeClips.filter(clip => clip.layerId === layerId));
                createdLayers.push(trackLayer);
            }

            // Create all MISC layers
            for (const miscLayer of miscLayers) {
                const trackLayer = createMiscLayerHidden(miscLayer);
                createdLayers.push(trackLayer);
            }

            // Now reveal layers one by one
            for (let i = 0; i < allLayersInOrder.length; i++) {
                const layerId = allLayersInOrder[i];
                const isRegular = regularLayers.includes(layerId);

                if (isRegular) {
                    statusText.textContent = messages[Math.min(currentStep, messages.length - 1)];
                    layerStatus.textContent = `Processing ${layerId.replace('-', ' ')}...`;
                } else {
                    statusText.textContent = 'Cataloging performance artifacts...';
                    layerStatus.textContent = `Creating ${miscLayers.find(m => m.id === layerId).displayName}...`;
                }

                // Step 1: Reveal the empty layer first
                createdLayers[i].style.display = 'flex';

                // Brief pause to show the empty layer
                await new Promise(resolve => setTimeout(resolve, 300));

                // Get actual clips from the DOM layer and sort them left to right
                let sortedClips = [];
                if (isRegular) {
                    // Get clips from the actual layer DOM element
                    const layerElement = createdLayers[i];
                    const clipElements = layerElement.querySelectorAll('.audio-clip');

                    sortedClips = Array.from(clipElements).map(clipEl => {
                        // Find the corresponding config data
                        const configClip = largeClips.find(c => c.id === clipEl.dataset.clip);
                        return {
                            id: clipEl.dataset.clip,
                            left: clipEl.style.left,
                            width: clipEl.style.width,
                            element: clipEl,
                            config: configClip
                        };
                    }).sort((a, b) => {
                        const leftA = parseFloat(a.left.replace('%', ''));
                        const leftB = parseFloat(b.left.replace('%', ''));
                        return leftA - leftB;
                    });
                } else {
                    // For MISC layers, use the provided clips
                    const miscLayer = miscLayers.find(m => m.id === layerId);
                    sortedClips = [...miscLayer.clips].sort((a, b) => {
                        const leftA = parseFloat(a.left.replace('%', ''));
                        const leftB = parseFloat(b.left.replace('%', ''));
                        return leftA - leftB;
                    });
                }

                // Step 2: Fill the layer with clips left-to-right while animating progress
                const clipsDelay = isRegular ? 2100 : 1300; // Reduced to account for the 300ms pause
                const startProgress = (currentStep / totalSteps) * 100;
                const endProgress = ((currentStep + 1) / totalSteps) * 100;

                // Start progress bar animation
                const progressPromise = animateProgressBar(progressBar, startProgress, endProgress, clipsDelay);

                // Reveal clips one by one from left to right (both in layer and merged view)
                const clipsPromise = revealClipsSequentially(layerId, sortedClips, clipsDelay, isRegular);

                // Wait for both to complete
                await Promise.all([progressPromise, clipsPromise]);

                currentStep++;
            }

            // Final completion
            statusText.textContent = 'Stem isolation complete!';
            layerStatus.textContent = 'All audio layers separated successfully.';
            progressBar.style.width = '100%';

            await new Promise(resolve => setTimeout(resolve, 2000)); // Doubled final delay

            // Remove loading overlay
            loadingOverlay.remove();

            // Store original clip data for zoom functionality
            storeOriginalClipData();

            // Enable zoom controls now that clips are available
            enableZoomControls();

            // Create MISC clips in merged view for zoom discovery
            createMergedMiscClips(smallClips);

            // Enable tools
            enableTools();

            // Set up manual discovery for small clips
            setupSmallClipDiscovery();


        }

        // Create a regular layer with large clips (old function for backwards compatibility)
        function createRegularLayer(layerId, layerClips) {
            const trackLayer = createRegularLayerHidden(layerId, layerClips);
            trackLayer.style.display = 'flex';
            addClipsToMergedView(layerId, layerClips);
        }

        // Create a regular layer but keep it hidden initially
        function createRegularLayerHidden(layerId, layerClips) {
            const layerConfig = window.currentLayerConfig[layerId];
            const centerPanel = document.querySelector('.center-panel');

            // Find the last layer to insert after (to maintain order)
            const existingLayers = centerPanel.querySelectorAll('.track-layer:not(#merged)');
            const layersHeader = centerPanel.querySelector('.timeline-header:last-of-type');
            let insertAfter = layersHeader || document.getElementById('merged');

            // If there are existing layers, insert after the last one
            if (existingLayers.length > 0) {
                insertAfter = existingLayers[existingLayers.length - 1];
            }

            // Create a filtered layer config that only contains the large clips
            const filteredLayerConfig = {
                ...layerConfig,
                clips: layerClips // Only the large clips
            };

            // Create the layer with only large clips
            const trackLayer = createTrackLayer(layerId, filteredLayerConfig, centerPanel, insertAfter);

            // Hide all clips initially - they'll be revealed sequentially
            layerClips.forEach(clip => {
                const clipElement = trackLayer.querySelector(`[data-clip="${clip.id}"]`);
                if (clipElement) {
                    clipElement.style.display = 'none';
                    discoveredClips.add(clip.id); // Mark as discovered for tools
                }
            });

            return trackLayer;
        }

        // Add clips to merged view
        function addClipsToMergedView(layerId, layerClips) {
            const layerConfig = window.currentLayerConfig[layerId];

            layerClips.forEach(clip => {
                // Add to merged view
                const mergedClip = document.createElement('div');
                mergedClip.className = 'audio-clip revealed';
                mergedClip.dataset.clip = clip.id;
                mergedClip.dataset.layer = layerId;
                mergedClip.style.left = clip.left;
                mergedClip.style.width = clip.width;

                // Position in merged view
                const clipHash = clip.id.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                const verticalVariation = (clipHash % 30) - 15;
                mergedClip.style.top = `${layerConfig.baseHeight + verticalVariation}px`;
                mergedClip.textContent = clip.id;

                const mergedTrack = document.querySelector('#merged .track-content');
                if (mergedTrack) {
                    mergedTrack.appendChild(mergedClip);
                    // Apply waveform to the new clip
                    applyWaveformToClip(mergedClip);
                }
            });
        }

        // Create a MISC layer with small clips (old function for backwards compatibility)
        function createMiscLayer(miscLayer) {
            const trackLayer = createMiscLayerHidden(miscLayer);
            trackLayer.style.display = 'flex';
        }

        // Create a MISC layer but keep it hidden initially
        function createMiscLayerHidden(miscLayer) {
            const centerPanel = document.querySelector('.center-panel');

            // Find the last layer to insert after (to maintain order)
            const existingLayers = centerPanel.querySelectorAll('.track-layer:not(#merged)');
            const layersHeader = centerPanel.querySelector('.timeline-header:last-of-type');
            let insertAfter = layersHeader || document.getElementById('merged');

            // If there are existing layers, insert after the last one
            if (existingLayers.length > 0) {
                insertAfter = existingLayers[existingLayers.length - 1];
            }

            const trackLayer = document.createElement('div');
            trackLayer.className = 'track-layer misc-layer';
            trackLayer.id = miscLayer.id;

            trackLayer.innerHTML = `
                <div class="track-info">
                    <span style="font-size: 0.8em; color: #95a5a6;">${miscLayer.displayName}</span><br>
                    <span style="font-weight: bold; color: #ecf0f1;">${miscLayer.name}</span>
                </div>
                <div class="track-content" 
                     style="position: relative;"
                     onclick="selectClip(event)">
                    ${miscLayer.clips.map(clip =>
                `<div class="audio-clip hidden-small" 
                              data-clip="${clip.id}"
                              data-layer="${miscLayer.id}"
                              style="left: ${clip.left}; width: ${clip.width}; height: 18px; top: 6px; display: none;" 
                              title="Zoom into the WAV file to find and identify this clip."
                              onclick="showClipPopup(event)">
                            ???
                        </div>`
            ).join('')}
                </div>
            `;

            // Insert after the last existing layer to maintain order
            insertAfter.parentNode.insertBefore(trackLayer, insertAfter.nextSibling);
            trackLayer.style.display = 'none'; // Start hidden

            return trackLayer;
        }

        // Animate progress bar smoothly from start to end percentage over duration
        function animateProgressBar(progressBar, startPercent, endPercent, duration) {
            return new Promise(resolve => {
                const startTime = Date.now();
                const startWidth = startPercent;
                const endWidth = endPercent;
                const totalChange = endWidth - startWidth;

                function updateProgress() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1); // 0 to 1

                    // Easing function for smooth animation (ease-out)
                    const easedProgress = 1 - Math.pow(1 - progress, 3);

                    const currentWidth = startWidth + (totalChange * easedProgress);
                    progressBar.style.width = `${currentWidth}%`;

                    if (progress < 1) {
                        requestAnimationFrame(updateProgress);
                    } else {
                        // Ensure we end at exactly the target
                        progressBar.style.width = `${endWidth}%`;
                        resolve();
                    }
                }

                requestAnimationFrame(updateProgress);
            });
        }

        // Reveal clips in a layer sequentially from left to right
        function revealClipsSequentially(layerId, sortedClips, totalDuration, isRegular) {
            return new Promise(async (resolve) => {
                if (sortedClips.length === 0) {
                    resolve();
                    return;
                }

                // Calculate delay between each clip
                const delayBetweenClips = totalDuration / sortedClips.length;

                for (let i = 0; i < sortedClips.length; i++) {
                    const clip = sortedClips[i];

                    if (isRegular) {
                        // Reveal clip in regular layer using the element reference
                        if (clip.element) {
                            clip.element.style.display = 'flex';

                            // Simultaneously add clip to merged view using config data
                            addSingleClipToMergedView(layerId, clip.config || clip);
                        }
                    } else {
                        // For MISC layers, reveal the ??? clips one by one
                        const miscLayer = document.getElementById(layerId);
                        if (miscLayer) {
                            const clipElement = miscLayer.querySelector(`[data-clip="${clip.id}"]`);
                            if (clipElement) {
                                clipElement.style.display = 'flex';
                            }
                        }
                    }

                    // Wait before revealing next clip (including after the last one)
                    await new Promise(resolve => setTimeout(resolve, delayBetweenClips));
                }

                resolve();
            });
        }

        // Add a single clip to merged view
        function addSingleClipToMergedView(layerId, clip) {
            const layerConfig = window.currentLayerConfig[layerId];

            // Add to merged view
            const mergedClip = document.createElement('div');
            mergedClip.className = 'audio-clip revealed';
            mergedClip.dataset.clip = clip.id;
            mergedClip.dataset.layer = layerId;
            mergedClip.style.left = clip.left;
            mergedClip.style.width = clip.width;

            // Position in merged view
            const clipHash = clip.id.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
            const verticalVariation = (clipHash % 30) - 15;
            mergedClip.style.top = `${layerConfig.baseHeight + verticalVariation}px`;
            mergedClip.textContent = clip.id;

            const mergedTrack = document.querySelector('#merged .track-content');
            if (mergedTrack) {
                mergedTrack.appendChild(mergedClip);
                // Apply waveform to the new clip
                applyWaveformToClip(mergedClip);

                // Update stored clip data if we're already tracking clips
                if (originalClipData.size > 0) {
                    const left = parseFloat(clip.left.replace('%', ''));
                    const width = parseFloat(clip.width.replace('%', ''));
                    originalClipData.set(clip.id, {
                        left: left,
                        width: width,
                        element: mergedClip
                    });
                }
            }
        }

        // Create MISC clips in merged view for zoom discovery
        function createMergedMiscClips(smallClips) {
            const mergedTrack = document.querySelector('#merged .track-content');
            if (!mergedTrack) return;

            // Clear any existing MISC clips
            mergedMiscClips.forEach(miscClip => {
                if (miscClip.element && miscClip.element.parentNode) {
                    miscClip.element.remove();
                }
            });
            mergedMiscClips = [];

            // Randomly select half of the clips to be spec-only
            specOnlyMiscClips.clear();
            if (smallClips.length > 1) {
                const shuffled = [...smallClips].sort(() => Math.random() - 0.5);
                const specOnlyCount = Math.floor(smallClips.length / 2);
                for (let i = 0; i < specOnlyCount; i++) {
                    specOnlyMiscClips.add(shuffled[i].id);
                }
            }

            // Calculate vertical spread for MISC clips
            const trackHeight = 240; // Merged track height
            const clipHeight = 18;
            const margin = 10; // Margin from top and bottom edges
            const availableHeight = trackHeight - (2 * margin) - clipHeight;


            // Create ??? clips for each small clip
            smallClips.forEach((clip, index) => {
                // Create the ??? clip element
                const miscClip = document.createElement('div');
                miscClip.className = 'audio-clip misc-clip-hidden';
                miscClip.dataset.clip = clip.id;
                miscClip.dataset.layer = clip.layerId;
                miscClip.style.left = clip.left;
                miscClip.style.width = clip.width;
                miscClip.style.height = '18px';

                // Distribute clips vertically across available space
                let topPosition;
                if (smallClips.length === 1) {
                    // Single clip: center it
                    topPosition = margin + (availableHeight / 2);
                } else {
                    // Multiple clips: spread them evenly
                    const step = availableHeight / (smallClips.length - 1);
                    topPosition = margin + (index * step);
                }
                miscClip.style.top = `${topPosition}px`;

                miscClip.style.display = 'none'; // Hidden initially
                miscClip.style.zIndex = '50'; // Above regular clips
                miscClip.style.background = '#555';
                miscClip.style.color = '#bbb';
                miscClip.style.border = '2px solid #888';
                miscClip.style.boxShadow = '0 0 0 0.5px rgba(0, 0, 0, 0.9), 0 2px 6px rgba(0, 0, 0, 0.4)';
                miscClip.style.textShadow = '1px 1px 2px rgba(0, 0, 0, 0.9)';
                miscClip.style.pointerEvents = 'auto';
                miscClip.textContent = '???';
                miscClip.title = 'Zoom into the WAV file to find and identify this clip.';

                // Add click handler for popup
                miscClip.addEventListener('click', showClipPopup);

                // Add to merged track
                mergedTrack.appendChild(miscClip);

                // Store tracking data
                mergedMiscClips.push({
                    clipId: clip.id,
                    layerId: clip.layerId,
                    originalLeft: clip.left,
                    originalWidth: clip.width,
                    element: miscClip
                });

                // Add to zoom tracking data so MISC clips scale with zoom
                const left = parseFloat(clip.left.replace('%', ''));
                const width = parseFloat(clip.width.replace('%', ''));
                originalClipData.set(clip.id, {
                    left: left,
                    width: width,
                    element: miscClip
                });
            });
        }

        // Setup manual discovery for small clips in MISC layers
        function setupSmallClipDiscovery() {
            const trackContent = document.querySelector('#merged .track-content');
            if (trackContent && !trackContent.hasAttribute('data-discovery-setup')) {
                trackContent.setAttribute('data-discovery-setup', 'true');
                trackContent.addEventListener('mousedown', startMiscClipIdentification);
                trackContent.addEventListener('mousemove', updateMiscClipIdentification);
                trackContent.addEventListener('mouseup', endMiscClipIdentification);
            }
        }

        // MISC clip identification system (for merged view)
        let miscIdentificationDrawing = false;
        let miscIdentificationBox = null;
        let miscIdentificationStartX = 0;
        let miscIdentificationStartY = 0;

        function startMiscClipIdentification(event) {
            // Only respond to left mouse button (button 0)
            if (event.button !== 0) return;

            // Only work on revealed MISC clips
            const miscClipElements = document.querySelectorAll('#merged .misc-clip-hidden');

            // Check if any revealed clips are visible
            const visibleRevealedClips = Array.from(miscClipElements).filter(clip =>
                clip.style.display === 'flex' && revealedMiscClips.has(clip.dataset.clip)
            );

            // Always allow box drawing for testing, even if no clips available
            miscIdentificationDrawing = true;
            // Find the track content container, not the canvas
            const trackContent = event.target.closest('.track-content') || document.querySelector('#merged .track-content');
            const rect = trackContent.getBoundingClientRect();

            miscIdentificationStartX = event.clientX - rect.left;
            miscIdentificationStartY = event.clientY - rect.top;

            // Clean up existing boxes
            const existingBoxes = trackContent.querySelectorAll('.selection-box');
            existingBoxes.forEach(box => box.remove());

            // Create selection box
            miscIdentificationBox = document.createElement('div');
            miscIdentificationBox.className = 'selection-box';
            trackContent.appendChild(miscIdentificationBox);
        }

        function updateMiscClipIdentification(event) {
            if (!miscIdentificationDrawing || !miscIdentificationBox) {
                return;
            }

            // Use the same track content container we used for the start
            const trackContent = miscIdentificationBox.parentNode;
            const rect = trackContent.getBoundingClientRect();

            const currentX = event.clientX - rect.left;
            const currentY = event.clientY - rect.top;

            const width = Math.abs(currentX - miscIdentificationStartX);
            const height = Math.abs(currentY - miscIdentificationStartY);

            miscIdentificationBox.style.left = Math.min(miscIdentificationStartX, currentX) + 'px';
            miscIdentificationBox.style.top = Math.min(miscIdentificationStartY, currentY) + 'px';
            miscIdentificationBox.style.width = width + 'px';
            miscIdentificationBox.style.height = height + 'px';
        }

        function endMiscClipIdentification(event) {
            if (!miscIdentificationDrawing || !miscIdentificationBox) return;

            // Find overlapping revealed MISC clips in merged view
            const miscClipElements = document.querySelectorAll('#merged .misc-clip-hidden');
            const boxRect = miscIdentificationBox.getBoundingClientRect();

            // Only process clips if there are revealed MISC clips
            if (miscClipElements.length > 0) {
                miscClipElements.forEach(clip => {
                    // Only process revealed clips that are currently visible
                    if (!revealedMiscClips.has(clip.dataset.clip) || clip.style.display !== 'flex') return;

                    const clipRect = clip.getBoundingClientRect();

                    // Check for overlap
                    if (boxRect.left <= clipRect.right && boxRect.right >= clipRect.left &&
                        boxRect.top <= clipRect.bottom && boxRect.bottom >= clipRect.top) {

                        // Identify the clip - reveal its true name and make it editable
                        identifyMiscClip(clip);
                    }
                });
            }

            // Clean up
            if (miscIdentificationBox && miscIdentificationBox.parentNode) {
                miscIdentificationBox.remove();
            }
            miscIdentificationBox = null;
            miscIdentificationDrawing = false;
        }

        function identifyMiscClip(mergedClip) {
            const clipId = mergedClip.dataset.clip;
            const layerId = mergedClip.dataset.layer;

            // Update the merged view clip
            mergedClip.classList.remove('misc-clip-hidden');
            mergedClip.classList.add('identified');
            mergedClip.textContent = ''; // Clear the ??? text since we'll use ::after for the real name
            mergedClip.title = clipId; // Update hover text to show real name
            mergedClip.style.pointerEvents = 'auto';
            mergedClip.style.cursor = 'pointer';

            // Change click handler from showClipPopup to selectClip
            mergedClip.removeEventListener('click', showClipPopup);
            mergedClip.addEventListener('click', selectClip);

            // Get the layer color and apply it
            const clipColor = getClipColorByLayer(layerId);
            mergedClip.style.background = clipColor;
            mergedClip.style.color = '#fff';
            mergedClip.style.border = `2px solid ${clipColor}`;

            // Find and update the corresponding clip in the MISC layer
            const miscLayerClip = document.querySelector(`.misc-layer .audio-clip[data-clip="${clipId}"]`);
            if (miscLayerClip) {
                miscLayerClip.classList.remove('hidden-small');
                miscLayerClip.textContent = clipId; // Show the real name instead of ???
                miscLayerClip.title = clipId; // Update hover text to show real name
                miscLayerClip.style.background = clipColor;
                miscLayerClip.style.color = '#fff';
                miscLayerClip.style.border = `1px solid ${clipColor}`;
                miscLayerClip.style.pointerEvents = 'auto';
                miscLayerClip.style.cursor = 'pointer';

                // Change click handler from showClipPopup to selectClip
                miscLayerClip.removeAttribute('onclick');
                miscLayerClip.onclick = selectClip;
            }

            // Add to discovered clips for tools access
            if (typeof discoveredClips !== 'undefined') {
                discoveredClips.add(clipId);
            }
        }

        // Small clip discovery system
        let discoveryDrawing = false;
        let discoveryBox = null;
        let discoveryStartX = 0;
        let discoveryStartY = 0;

        function startSmallClipSelection(event) {
            // Only respond to left mouse button (button 0)
            if (event.button !== 0) return;

            const hiddenClips = document.querySelectorAll('.audio-clip.hidden-small');
            if (hiddenClips.length === 0) return;

            discoveryDrawing = true;
            const trackContent = event.target;
            const rect = trackContent.getBoundingClientRect();

            discoveryStartX = event.clientX - rect.left;
            discoveryStartY = event.clientY - rect.top;

            // Clean up existing boxes
            const existingBoxes = event.target.querySelectorAll('.selection-box');
            existingBoxes.forEach(box => box.remove());

            // Create selection box
            discoveryBox = document.createElement('div');
            discoveryBox.className = 'selection-box';
            trackContent.appendChild(discoveryBox);
        }

        function updateSmallClipSelection(event) {
            if (!discoveryDrawing || !discoveryBox) return;

            const trackContent = event.target;
            const rect = trackContent.getBoundingClientRect();

            const currentX = event.clientX - rect.left;
            const currentY = event.clientY - rect.top;

            const width = Math.abs(currentX - discoveryStartX);
            const height = Math.abs(currentY - discoveryStartY);

            discoveryBox.style.left = Math.min(discoveryStartX, currentX) + 'px';
            discoveryBox.style.top = Math.min(discoveryStartY, currentY) + 'px';
            discoveryBox.style.width = width + 'px';
            discoveryBox.style.height = height + 'px';
        }

        function endSmallClipSelection(event) {
            if (!discoveryDrawing || !discoveryBox) return;

            // Find overlapping hidden clips
            const hiddenClips = document.querySelectorAll('.misc-layer .audio-clip.hidden-small');
            const boxRect = discoveryBox.getBoundingClientRect();

            hiddenClips.forEach(clip => {
                const clipRect = clip.getBoundingClientRect();

                // Check for overlap
                if (boxRect.left <= clipRect.right && boxRect.right >= clipRect.left &&
                    boxRect.top <= clipRect.bottom && boxRect.bottom >= clipRect.top) {

                    // Reveal the clip
                    clip.classList.remove('hidden-small');
                    clip.textContent = clip.dataset.clip;
                    clip.style.pointerEvents = 'auto';
                    clip.style.background = '';
                    clip.style.color = '';
                    clip.style.border = '';

                    discoveredClips.add(clip.dataset.clip);
                }
            });

            // Clean up
            if (discoveryBox && discoveryBox.parentNode) {
                discoveryBox.remove();
            }
            discoveryBox = null;
            discoveryDrawing = false;
        }



        // AUDIO CONTROL FUNCTIONS
        function toggleTrackMute(trackId) {
            const track = document.getElementById(trackId);
            if (!track) return;

            track.classList.toggle('track-muted');

            // Update mute button
            const muteBtn = track.querySelector('.audio-control[onclick*="toggleTrackMute"]');
            if (muteBtn) {
                if (track.classList.contains('track-muted')) {
                    muteBtn.textContent = '🔇';
                    muteBtn.classList.add('muted');
                } else {
                    muteBtn.textContent = '🔊';
                    muteBtn.classList.remove('muted');
                }
            }
        }

        function toggleTrackSolo(trackId) {
            const track = document.getElementById(trackId);
            if (!track) return;

            track.classList.toggle('track-soloed');

            // Update solo button
            const soloBtn = track.querySelector('.audio-control[onclick*="toggleTrackSolo"]');
            if (soloBtn) {
                if (track.classList.contains('track-soloed')) {
                    soloBtn.textContent = '🎯';
                    soloBtn.classList.add('soloed');
                } else {
                    soloBtn.textContent = 'S';
                    soloBtn.classList.remove('soloed');
                }
            }
        }

        function toggleTrackExpansion(trackId) {
            const track = document.getElementById(trackId);
            if (!track) return;

            track.classList.toggle('track-stereo');

            // Update expansion button
            const expandBtn = track.querySelector('.audio-control[onclick*="toggleTrackExpansion"]');
            if (expandBtn) {
                if (track.classList.contains('track-stereo')) {
                    expandBtn.textContent = '▼';
                } else {
                    expandBtn.textContent = '►';
                }
            }
        }

        // Prevent default drag behavior on document
        document.addEventListener('dragover', function (e) {
            e.preventDefault();
        });

        document.addEventListener('drop', function (e) {
            e.preventDefault();
        });

        function enableTools() {
            isAnalyzed = true;
            document.getElementById('tools-message').textContent = 'Select a clip in a layer to use available tools.';
            document.getElementById('tools-container').style.display = 'block';

            // Show view mode overlay
            const viewModeOverlay = document.getElementById('view-mode-overlay');
            if (viewModeOverlay) {
                viewModeOverlay.style.display = 'flex';
            }

            // Make all clips clickable
            document.querySelectorAll('.audio-clip').forEach(clip => {
                clip.style.pointerEvents = 'auto';
                clip.style.cursor = 'pointer';
            });

            // Enable main playback controls
            enablePlaybackControls();
        }

        function enablePlaybackControls() {
            // Enable all transport buttons
            document.querySelectorAll('#main-buttons button').forEach(button => {
                button.disabled = false;
            });

            // Enable loop checkbox
            const loopCheckbox = document.getElementById('main-loop-checkbox');
            if (loopCheckbox) {
                loopCheckbox.disabled = false;
            }

            // Enable solo checkbox
            const soloCheckbox = document.getElementById('main-solo-checkbox');
            if (soloCheckbox) {
                soloCheckbox.disabled = false;
            }

            // Hide the disabled message
            const disabledMessage = document.querySelector('.playback-disabled-message');
            if (disabledMessage) {
                disabledMessage.style.display = 'none';
            }
        }

        // Clip Focus Mode Functions
        function enterClipFocusMode(clip) {
            clipFocusMode = true;

            // Calculate clip boundaries in absolute timeline position
            const clipLeft = parseFloat(clip.style.left.replace('%', ''));
            const clipWidth = parseFloat(clip.style.width.replace('%', ''));

            focusedClipStart = (clipLeft / 100) * totalDuration;
            focusedClipEnd = ((clipLeft + clipWidth) / 100) * totalDuration;

            // Apply visual effects
            applyClipFocusVisuals(clip, clipLeft, clipWidth);

            // Move playhead to clip start
            currentTime = focusedClipStart;
            updateTimeDisplay();
            updatePlaybackMarker();
        }

        function exitClipFocusMode() {
            clipFocusMode = false;
            focusedClipStart = 0;
            focusedClipEnd = 0;

            // Remove visual effects
            removeClipFocusVisuals();
        }

        function applyClipFocusVisuals(focusedClip, clipLeft, clipWidth) {
            const rootLayer = document.getElementById('merged');
            const trackContent = rootLayer.querySelector('.track-content');

            // Highlight focused clip and lowlight others in root layer
            rootLayer.querySelectorAll('.audio-clip').forEach(clip => {
                if (clip === focusedClip) {
                    clip.classList.add('clip-focused');
                    clip.classList.remove('clip-lowlighted');
                } else {
                    clip.classList.add('clip-lowlighted');
                    clip.classList.remove('clip-focused');
                }
            });

            // Create darkening overlays
            // Left side overlay
            if (clipLeft > 0) {
                const leftOverlay = document.createElement('div');
                leftOverlay.className = 'clip-focus-overlay left-overlay';
                leftOverlay.style.left = '0%';
                leftOverlay.style.width = `${clipLeft}%`;
                trackContent.appendChild(leftOverlay);
            }

            // Right side overlay
            const rightStart = clipLeft + clipWidth;
            if (rightStart < 100) {
                const rightOverlay = document.createElement('div');
                rightOverlay.className = 'clip-focus-overlay right-overlay';
                rightOverlay.style.left = `${rightStart}%`;
                rightOverlay.style.width = `${100 - rightStart}%`;
                trackContent.appendChild(rightOverlay);
            }

            // Create loop point lines
            const inPoint = document.createElement('div');
            inPoint.className = 'clip-focus-line in-point';
            inPoint.style.left = `${clipLeft}%`;
            trackContent.appendChild(inPoint);

            const outPoint = document.createElement('div');
            outPoint.className = 'clip-focus-line out-point';
            outPoint.style.left = `${clipLeft + clipWidth}%`;
            trackContent.appendChild(outPoint);
        }

        function removeClipFocusVisuals() {
            // Remove all clip highlighting/lowlighting
            document.querySelectorAll('.audio-clip').forEach(clip => {
                clip.classList.remove('clip-focused', 'clip-lowlighted');
            });

            // Remove overlays and loop lines
            document.querySelectorAll('.clip-focus-overlay, .clip-focus-line').forEach(element => {
                element.remove();
            });
        }

        function updateClipFocusVisuals() {
            if (!clipFocusMode || !selectedClip) return;

            // Remove existing overlays and lines
            document.querySelectorAll('.clip-focus-overlay, .clip-focus-line').forEach(element => {
                element.remove();
            });

            // Find the focused clip in the root layer (might be different from selectedClip if selected from another layer)
            const rootLayer = document.getElementById('merged');
            const clipId = selectedClip.dataset.clip;
            const rootClip = rootLayer.querySelector(`[data-clip="${clipId}"]`);

            if (!rootClip) return;

            // Get original clip data for comparison
            const originalData = originalClipData.get(clipId);

            // Get current displayed position and width of the focused clip (after zoom/pan transformations)
            const currentLeft = parseFloat(rootClip.style.left.replace('%', ''));
            const currentWidth = parseFloat(rootClip.style.width.replace('%', ''));

            const trackContent = rootLayer.querySelector('.track-content');

            // Enhanced visibility check using ORIGINAL coordinates vs VISIBLE RANGE
            const originalLeft = originalData.left;
            const originalRight = originalData.left + originalData.width;
            const visibleStart = waveformOffsetX * 100;
            const visibleEnd = visibleStart + (100 / currentZoom);

            // Check if clip intersects with visible range in ORIGINAL coordinates
            const isInVisibleRange = !(originalRight <= visibleStart || originalLeft >= visibleEnd);

            // Only create overlays and lines if the clip is visible
            if (isInVisibleRange && rootClip.style.display !== 'none') {
                // Create darkening overlays
                // Left side overlay
                if (currentLeft > 0) {
                    const leftOverlayWidth = Math.max(0, currentLeft);
                    const leftOverlay = document.createElement('div');
                    leftOverlay.className = 'clip-focus-overlay left-overlay';
                    leftOverlay.style.left = '0%';
                    leftOverlay.style.width = `${leftOverlayWidth}%`;
                    trackContent.appendChild(leftOverlay);
                }

                // Right side overlay
                const rightStart = currentLeft + currentWidth;
                if (rightStart < 100) {
                    const rightOverlayLeft = Math.min(100, rightStart);
                    const rightOverlayWidth = Math.max(0, 100 - rightStart);
                    const rightOverlay = document.createElement('div');
                    rightOverlay.className = 'clip-focus-overlay right-overlay';
                    rightOverlay.style.left = `${rightOverlayLeft}%`;
                    rightOverlay.style.width = `${rightOverlayWidth}%`;
                    trackContent.appendChild(rightOverlay);
                }

                // Create loop point lines
                const inPointLeft = Math.max(0, Math.min(100, currentLeft));
                const outPointLeft = Math.max(0, Math.min(100, currentLeft + currentWidth));

                const inPoint = document.createElement('div');
                inPoint.className = 'clip-focus-line in-point';
                inPoint.style.left = `${inPointLeft}%`;
                trackContent.appendChild(inPoint);

                const outPoint = document.createElement('div');
                outPoint.className = 'clip-focus-line out-point';
                outPoint.style.left = `${outPointLeft}%`;
                trackContent.appendChild(outPoint);

            } else if (!isInVisibleRange) {
                // Clip is completely outside viewport - darken the entire timeline
                const fullOverlay = document.createElement('div');
                fullOverlay.className = 'clip-focus-overlay full-overlay';
                fullOverlay.style.left = '0%';
                fullOverlay.style.width = '100%';
                trackContent.appendChild(fullOverlay);
            }
        }

        function selectClip(event) {
            if (!event.target.classList.contains('audio-clip')) {
                return;
            }
            if (!isAnalyzed) {
                return; // Don't allow selection before analysis
            }
            if (event.target.classList.contains('hidden-small')) {
                return; // Don't allow selection of ??? clips
            }
            if (event.target.classList.contains('misc-clip-hidden') && !event.target.classList.contains('identified')) {
                return; // Don't allow selection of unidentified MISC clips
            }

            event.stopPropagation();

            // Exit previous clip focus mode if active
            if (clipFocusMode) {
                exitClipFocusMode();
            }

            // Remove selection from all clips
            document.querySelectorAll('.audio-clip').forEach(clip => {
                clip.classList.remove('selected');
            });

            // Select clicked clip
            event.target.classList.add('selected');
            selectedClip = event.target;

            // Find corresponding clip in root layer for focus mode
            const rootLayer = document.getElementById('merged');
            const isInRootLayer = rootLayer.contains(event.target);

            if (isInRootLayer) {
                // Selected clip is in root layer, use it directly
                enterClipFocusMode(event.target);
            } else {
                // Selected clip is in another layer, find corresponding clip in root layer
                const clipId = event.target.dataset.clip;
                const rootClip = rootLayer.querySelector(`[data-clip="${clipId}"]`);
                if (rootClip) {
                    enterClipFocusMode(rootClip);
                }
            }

            // Update selected clip display
            const selectedClipDisplay = document.getElementById('selected-clip-display');
            const selectedClipName = selectedClipDisplay.querySelector('.selected-clip-name');
            const selectedClipWaveform = selectedClipDisplay.querySelector('.selected-clip-waveform');

            // Set clip name and correct waveform color
            selectedClipName.textContent = selectedClip.dataset.clip;

            // Get the correct color based on the clip's layer
            const clipLayerId = selectedClip.closest('.track-layer').id;
            const clipColor = getClipColorByLayer(clipLayerId);
            selectedClipWaveform.style.background = `linear-gradient(90deg, ${clipColor}22 0%, ${clipColor}11 100%)`;
            selectedClipWaveform.style.color = clipColor;

            // Apply waveform to selected clip display
            applyWaveformToClip(selectedClipWaveform);

            // Show the display and hide the tools message
            selectedClipDisplay.style.display = 'block';
            document.getElementById('tools-message').style.display = 'none';

            // Enable tools and update their active state based on clip effects
            const clipId = selectedClip.dataset.clip;
            const activeEffects = clipEffects.get(clipId) || new Set();


            const pluginSections = document.querySelectorAll('.plugin-section');

            // Check if tools container is visible
            const toolsContainer = document.getElementById('tools-container');

            pluginSections.forEach(section => {
                section.classList.remove('disabled');

                // Explicitly enable pointer events and reset opacity to override any CSS rules
                section.style.pointerEvents = 'auto';
                section.style.opacity = '1';

                // Get the plugin name from the title, removing emoji and spaces
                const pluginName = section.querySelector('.plugin-title').textContent
                    .replace(/[^\w\s]/g, '') // Remove emojis
                    .trim()
                    .toLowerCase()
                    .replace(/\s+/g, ''); // Remove spaces


                // Toggle active state based on whether this effect is in the clip's active effects
                const hasEffect = activeEffects.has(pluginName);
                section.classList.toggle('active', hasEffect);
            });

            // Update loop state based on new selection
            updateLoopState();

            // Update solo state based on new selection
            updateSoloState();
        }

        function deselectClip() {
            if (selectedClip) {
                selectedClip.classList.remove('selected');
                selectedClip = null;

                // Exit clip focus mode
                if (clipFocusMode) {
                    exitClipFocusMode();
                }

                // Hide selected clip display and show tools message
                document.getElementById('selected-clip-display').style.display = 'none';
                const toolsMessage = document.getElementById('tools-message');
                toolsMessage.style.display = 'block';
                toolsMessage.textContent = 'Select a clip to use available tools';

                // Disable tools and reset their appearance
                document.querySelectorAll('.plugin-section').forEach(section => {
                    section.classList.add('disabled');
                    section.classList.remove('active'); // Remove active state to reset color
                    section.style.pointerEvents = 'none'; // Explicitly disable pointer events
                });

                // Update loop state based on deselection
                updateLoopState();

                // Update solo state based on deselection
                updateSoloState();
            }
        }



        // Add click handler to document to deselect when clicking outside or in empty space
        document.addEventListener('click', function (event) {
            // Don't deselect if clicking on tools panel or its buttons
            if (event.target.closest('.right-panel')) {
                return;
            }

            // Don't deselect if clicking on left panel controls or VU meters
            if (event.target.closest('.left-panel')) {
                return;
            }

            // Don't deselect if clicking on interactive elements like buttons or controls
            if (event.target.closest('button, .zoom-controls, .pan-controls, .analyze-overlay, .view-mode-overlay, .opacity-slider, .slider-track, .slider-thumb')) {
                return;
            }

            // Don't deselect if clicking directly on an audio clip
            if (event.target.classList.contains('audio-clip')) {
                return;
            }

            // Deselect if clicking anywhere else (empty space, track content, center panel, etc.)
            deselectClip();
        });

        // Initially disable all clips
        document.querySelectorAll('.audio-clip').forEach(clip => {
            clip.style.pointerEvents = 'none';
            clip.style.cursor = 'default';
        });

        // Add slider functionality
        function initSliders() {
            document.querySelectorAll('.slider-track').forEach(track => {
                const thumb = track.querySelector('.slider-thumb');
                const fill = track.querySelector('.slider-fill');
                const pluginSection = track.closest('.plugin-section');
                let isDragging = false;
                const SNAP_TOLERANCE = 5; // 5% tolerance around center for snapping

                function updateSlider(e, skipSnap = false) {
                    const rect = track.getBoundingClientRect();
                    const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
                    let percent = (x / rect.width) * 100;

                    // Snap to center if within tolerance (unless explicitly skipped)
                    if (!skipSnap && Math.abs(percent - 50) <= SNAP_TOLERANCE) {
                        percent = 50;
                    }

                    // Update slider position
                    fill.style.width = `${percent}%`;
                    thumb.style.left = `${percent}%`;

                    // Update plugin section active state based on position
                    const isAtCenter = Math.abs(percent - 50) < 1; // Very close to center
                    if (isAtCenter) {
                        pluginSection.classList.remove('active');
                    } else {
                        pluginSection.classList.add('active');
                    }

                    // Handle speed slider specifically
                    if (track.closest('.plugin-section').querySelector('.plugin-title').textContent.includes('Speed')) {
                        const clip = document.querySelector('.audio-clip.selected');
                        if (clip) {
                            // Calculate new width based on slider value
                            // 50% = normal speed, 0% = half speed, 100% = double speed
                            const originalWidth = parseFloat(clip.dataset.originalWidth || clip.style.width);
                            const speedFactor = 1 + (percent - 50) / 50; // 0.5 to 1.5
                            clip.style.width = `${originalWidth * speedFactor}%`;
                        }
                    }
                }

                function handleMouseDown(e) {
                    isDragging = true;
                    // Store original width when starting to drag speed slider
                    if (track.closest('.plugin-section').querySelector('.plugin-title').textContent.includes('Speed')) {
                        const clip = document.querySelector('.audio-clip.selected');
                        if (clip && !clip.dataset.originalWidth) {
                            clip.dataset.originalWidth = clip.style.width;
                        }
                    }
                    // Prevent event bubbling to avoid any parent click handlers
                    e.stopPropagation();
                }

                function handleMouseMove(e) {
                    if (isDragging) {
                        updateSlider(e);
                        e.stopPropagation();
                    }
                }

                function handleMouseUp(e) {
                    if (isDragging) {
                        isDragging = false;
                        e.stopPropagation();
                    }
                }

                function handleTrackClick(e) {
                    if (!isDragging) {
                        updateSlider(e);
                    }
                    e.stopPropagation();
                }

                // Event listeners
                thumb.addEventListener('mousedown', handleMouseDown);
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                track.addEventListener('click', handleTrackClick);

                // Prevent plugin section clicks when interacting with sliders
                track.addEventListener('click', (e) => e.stopPropagation());
                thumb.addEventListener('click', (e) => e.stopPropagation());
            });
        }

        // Initialize application
        function initializeApp() {
            // Generate plugins dynamically (initially empty - will be populated when loading audio)
            const toolsContainer = document.getElementById('tools-container');
            if (toolsContainer) {
                toolsContainer.innerHTML = generatePluginsHTML([]);
            }

            // Initialize sliders
            initSliders();

            // Initialize zoom controls
            initializeZoomControls();

            // Initialize waveform canvas
            initializeWaveformCanvas();

            // Setup loop preference tracking
            setupLoopPreferenceTracking();

            // Setup solo preference tracking
            setupSoloPreferenceTracking();

            // Ensure initial loop and solo states are correct
            updateLoopState();
            updateSoloState();

            // Load default file configuration (simplest file)
            const defaultConfig = AUDIO_CONFIGS['0_viola_first_track_demo.wav'];
            if (defaultConfig) {
                loadAudioConfiguration(defaultConfig);
            }

            // Apply waveforms to initial clips
            setTimeout(() => {
                applyWaveformsToAllClips();
            }, 100);
        }

        // Call initialization after the page loads
        window.addEventListener('load', initializeApp);

        // Load menu functionality
        function toggleLoadMenu(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('load-dropdown');
            dropdown.classList.toggle('show');
        }

        // Settings menu functionality
        function toggleSettingsMenu(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('settings-dropdown');
            dropdown.classList.toggle('show');
        }

        // Remove base layer clips from overlay (one-shot)
        function removeBaseOverlay() {
            const mergedTrack = document.querySelector('#merged .track-content');
            if (!mergedTrack) return;

            const baseClips = mergedTrack.querySelectorAll('.audio-clip.revealed');
            baseClips.forEach(clip => {
                clip.remove();
            });
        }

        // Remove base track layers (one-shot)
        function removeBaseTracks() {
            const allLayers = document.querySelectorAll('.track-layer');
            const baseLayers = Array.from(allLayers).filter(layer => {
                return layer.id !== 'merged' && !layer.classList.contains('misc-layer');
            });

            baseLayers.forEach(layer => {
                layer.remove();
            });
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function (event) {
            const loadDropdown = document.getElementById('load-dropdown');
            const loadMenu = event.target.closest('.load-menu');
            const settingsDropdown = document.getElementById('settings-dropdown');
            const settingsMenu = event.target.closest('.settings-menu');

            if (!loadMenu && loadDropdown.classList.contains('show')) {
                loadDropdown.classList.remove('show');
            }

            if (!settingsMenu && settingsDropdown.classList.contains('show')) {
                settingsDropdown.classList.remove('show');
            }
        });

        // Load audio file and reset state
        function loadAudioFile(filename, event) {
            event.stopPropagation();

            // Close dropdown
            document.getElementById('load-dropdown').classList.remove('show');

            // Get configuration for this file
            const config = AUDIO_CONFIGS[filename];
            if (!config) {
                console.error(`No configuration found for ${filename}`);
                return;
            }

            // Reset all application state
            resetApplicationState();

            // Update the application with new configuration
            loadAudioConfiguration(config);
        }

        // Reset entire application state
        function resetApplicationState() {
            // Reset analysis state
            isAnalyzed = false;
            discoveredClips.clear();
            selectedClip = null;
            selectedPlugin = null;

            // Clear all clip effects
            clipEffects.clear();

            // Clear solo preferences
            userSoloPreferences.clear();

            // Clear clip position data
            originalClipData.clear();

            // Reset MISC clip discovery
            mergedMiscClips = [];
            revealedMiscClips.clear();
            specOnlyMiscClips.clear();

            // Disable zoom and hide controls
            zoomEnabled = false;
            const zoomControls = document.querySelector('.zoom-controls');
            const zoomDisplay = document.getElementById('zoom-level-display');
            const viewModeOverlay = document.getElementById('view-mode-overlay');
            if (zoomControls) {
                zoomControls.classList.remove('enabled');
            }
            if (zoomDisplay) {
                zoomDisplay.classList.remove('enabled');
            }
            if (viewModeOverlay) {
                viewModeOverlay.style.display = 'none';
            }

            // Stop any playback
            if (isPlaying) {
                stopMainPlayback({ stopPropagation: () => { } });
            }


            // Reset time
            currentTime = 0;
            updateTimeDisplay();
            updatePlaybackMarker();

            // Reset zoom
            currentZoom = 1.0;
            waveformOffsetX = 0;

            // Reset loop states and checkboxes
            mainLoopEnabled = false;
            const mainLoopCheckbox = document.getElementById('main-loop-checkbox');
            if (mainLoopCheckbox) mainLoopCheckbox.checked = false;

            // Reset solo checkbox
            const mainSoloCheckbox = document.getElementById('main-solo-checkbox');
            if (mainSoloCheckbox) {
                mainSoloCheckbox.checked = false;
                mainSoloCheckbox.disabled = true; // Ensure it's disabled when no clip selected
            }

            // Note: Don't reset view mode here - let loadAudioConfiguration handle it
            // Reset canvas visualization if it exists
            if (waveformCanvas) {
                // Regenerate data for new file
                const currentFile = document.querySelector('#merged .track-info span:first-child')?.textContent || '5_medium_find_the_murderer.wav';
                waveformData = generateWaveformData(currentFile, 10000);
                spectrogramData = generateSpectrogramData(currentFile);
                drawVisualization();
            }

            updateZoomButtons();

            // Hide and remove all dynamic track layers (keep only merged)
            const trackLayers = document.querySelectorAll('.track-layer:not(#merged)');
            trackLayers.forEach(layer => {
                layer.remove();
            });

            // Clear merged view of revealed clips
            const mergedTrack = document.querySelector('#merged .track-content');
            if (mergedTrack) {
                // Remove all revealed clips but preserve the waveform gradient
                mergedTrack.querySelectorAll('.audio-clip').forEach(clip => clip.remove());

                // Restore stem isolation overlay if it doesn't exist
                if (!mergedTrack.querySelector('.analyze-overlay')) {
                    const analyzeOverlay = document.createElement('div');
                    analyzeOverlay.className = 'analyze-overlay';
                    analyzeOverlay.innerHTML = '<button class="analyze-btn" onclick="realTimeAnalysis(event)">Analyze Track</button>';
                    mergedTrack.appendChild(analyzeOverlay);
                }
            }

            // Exit clip focus mode
            if (clipFocusMode) {
                exitClipFocusMode();
            }

            // Reset tools panel
            document.getElementById('tools-message').textContent = 'Run Analyze Track to separate audio layers and unlock tools.';
            document.getElementById('tools-message').style.display = 'block';
            document.getElementById('tools-container').style.display = 'none';
            document.getElementById('selected-clip-display').style.display = 'none';

            // Disable all plugins and reset their state
            document.querySelectorAll('.plugin-section').forEach(section => {
                section.classList.remove('active');
                section.classList.add('disabled');

                // Reset sliders to center position and remove active state
                const sliderFill = section.querySelector('.slider-fill');
                const sliderThumb = section.querySelector('.slider-thumb');
                if (sliderFill && sliderThumb) {
                    sliderFill.style.width = '50%';
                    sliderThumb.style.left = '50%';
                    // Sliders at center should not be active
                    section.classList.remove('active');
                }
            });


        }

        // Load audio configuration and create track structure
        function loadAudioConfiguration(config) {
            // Update total duration
            totalDuration = config.totalDuration;
            updateTimeDisplay();



            // Update file status in left panel
            const currentFileName = document.getElementById('current-file-name');
            const fileStats = document.getElementById('file-stats');
            const fileGoal = document.getElementById('file-goal');

            if (currentFileName) {
                currentFileName.textContent = config.name;
            }
            if (fileStats) {
                fileStats.textContent = `Duration: ${formatTime(config.totalDuration)} • 44.1kHz`;
            }
            if (fileGoal) {
                const taskHint = TASK_HINTS[config.name];
                if (taskHint) {
                    fileGoal.innerHTML = `
                        <div style="margin-bottom: 8px;">
                            <strong>Player Guidance:</strong> ${taskHint.guidance}
                        </div>
                        <div>
                            <strong>Intended Solution:</strong> ${taskHint.solution}
                        </div>
                    `;
                } else {
                    fileGoal.textContent = 'Complete the audio analysis task';
                }
            }

            // Canvas-based waveform is already updated via generateWaveformData

            // Update tools based on available tools for this level
            const toolsContainer = document.getElementById('tools-container');
            if (toolsContainer) {
                toolsContainer.innerHTML = generatePluginsHTML(config.availableTools || []);
                initSliders(); // Re-initialize sliders after regenerating tools
            }

            // Create track layers dynamically
            const centerPanel = document.querySelector('.center-panel');
            const mergedLayer = document.getElementById('merged');

            Object.entries(config.layers).forEach(([layerId, layerConfig]) => {
                createTrackLayer(layerId, layerConfig, centerPanel, mergedLayer);
            });

            // Update global layer config for analysis game
            window.currentLayerConfig = config.layers;

            // Restore opacity preference for this file
            const savedOpacity = viewModePreferences[config.name];
            if (savedOpacity !== undefined) {
                const opacitySlider = document.getElementById('opacity-slider');
                if (opacitySlider) {
                    opacitySlider.value = savedOpacity;
                    updateViewOpacity(savedOpacity);
                }
            } else {
                // Default to 50/50 mix (50)
                const opacitySlider = document.getElementById('opacity-slider');
                if (opacitySlider) {
                    opacitySlider.value = 50;
                    updateViewOpacity(50);
                }
            }

            // Generate both waveform and spectrogram data for the new file
            if (waveformCanvas) {
                waveformData = generateWaveformData(config.name, 10000);
                spectrogramData = generateSpectrogramData(config.name);
                drawVisualization();
            }

            // Apply waveforms to all newly created clips
            setTimeout(() => {
                applyWaveformsToAllClips();
            }, 100);


        }

        // Create a track layer element
        function createTrackLayer(layerId, layerConfig, parentElement, insertAfter) {
            const trackLayer = document.createElement('div');
            trackLayer.className = 'track-layer';
            trackLayer.id = layerId;

            trackLayer.innerHTML = `
                <div class="track-info">
                    <span style="font-size: 0.8em; color: #95a5a6;">${layerConfig.displayName}</span><br>
                    <span style="font-weight: bold; color: #ecf0f1;">${layerConfig.name}</span>
                </div>
                <div class="track-content" 
                     style="position: relative;"
                     onclick="selectClip(event)">
                    ${layerConfig.clips.map(clip =>
                `<div class="audio-clip" 
                              data-clip="${clip.id}"
                              style="left: ${clip.left}; width: ${clip.width}; height: 18px; top: 6px;" 
                              title="${clip.title}">
                            ${clip.id}
                        </div>`
            ).join('')}
                </div>
            `;

            // Insert after the merged layer
            insertAfter.parentNode.insertBefore(trackLayer, insertAfter.nextSibling);

            // Initially hide the layer
            trackLayer.style.display = 'none';

            // Apply waveforms to all clips in this layer
            trackLayer.querySelectorAll('.audio-clip').forEach(clip => {
                applyWaveformToClip(clip);
            });

            // Return the created element
            return trackLayer;
        }


    </script>
</body>

</html>